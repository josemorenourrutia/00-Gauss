import {
  require_Algebra,
  require_Calculus
} from "./chunk-C7WR7DA7.js";
import {
  require_nerdamer_core
} from "./chunk-VJYXX7CH.js";
import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/nerdamer/Solve.js
var require_Solve = __commonJS({
  "node_modules/nerdamer/Solve.js"(exports, module) {
    if (typeof module !== "undefined") {
      nerdamer = require_nerdamer_core();
      require_Calculus();
      require_Algebra();
    }
    var nerdamer;
    (function() {
      var core = nerdamer.getCore(), _ = core.PARSER, _A = core.Algebra, _C = core.Calculus, explode = _C.integration.decompose_arg, evaluate = core.Utils.evaluate, remove = core.Utils.remove, format = core.Utils.format, build = core.Utils.build, knownVariable = core.Utils.knownVariable, Symbol = core.Symbol, isSymbol = core.Utils.isSymbol, variables = core.Utils.variables, S = core.groups.S, PL = core.groups.PL, CB = core.groups.CB, CP = core.groups.CP, FN = core.groups.FN, Settings = core.Settings, range = core.Utils.range, isArray = core.Utils.isArray;
      core.Settings.SOLVE_RADIUS = 1e3;
      core.Settings.ROOTS_PER_SIDE = 10;
      core.Settings.make_pi_conversions = false;
      core.Settings.STEP_SIZE = 0.1;
      core.Settings.EPSILON = 1e-13;
      core.Settings.MAX_NEWTON_ITERATIONS = 200;
      core.Settings.MAX_NON_LINEAR_TRIES = 12;
      core.Settings.NON_LINEAR_JUMP_AT = 50;
      core.Settings.NON_LINEAR_JUMP_SIZE = 100;
      core.Settings.NON_LINEAR_START = 0.01;
      core.Settings.NEWTON_SLICES = 200;
      core.Settings.NEWTON_EPSILON = Number.EPSILON * 2;
      core.Settings.SOLUTION_PROXIMITY = 1e-14;
      core.Settings.FILTER_SOLUTIONS = true;
      core.Settings.MAX_SOLVE_DEPTH = 10;
      core.Settings.ZERO_EPSILON = 1e-9;
      core.Settings.MAX_BISECTION_ITER = 2e3;
      core.Settings.BI_SECTION_EPSILON = 1e-12;
      core.Symbol.prototype.hasTrig = function() {
        return this.containsFunction(["cos", "sin", "tan", "cot", "csc", "sec"]);
      };
      core.Symbol.prototype.hasNegativeTerms = function() {
        if (this.isComposite()) {
          for (var x in this.symbols) {
            var sym = this.symbols[x];
            if (sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))
              return true;
          }
        }
        return false;
      };
      function Equation(lhs, rhs) {
        if (rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) && rhs.isConstant(true) || rhs.equals(core.Settings.IMAGINARY) && lhs.isConstant(true))
          throw new core.exceptions.NerdamerValueError(lhs.toString() + " does not equal " + rhs.toString());
        this.LHS = lhs;
        this.RHS = rhs;
      }
      ;
      Equation.prototype = {
        toString: function() {
          return this.LHS.toString() + "=" + this.RHS.toString();
        },
        text: function(option) {
          return this.LHS.text(option) + "=" + this.RHS.text(option);
        },
        toLHS: function(expand) {
          expand = typeof expand === "undefined" ? true : false;
          var eqn;
          if (!expand) {
            eqn = this.clone();
          } else {
            eqn = this.removeDenom();
          }
          var a = eqn.LHS;
          var b = eqn.RHS;
          if (a.isConstant(true) && !b.isConstant(true)) {
            [a, b] = [b, a];
          }
          var _t = _.subtract(a, b);
          var retval = expand ? _.expand(_t) : _t;
          retval = new Equation(retval, new Symbol(0)).removeDenom().LHS;
          return retval;
        },
        removeDenom: function() {
          var a = this.LHS.clone();
          var b = this.RHS.clone();
          var den = _.multiply(a.getDenom(), b.getDenom());
          a = _.expand(_.multiply(a, den.clone()));
          b = _.expand(_.multiply(b, den));
          if (b.group === CP && b.group !== CP) {
            var t = a;
            a = b;
            b = t;
          }
          if (a.group === CB) {
            var t = new Symbol(a.multiplier), newRHS = b.clone();
            a.each(function(y2) {
              if (y2.power.lessThan(0))
                newRHS = _.divide(newRHS, y2);
              else
                t = _.multiply(t, y2);
            });
            a = t;
            b = newRHS;
          } else if (a.group === CP) {
            for (var x in a.symbols) {
              var sym = a.symbols[x];
              if (sym.group === CB) {
                for (var y in sym.symbols) {
                  var sym2 = sym.symbols[y];
                  if (sym2.power.lessThan(0)) {
                    return new Equation(
                      _.expand(_.multiply(sym2.clone().toLinear(), a)),
                      _.expand(_.multiply(sym2.clone().toLinear(), b))
                    );
                  }
                }
              }
            }
          }
          return new Equation(a, b);
        },
        clone: function() {
          return new Equation(this.LHS.clone(), this.RHS.clone());
        },
        sub: function(x, y) {
          var clone = this.clone();
          clone.LHS = clone.LHS.sub(x.clone(), y.clone());
          clone.RHS = clone.RHS.sub(x.clone(), y.clone());
          return clone;
        },
        isZero: function() {
          return core.Utils.evaluate(this.toLHS()).equals(0);
        },
        latex: function(option) {
          return [this.LHS.latex(option), this.RHS.latex(option)].join("=");
        }
      };
      _.equals = function(a, b) {
        return new Equation(a, b);
      };
      (function() {
        var simplify = _.functions.simplify[0];
        _.functions.simplify[0] = function(symbol) {
          if (symbol instanceof Equation) {
            symbol.LHS = simplify(symbol.LHS);
            symbol.RHS = simplify(symbol.RHS);
            return symbol;
          }
          return simplify(symbol);
        };
      })();
      core.Expression.prototype.equals = function(symbol) {
        if (symbol instanceof core.Expression)
          symbol = symbol.symbol;
        var eq = new Equation(this.symbol, symbol);
        return eq;
      };
      core.Expression.prototype.solveFor = function(x) {
        var symbol;
        if (this.symbol instanceof Equation) {
          if (this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))
            return new core.Expression(this.symbol.LHS);
          if (this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))
            return new core.Expression(this.symbol.RHS);
          symbol = this.symbol.toLHS();
        } else {
          symbol = this.symbol;
        }
        return solve(symbol, x).map(function(x2) {
          return new core.Expression(x2);
        });
      };
      core.Expression.prototype.expand = function() {
        if (this.symbol instanceof Equation) {
          var clone = this.symbol.clone();
          clone.RHS = _.expand(clone.RHS);
          clone.LHS = _.expand(clone.LHS);
          return new core.Expression(clone);
        }
        return new core.Expression(_.expand(this.symbol));
      };
      core.Expression.prototype.variables = function() {
        if (this.symbol instanceof Equation)
          return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));
        return variables(this.symbol);
      };
      var setEq = function(a, b) {
        return _.equals(a, b);
      };
      core.Equation = Equation;
      var checkAll = core.Utils.checkAll = function(args, test) {
        for (var i = 0; i < args.length; i++)
          if (test(args[i]))
            return false;
        return true;
      };
      var __ = core.Solve = {
        version: "2.0.3",
        solutions: [],
        solve: function(eq, variable) {
          var solution = solve(eq, String(variable));
          return new core.Vector(solution);
        },
        /**
         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation
         * @param {Equation|String} eqn
         * @returns {Symbol}
         */
        toLHS: function(eqn, expand) {
          if (isSymbol(eqn))
            return eqn;
          if (!(eqn instanceof Equation)) {
            var es = eqn.split("=");
            es[1] = es[1] || "0";
            eqn = new Equation(_.parse(es[0]), _.parse(es[1]));
          }
          return eqn.toLHS(expand);
        },
        //        getSystemVariables: function(eqns) {
        //            vars = variables(eqns[0], null, null, true);
        //
        //            //get all variables
        //            for (var i = 1, l=eqns.length; i < l; i++)
        //                vars = vars.concat(variables(eqns[i]));
        //            //remove duplicates
        //            vars = core.Utils.arrayUnique(vars).sort();
        //            
        //            //done
        //            return vars;
        //        },
        /**
         * Solve a set of circle equations. 
         * @param {Symbol[]} eqns
         * @returns {Array}
         */
        solveCircle: function(eqns, vars) {
          var svars = vars.map(function(x2) {
            return _.parse(x2);
          });
          var deg = [];
          var solutions = [];
          for (var i = 0; i < eqns.length; i++) {
            var d = [];
            for (var j = 0; j < svars.length; j++) {
              d.push(Number(core.Algebra.degree(eqns[i], svars[j])));
            }
            d.push(core.Utils.arraySum(d, true));
            deg.push(d);
          }
          var a = eqns[0];
          var b = eqns[1];
          if (deg[0][2] > deg[1][2]) {
            [b, a] = [a, b];
            [deg[1], deg[0]] = [deg[0], deg[1]];
          }
          if (deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {
            var x = vars[0];
            var y = vars[1];
            var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function(x2) {
              return x2.toString();
            });
            var x_points = [
              solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()
            ];
            if (y_points[1]) {
              x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());
            }
            if (Settings.SOLUTIONS_AS_OBJECT) {
              var solutions = {};
              solutions[x] = x_points;
              solutions[y] = y_points;
            } else {
              y_points.unshift(y);
              x_points.unshift(x);
              solutions = [x_points, y_points];
            }
          }
          return solutions;
        },
        /**
         * Solve a system of nonlinear equations
         * @param {Symbol[]} eqns The array of equations
         * @param {number} tries The maximum number of tries
         * @param {number} start The starting point where to start looking for solutions
         * @returns {Array}
         */
        solveNonLinearSystem: function(eqns, tries, start) {
          if (tries < 0) {
            return [];
          }
          start = typeof start === "undefined" ? core.Settings.NON_LINEAR_START : start;
          var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;
          var halfway = Math.floor(max_tries / 2);
          tries = typeof tries === "undefined" ? max_tries : tries;
          var jump_at = core.Settings.NON_LINEAR_JUMP_AT;
          var jump = core.Settings.NON_LINEAR_JUMP_SIZE;
          var found = true;
          var create_subs = function(vars2, matrix) {
            return vars2.map(function(x, i) {
              return Number(matrix.get(i, 0));
            });
          };
          var vars = core.Utils.arrayGetVariables(eqns);
          var jacobian = core.Matrix.jacobian(eqns, vars, function(x) {
            return build(x, vars);
          }, true);
          var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;
          var o, y, iters, xn1, norm, lnorm, xn, d;
          var f_eqns = eqns.map(function(eq) {
            return build(eq, vars);
          });
          var J = jacobian.map(function(e) {
            return build(e, vars);
          }, true);
          xn1 = core.Matrix.cMatrix(0, vars);
          var c = core.Matrix.cMatrix(start, vars);
          iters = 0;
          do {
            if (iters > max_iter) {
              break;
              found = false;
            }
            o = create_subs(vars, c);
            xn = c.clone();
            f_eqns.forEach(function(f, i) {
              c.set(i, 0, f.apply(null, o));
            });
            var m = new core.Matrix();
            J.each(function(fn, i, j) {
              var ans = fn.apply(null, o);
              m.set(i, j, ans);
            });
            m = m.invert();
            y = _.multiply(m, c).negate();
            d = y.subtract(xn1, function(x) {
              return _.parse(Number(x));
            });
            xn1 = xn.add(y, function(x) {
              return _.parse(Number(x));
            });
            c = xn1;
            if (iters >= jump_at) {
              if (norm > 1) {
                if (tries === halfway)
                  start = 0;
                var sign = tries > halfway ? 1 : -1;
                n = tries % Math.floor(halfway) + 1;
                start += sign * n * jump;
                return __.solveNonLinearSystem(eqns, --tries, start);
              }
            }
            lnorm = norm;
            iters++;
            norm = d.max();
            if (Number(norm) === Number(lnorm)) {
              break;
            }
          } while (Number(norm) >= Number.EPSILON);
          if (!found)
            return [];
          return __.systemSolutions(c, vars, true, function(x) {
            return core.Utils.round(Number(x), 14);
          });
        },
        systemSolutions: function(result, vars, expand_result, callback) {
          var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];
          result.each(function(e, idx) {
            var solution = (expand_result ? _.expand(e) : e).valueOf();
            if (callback)
              solution = callback.call(e, solution);
            var variable = vars[idx];
            if (core.Settings.SOLUTIONS_AS_OBJECT) {
              solutions[variable] = solution;
            } else
              solutions.push([variable, solution]);
          });
          return solutions;
        },
        /**
         * Solves a system of equations by substitution. This is useful when
         * no distinct solution exists. e.g. a line, plane, etc.
         * @param {Array} eqns
         * @returns {Array}
         */
        solveSystemBySubstitution: function(eqns) {
          var vars_a = variables(eqns[0]);
          var vars_b = variables(eqns[1]);
          if (eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {
            return __.solveCircle(eqns, vars_a);
          }
          return [];
        },
        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf
        /**
         * Solves a systems of equations
         * @param {Array} eqns An array of equations
         * @param {Array} var_array An array of variables
         * @returns {Array|object}
         */
        solveSystem: function(eqns, var_array) {
          for (var i = 0; i < eqns.length; i++)
            eqns[i] = __.toLHS(eqns[i]);
          var l = eqns.length, m = new core.Matrix(), c = new core.Matrix(), expand_result = false, vars;
          if (typeof var_array === "undefined") {
            if (!_A.allLinear(eqns)) {
              try {
                return __.solveNonLinearSystem(eqns);
              } catch (e2) {
                if (e2 instanceof core.exceptions.DivisionByZero) {
                  return __.solveSystemBySubstitution(eqns);
                }
              }
            }
            vars = core.Utils.arrayGetVariables(eqns);
            if (vars.length === 1) {
              var n2 = 0, sol, e;
              do {
                var e = eqns[n2].clone();
                if (n2 > 0) {
                  e = e.sub(vars[0], sol[0]);
                }
                sol = solve(e, vars[0]);
                if (n2 === 0)
                  continue;
              } while (++n2 < eqns.length);
              var solutions;
              if (Settings.SOLUTIONS_AS_OBJECT) {
                solutions = {};
                solutions[vars[0]] = sol;
              } else if (sol.length === 0) {
                solutions = sol;
              } else {
                solutions = [vars[0], sol];
              }
              return solutions;
            }
            if (vars.length < eqns.length) {
              var reduced = [];
              var n2 = eqns.length;
              for (var i = 0; i < n2 - 1; i++) {
                reduced.push(_.parse(eqns[i]));
              }
              var knowns = {};
              var solutions = __.solveSystem(reduced, vars);
              if (Array.isArray(solutions)) {
                solutions.forEach(function(sol2) {
                  knowns[sol2[0]] = sol2[1];
                });
              } else {
                knowns = solutions;
              }
              var all_zero = true;
              for (var i = n2 - 1; i < n2; i++) {
                if (!_.parse(eqns[i], knowns).equals(0)) {
                  all_zero = false;
                }
              }
              if (all_zero) {
                return solutions;
              }
            }
            for (var i = 0; i < vars.length; i++) {
              nerdamer.setVar(vars[i], "delete");
            }
            for (var i = 0; i < l; i++) {
              var e = eqns[i];
              for (var j = 0; j < vars.length; j++) {
                var v = vars[j];
                var coeffs = [];
                e.each(function(x) {
                  if (x.contains(v)) {
                    coeffs = coeffs.concat(x.coeffs());
                  }
                });
                var cf = core.Utils.arraySum(coeffs);
                m.set(i, j, cf);
              }
              var num = e.clone();
              vars.map(function(e2) {
                num = num.stripVar(e2, true);
              });
              c.set(i, 0, num.negate());
            }
          } else {
            vars = var_array;
            expand_result = true;
            for (i = 0; i < l; i++) {
              c.set(i, 0, new Symbol(0));
              var e = _.expand(eqns[i]).collectSymbols();
              for (var j = 0; j < var_array.length; j++) {
                m.set(i, j, new Symbol(0));
                var v = var_array[j];
                for (var k = 0; k < e.length; k++) {
                  var term = e[k], check = false;
                  for (var z = 0; z < var_array.length; z++) {
                    if (term.contains(var_array[z])) {
                      if (check)
                        core.err("Multiple variables found for term " + term);
                      check = true;
                    }
                  }
                  if (term.contains(v)) {
                    var tparts = explode(remove(e, k), v);
                    m.set(i, j, _.add(m.get(i, j), tparts[0]));
                  }
                }
              }
              for (k = 0; k < e.length; k++) {
                c.set(i, 0, _.add(c.get(i, 0), e[k]));
              }
            }
          }
          if (vars.length !== eqns.length || m.determinant().equals(0)) {
            throw new core.exceptions.SolveError("System does not have a distinct solution");
          }
          m = m.invert();
          var result = m.multiply(c);
          if (core.Utils.isArray(var_array))
            result.each(function(x) {
              return x.negate();
            });
          return __.systemSolutions(result, vars, expand_result);
        },
        /**
         * The quadratic function but only one side.
         * @param {Symbol} c
         * @param {Symbol} b
         * @param {Symbol} a
         * @returns {Symbol}
         */
        quad: function(c, b, a) {
          var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)));
          discriminant = _.expand(discriminant);
          var det = _.pow(discriminant, Symbol(0.5));
          var den = _.parse(_.multiply(new Symbol(2), a.clone()));
          var retval = [
            _.parse(format("(-({0})+({1}))/({2})", b, det, den)),
            _.parse(format("(-({0})-({1}))/({2})", b, det, den))
          ];
          return retval;
        },
        /**
         * The cubic equation
         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations
         * @param {Symbol} d_o
         * @param {Symbol} c_o
         * @param {Symbol} b_o
         * @param {Symbol} a_o
         * @returns {Array}
         */
        cubic: function(d_o, c_o, b_o, a_o) {
          var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();
          var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;
          var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;
          var v = `(${b})/(3*(${a}))`;
          var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`;
          var w = "1/2+sqrt(3)/2*i";
          return [
            _.parse(x),
            _.parse(`(${x})(${w})`),
            _.parse(`(${x})(${w})^2`)
          ];
        },
        /**
         * The quartic equation
         * @param {Symbol} e
         * @param {Symbol} d
         * @param {Symbol} c
         * @param {Symbol} b
         * @param {Symbol} a
         * @returns {Array}
         */
        quartic: function(e, d, c, b, a) {
          var scope = {};
          core.Utils.arrayUnique(variables(a).concat(variables(b)).concat(variables(c)).concat(variables(d)).concat(variables(e))).map(function(x) {
            scope[x] = 1;
          });
          a = a.toString();
          b = b.toString();
          c = c.toString();
          d = d.toString();
          e = e.toString();
          var p, q, D, D0, D1, Q, x1, x2, x3, x4;
          p = _.parse(format("(8*({0})*({2})-3*({1})^2)/(8*({0})^2)", a, b, c)).toString();
          q = _.parse(format("(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)", a, b, c, d)).toString();
          D0 = _.parse(format("12*({0})*({4})-3*({1})*({3})+({2})^2", a, b, c, d, e)).toString();
          D1 = _.parse(format("2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})", a, b, c, d, e)).toString();
          Q = _.parse(format("((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)", D0, D1)).toString();
          S = _.parse(format("(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)", a, p, Q, D0)).toString();
          x1 = _.parse(format("-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))", a, b, p, q, S));
          x2 = _.parse(format("-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))", a, b, p, q, S));
          x3 = _.parse(format("-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))", a, b, p, q, S));
          x4 = _.parse(format("-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))", a, b, p, q, S));
          return [x1, x2, x3, x4];
        },
        /**
         * Breaks the equation up in its factors and tries to solve the smaller parts
         * @param {Symbol} symbol
         * @param {String} solve_for
         * @returns {Array}
         */
        divideAndConquer: function(symbol, solve_for) {
          var sols = [];
          var factors = core.Algebra.Factor.factor(symbol);
          if (factors.group === CB) {
            factors.each(function(x) {
              x = Symbol.unwrapPARENS(x);
              sols = sols.concat(solve(x, solve_for));
            });
          }
          return sols;
        },
        /**
         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients
         * @param {Symbol} eq
         * @param {String} solve_for
         * @returns {Array}
         */
        csolve: function(eq, solve_for) {
          return core.Utils.block("IGNORE_E", function() {
            var f, p, pn, n2, pf, r, theta, sr, sp, roots;
            roots = [];
            f = core.Utils.decompose_fn(eq, solve_for, true);
            if (f.x.group === S) {
              p = _.parse(f.x.power);
              pn = Number(p);
              n2 = _.pow(_.divide(f.b.negate(), f.a), p.invert());
              pf = Symbol.toPolarFormArray(n2);
              r = pf[0];
              theta = pf[1];
              sr = r.toString();
              sp = p.toString();
              var k, root, str;
              for (var i = 0; i < pn; i++) {
                k = i;
                str = format("({0})*e^(2*{1}*pi*{2}*{3})", sr, k, p, core.Settings.IMAGINARY);
                root = _.parse(str);
                roots.push(root);
              }
            }
            return roots;
          }, true);
        },
        /**
         * Generates starting points for the Newton solver given an expression at zero.
         * It beings by check if zero is a good point and starts expanding by a provided step size. 
         * Builds on the fact that if the sign changes over an interval then a zero
         * must exist on that interval
         * @param {Symbol} symbol
         * @param {Number} step
         * @param {Array} points
         * @returns {Array}
         */
        getPoints: function(symbol, step, points) {
          step = step || 0.01;
          points = points || [];
          var f = build(symbol);
          var x0 = 0;
          var start = Math.round(x0), last = f(start), last_sign = last / Math.abs(last), rside = core.Settings.ROOTS_PER_SIDE, lside = rside;
          points.push(Math.floor(start / 2));
          points.push(Math.abs(start));
          points.push(start);
          symbol.each(function(x) {
            if (x.containsFunction(core.Settings.LOG))
              points.push(0.1);
          });
          var left = range(-core.Settings.SOLVE_RADIUS, start, step), right = range(start, core.Settings.SOLVE_RADIUS, step);
          var test_side = function(side, num_roots) {
            var xi, val, sign;
            var hits = [];
            for (var i = 0, l = side.length; i < l; i++) {
              xi = side[i];
              val = f(xi);
              sign = val / Math.abs(val);
              if (isNaN(val) || !isFinite(val) || hits.length > num_roots) {
                continue;
              }
              if (sign !== last_sign) {
                hits.push(xi);
              }
              last_sign = sign;
            }
            points = points.concat(hits);
          };
          test_side(left, lside);
          test_side(right, rside);
          return points;
        },
        /**
         * Implements the bisection method. Returns undefined in no solution is found
         * @param {number} point
         * @param {function} f
         * @returns {undefined | number}
         */
        bisection: function(point, f) {
          var left = point - 1;
          var right = point + 1;
          if (Math.sign(f(left)) !== Math.sign(f(right))) {
            var safety = 0;
            var epsilon, middle;
            do {
              epsilon = Math.abs(right - left);
              if (safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {
                return;
              }
              middle = (left + right) / 2;
              if (f(left) * f(middle) > 0) {
                left = middle;
              } else {
                right = middle;
              }
            } while (epsilon >= Settings.EPSILON);
            var solution = (left + right) / 2;
            var x_point = f(solution);
            if (!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {
              return core.Utils.round(solution, 13);
            }
          }
        },
        /**
         * Implements Newton's iterations. Returns undefined if no solutions if found
         * @param {number} point
         * @param {function} f
         * @param {function} fp
         * @returns {undefined|number}
         */
        Newton: function(point, f, fp) {
          var maxiter = core.Settings.MAX_NEWTON_ITERATIONS, iter = 0;
          var x0 = point, x;
          do {
            var fx0 = f(x0);
            if (x0 === 0 && fx0 === 0) {
              x = 0;
              break;
            }
            iter++;
            if (iter > maxiter)
              return;
            x = x0 - fx0 / fp(x0);
            var e = Math.abs(x - x0);
            x0 = x;
          } while (e > Settings.NEWTON_EPSILON);
          if (Math.abs(f(x)) <= Settings.EPSILON)
            return x;
        },
        rewrite: function(rhs, lhs, for_variable) {
          lhs = lhs || new Symbol(0);
          if (rhs.isComposite() && rhs.isLinear()) {
            var sqrts = [];
            var rem = [];
            rhs.each(function(x) {
              x = x.clone();
              if (x.fname === "sqrt" && x.contains(for_variable)) {
                sqrts.push(x);
              } else {
                rem.push(x);
              }
            }, true);
            if (sqrts.length === 1) {
              lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2)));
              rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));
            }
          } else {
            rhs = Symbol.unwrapSQRT(_.expand(rhs));
          }
          var c = 0, l = rhs.length;
          if (rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {
            rhs.distributeMultiplier();
            var t = new Symbol(0);
            rhs.each(function(x) {
              if (x.contains(for_variable)) {
                c++;
                t = _.add(t, x.clone());
              } else
                lhs = _.subtract(lhs, x.clone());
            });
            rhs = t;
            if (c !== l) {
              return __.rewrite(rhs, lhs, for_variable);
            } else {
              return [rhs, lhs];
            }
          } else if (rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {
            if (rhs.multiplier.lessThan(0)) {
              rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));
              lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));
            }
            if (lhs.equals(0))
              return new Symbol(0);
            else {
              var t = new Symbol(1);
              rhs.each(function(x) {
                if (x.contains(for_variable))
                  t = _.multiply(t, x.clone());
                else
                  lhs = _.divide(lhs, x.clone());
              });
              rhs = t;
              return __.rewrite(rhs, lhs, for_variable);
            }
          } else if (!rhs.isLinear() && rhs.contains(for_variable)) {
            var p = _.parse(rhs.power.clone().invert());
            rhs = _.pow(rhs, p.clone());
            lhs = _.pow(_.expand(lhs), p.clone());
            return __.rewrite(rhs, lhs, for_variable);
          } else if (rhs.group === FN || rhs.group === S || rhs.group === PL) {
            return [rhs, lhs];
          }
        },
        sqrtSolve: function(symbol, v) {
          var sqrts = new Symbol(0);
          var rem = new Symbol(0);
          if (symbol.isComposite()) {
            symbol.each(function(x) {
              if (x.fname === "sqrt" && x.contains(v)) {
                sqrts = _.add(sqrts, x.clone());
              } else {
                rem = _.add(rem, x.clone());
              }
            });
            if (!sqrts.equals(0)) {
              var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2)))));
              var solutions = solve(t, v);
              solutions = solutions.filter(function(e) {
                if (e.isImaginary())
                  return e;
                var subs = {};
                subs[v] = e;
                var point = evaluate(symbol, subs);
                if (point.equals(0))
                  return e;
              });
              return solutions;
            }
          }
        }
      };
      var solve = function(eqns, solve_for, solutions, depth, fn) {
        depth = depth || 0;
        if (depth++ > Settings.MAX_SOLVE_DEPTH) {
          return solutions;
        }
        if (eqns instanceof Equation) {
          if (eqns.isZero()) {
            return [new Symbol(0)];
          }
          if (eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {
            return [eqns.RHS];
          }
          if (eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {
            return [eqns.LHS];
          }
        }
        if (eqns instanceof core.Vector)
          eqns = eqns.elements;
        solve_for = solve_for || "x";
        if (isArray(eqns)) {
          return __.solveSystem.apply(void 0, arguments);
        }
        solutions = solutions || [];
        var existing = {};
        var known = {};
        known[solve_for] = 0;
        if (isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {
          return solutions;
        }
        var add_to_result = function(r, has_trig2) {
          var r_is_symbol = isSymbol(r);
          if (r === void 0 || typeof r === "number" && isNaN(r))
            return;
          if (isArray(r)) {
            r.forEach(function(sol) {
              add_to_result(sol);
            });
          } else {
            if (r.valueOf() !== "null") {
              if (typeof core.Settings.PRE_ADD_SOLUTION === "function") {
                r = core.Settings.PRE_ADD_SOLUTION(r);
              }
              if (!r_is_symbol) {
                r = _.parse(r);
              }
              if (core.Settings.make_pi_conversions && has_trig2) {
                var temp = _.divide(r.clone(), new Symbol(Math.PI)), m = temp.multiplier, a = Math.abs(m.num), b = Math.abs(m.den);
                if (a < 10 && b < 10)
                  r = _.multiply(temp, new Symbol("pi"));
              }
              var r_str = r.toString();
              if (!existing[r_str]) {
                solutions.push(r);
              }
              existing[r_str] = true;
            }
          }
        };
        if (eqns.group === S && eqns.contains(solve_for)) {
          try {
            var o = {};
            o[solve_for] = 0;
            evaluate(fn, o, "numer");
            add_to_result(new Symbol(0));
          } catch (e) {
          }
          return solutions;
        }
        if (eqns.group === CB) {
          var num = eqns.getNum();
          if (num.group === CB) {
            var sf = String(solve_for);
            num.each(function(x2) {
              if (x2.contains(sf))
                solve(x2, solve_for, solutions, depth, eqns);
            });
            return solutions;
          }
          return solve(num, solve_for, solutions, depth, fn);
        }
        if (eqns.group === FN && eqns.fname === "sqrt") {
          eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));
        }
        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(), vars = core.Utils.variables(eq), numvars = vars.length;
        if (core.Utils.isInt(eq.power) && eq.power > 0) {
          eq = _.parse(eq).toLinear();
        }
        if (eq.group === S || eq.group === CB && eq.contains(solve_for)) {
          return [new Symbol(0)];
        }
        var fractionals = {}, cfact;
        var correct_denom = function(symbol) {
          symbol = _.expand(symbol, {
            expand_denominator: true,
            expand_functions: true
          });
          var original = symbol.clone();
          if (symbol.symbols) {
            for (var x2 in symbol.symbols) {
              var sym = symbol.symbols[x2];
              var den = sym.getDenom();
              if (!den.isConstant(true) && symbol.isComposite()) {
                var t = new Symbol(0);
                symbol.each(function(e) {
                  t = _.add(t, _.multiply(e, den.clone()));
                });
                return correct_denom(_.multiply(_.parse(symbol.multiplier), t));
              }
              var parts2 = explode(sym, solve_for);
              var is_sqrt = parts2[1].fname === core.Settings.SQRT;
              var v = Symbol.unwrapSQRT(parts2[1]);
              var p2 = v.power.clone();
              if (!isSymbol(p2) && !p2.equals(1 / 2)) {
                if (p2.den.gt(1)) {
                  if (is_sqrt) {
                    symbol = _.subtract(symbol, sym.clone());
                    symbol = _.add(symbol, _.multiply(parts2[0].clone(), v));
                    return correct_denom(symbol);
                  }
                  var c = fractionals[p2.den];
                  fractionals[p2.den] = c ? c++ : 1;
                } else if (p2.sign() === -1) {
                  var factor = _.parse(solve_for + "^" + Math.abs(p2));
                  symbol.each(function(y, index) {
                    if (y.contains(solve_for)) {
                      symbol.symbols[index] = _.multiply(y, factor.clone());
                    }
                  });
                  fractionals = {};
                  return correct_denom(_.parse(symbol));
                } else if (sym.group === PL) {
                  var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));
                  if (min_p < 0) {
                    var factor = _.parse(solve_for + "^" + Math.abs(min_p));
                    var corrected = new Symbol(0);
                    original.each(function(x3) {
                      corrected = _.add(corrected, _.multiply(x3.clone(), factor.clone()));
                    }, true);
                    return corrected;
                  }
                }
              }
            }
          }
          return symbol;
        };
        var separate = function(eq2) {
          var lhs2 = new Symbol(0), rhs2 = new Symbol(0);
          eq2.each(function(x2) {
            if (x2.contains(solve_for, true))
              lhs2 = _.add(lhs2, x2.clone());
            else
              rhs2 = _.subtract(rhs2, x2.clone());
          });
          return [lhs2, rhs2];
        };
        __.inverseFunctionSolve = function(name, lhs2, rhs2) {
          var parts2 = explode(lhs2.args[0], solve_for);
          var x2 = parts2[1];
          if (x2.group === S) {
            return _.divide(_.symfunction(name, [_.divide(rhs2, _.parse(lhs2.multiplier))]), parts2[0]);
          }
        };
        eq = correct_denom(eq);
        if (eq.equals(0))
          return [eq];
        var fkeys = core.Utils.keys(fractionals);
        if (fkeys.length === 1) {
          cfact = fkeys[0];
          eq.each(function(x2, index) {
            if (x2.contains(solve_for)) {
              var parts2 = explode(x2, solve_for);
              var v = parts2[1];
              var p2 = v.power;
              if (p2.den.gt(1)) {
                v.power = p2.multiply(new core.Frac(cfact));
                eq.symbols[index] = _.multiply(v, parts2[0]);
              }
            }
          });
          eq = _.parse(eq);
        }
        add_to_result(__.sqrtSolve(eq, solve_for));
        if (numvars === 1) {
          if (eq.isPoly(true)) {
            var factors = new core.Algebra.Classes.Factors();
            core.Algebra.Factor.factor(eq, factors);
            if (factors.getNumberSymbolics() > 1) {
              for (var x in factors.factors) {
                add_to_result(solve(factors.factors[x], solve_for));
              }
            } else {
              var coeffs = core.Utils.getCoeffs(eq, solve_for), deg = coeffs.length - 1, was_calculated = false;
              if (vars[0] === solve_for) {
                if (checkAll(coeffs, function(x2) {
                  return x2.group !== core.groups.N;
                })) {
                  var roots = core.Algebra.proots(eq);
                  if (checkAll(roots, function(x2) {
                    return !core.Utils.isInt(x2);
                  })) {
                    was_calculated = true;
                    roots.map(function(x2) {
                      add_to_result(new Symbol(x2));
                    });
                  }
                }
                if (!was_calculated) {
                  eqns = _.parse(eqns);
                  if (eqns instanceof core.Equation)
                    eqns = eqns.toLHS();
                  if (deg === 1)
                    add_to_result(_.divide(coeffs[0], coeffs[1].negate()));
                  else if (deg === 2) {
                    add_to_result(_.expand(__.quad.apply(void 0, coeffs)));
                  } else if (deg === 3) {
                    var solutions = [];
                    var factored = core.Algebra.Factor.factor(eqns);
                    var solutions = [];
                    if (solutions.length > 0)
                      add_to_result(solutions);
                    else
                      add_to_result(__.cubic.apply(void 0, coeffs));
                  } else {
                    _A.proots(eq).map(add_to_result);
                  }
                }
              }
            }
          } else {
            try {
              var has_trig = eq.hasTrig();
              var points1 = __.getPoints(eq, 0.1);
              var points2 = __.getPoints(eq, 0.05);
              var points3 = __.getPoints(eq, 0.01);
              var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function(a, b) {
                return a - b;
              });
              var i, point, solution;
              var f = build(eq.clone());
              var t_points = [];
              for (i = 0; i < points.length; i++) {
                point = points[i];
                solution = __.bisection(point, f);
                if (typeof solution === "undefined") {
                  t_points.push(point);
                  continue;
                }
                add_to_result(solution, has_trig);
              }
              points = t_points;
              var d = _C.diff(eq.clone());
              var fp = build(d);
              for (i = 0; i < points.length; i++) {
                point = points[i];
                add_to_result(__.Newton(point, f, fp), has_trig);
              }
              solutions.sort();
            } catch (e) {
              console.log(e);
            }
          }
        } else {
          if (!eq.hasFunc(solve_for) && eq.isComposite()) {
            try {
              var factored = core.Algebra.Factor.factor(eq.clone());
              if (factored.group === CB) {
                factored.each(function(x2) {
                  add_to_result(solve(x2, solve_for));
                });
              } else {
                var coeffs = core.Utils.getCoeffs(eq, solve_for);
                var l = coeffs.length, deg = l - 1;
                switch (deg) {
                  case 0:
                    var separated = separate(eq);
                    var lhs = separated[0], rhs = separated[1];
                    if (lhs.group === core.groups.EX) {
                      var log = core.Settings.LOG;
                      var expr_str = `${log}((${rhs})/(${lhs.multiplier}))/${log}(${lhs.value})/${lhs.power.multiplier}`;
                      add_to_result(_.parse(expr_str));
                    }
                    break;
                  case 1:
                    add_to_result(_.divide(coeffs[0], coeffs[1].negate()));
                    break;
                  case 2:
                    add_to_result(__.quad.apply(void 0, coeffs));
                    break;
                  case 3:
                    add_to_result(__.cubic.apply(void 0, coeffs));
                    break;
                  case 4:
                    add_to_result(__.quartic.apply(void 0, coeffs));
                    break;
                  default:
                    add_to_result(__.csolve(eq, solve_for));
                    if (solutions.length === 0)
                      add_to_result(__.divideAndConquer(eq, solve_for));
                }
                if (solutions.length === 0) {
                  add_to_result(solve(factored, solve_for, solutions, depth));
                }
              }
            } catch (e) {
              ;
            }
          } else {
            try {
              var rw = __.rewrite(eq, null, solve_for);
              var lhs = rw[0];
              var rhs = rw[1];
              if (lhs.group === FN) {
                if (lhs.fname === "abs") {
                  add_to_result([rhs.clone(), rhs.negate()]);
                } else if (lhs.fname === "sin") {
                  add_to_result(__.inverseFunctionSolve("asin", lhs, rhs));
                } else if (lhs.fname === "cos") {
                  add_to_result(__.inverseFunctionSolve("acos", lhs, rhs));
                } else if (lhs.fname === "tan") {
                  add_to_result(__.inverseFunctionSolve("atan", lhs, rhs));
                } else if (lhs.fname === core.Settings.LOG) {
                  var parts = explode(lhs.args[0], solve_for);
                  var x = parts[1];
                  if (x.group === S) {
                    rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol("e"), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);
                    var eq = new Equation(x, rhs).toLHS();
                    add_to_result(solve(eq, solve_for));
                  }
                } else
                  add_to_result(_.subtract(lhs, rhs));
              } else {
                var neq = new Equation(lhs, rhs).toLHS();
                if (neq.equals(eq))
                  throw new Error("Stopping. No stop condition exists");
                add_to_result(solve(neq, solve_for));
              }
            } catch (error) {
              try {
                if (eq.group === CB)
                  add_to_result(0);
                else if (eq.group === CP) {
                  var separated = separate(eq);
                  var lhs = separated[0], rhs = separated[1];
                  if (lhs.group === core.groups.EX && lhs.value === solve_for) {
                    var p = lhs.power.clone().invert();
                    add_to_result(_.pow(rhs, p));
                  }
                }
              } catch (error2) {
                ;
              }
            }
          }
        }
        if (cfact) {
          solutions = solutions.map(function(x2) {
            return _.pow(x2, new Symbol(cfact));
          });
        }
        if (isSymbol(eqns)) {
          var knowns = {};
          solutions = solutions.filter(function(x2) {
            try {
              knowns[solve_for] = x2;
              var zero = Number(evaluate(eqns, knowns));
              if (isNaN(zero)) {
                return true;
              }
              return true;
            } catch (e) {
              return false;
            }
          });
        }
        return solutions;
      };
      nerdamer.register([
        {
          name: "solveEquations",
          parent: "nerdamer",
          numargs: -1,
          visible: true,
          build: function() {
            return solve;
          }
        },
        {
          name: "solve",
          parent: "Solve",
          numargs: 2,
          visible: true,
          build: function() {
            return core.Solve.solve;
          }
        },
        {
          name: "setEquation",
          parent: "Solve",
          visible: true,
          build: function() {
            return setEq;
          }
        }
      ]);
      nerdamer.updateAPI();
    })();
  }
});
export default require_Solve();
//# sourceMappingURL=nerdamer_Solve.js.map
