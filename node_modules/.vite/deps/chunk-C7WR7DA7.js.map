{
  "version": 3,
  "sources": ["../../nerdamer/Calculus.js", "../../nerdamer/Algebra.js"],
  "sourcesContent": ["/* global module */\r\n\r\n/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\nif((typeof module) !== 'undefined' && typeof nerdamer === 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            Frac = core.Frac,\r\n            Settings = core.Settings,\r\n            isSymbol = core.Utils.isSymbol,\r\n            FN = core.groups.FN,\r\n            Symbol = core.Symbol,\r\n            text = core.Utils.text,\r\n            inBrackets = core.Utils.inBrackets,\r\n            isInt = core.Utils.isInt,\r\n            format = core.Utils.format,\r\n            even = core.Utils.even,\r\n            evaluate = core.Utils.evaluate,\r\n            N = core.groups.N,\r\n            S = core.groups.S,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            EX = core.groups.EX,\r\n            P = core.groups.P,\r\n            LOG = Settings.LOG,\r\n            EXP = 'exp',\r\n            ABS = 'abs',\r\n            SQRT = 'sqrt',\r\n            SIN = 'sin',\r\n            COS = 'cos',\r\n            TAN = 'tan',\r\n            SEC = 'sec',\r\n            CSC = 'csc',\r\n            COT = 'cot',\r\n            ASIN = 'asin',\r\n            ACOS = 'acos',\r\n            ATAN = 'atan',\r\n            ASEC = 'asec',\r\n            ACSC = 'acsc',\r\n            ACOT = 'acot',\r\n            SINH = 'sinh',\r\n            COSH = 'cosh',\r\n            TANH = 'tanh',\r\n            CSCH = 'csch',\r\n            SECH = 'sech',\r\n            COTH = 'coth',\r\n            ASECH = 'asech',\r\n            ACSCH = 'acsch',\r\n            ACOTH = 'acoth';\r\n\r\n    //custom errors\r\n    function NoIntegralFound(msg) {\r\n        this.message = msg || \"\";\r\n    }\r\n    NoIntegralFound.prototype = new Error();\r\n\r\n    //Preparations\r\n    Symbol.prototype.hasIntegral = function () {\r\n        return this.containsFunction('integrate');\r\n    };\r\n    //transforms a function\r\n    Symbol.prototype.fnTransform = function () {\r\n        if(this.group !== FN)\r\n            return this;\r\n        var retval, a = this.args[0];\r\n        var m = new Symbol(this.multiplier);\r\n        var sym = this.clone().toUnitMultiplier();\r\n        if(this.isLinear()) {\r\n            switch(this.fname) {\r\n                case SINH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('(e^({0})+e^(-({0})))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))', a));\r\n                    break;\r\n                case TAN:\r\n                    retval = _.parse(format('sin({0})/cos({0})', a));\r\n                    break;\r\n                case CSC:\r\n                    retval = _.parse(format('1/sin({0})', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('1/cos({0})', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.power.equals(2)) {\r\n            switch(this.fname) {\r\n                case SIN:\r\n                    retval = _.parse(format('1/2-cos(2*({0}))/2', a));\r\n                    break;\r\n                case COS:\r\n                    retval = _.parse(format('1/2+cos(2*({0}))/2', a));\r\n                    break;\r\n                case TAN:\r\n                    //retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))', a));\r\n                    retval = _.parse(format('sin({0})^2/cos({0})^2', a));\r\n                    break;\r\n                case COSH:\r\n                    retval = _.parse(format('1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case SINH:\r\n                    retval = _.parse(format('-1/2+cosh(2*({0}))/2', a));\r\n                    break;\r\n                case TANH:\r\n                    retval = _.parse(format('(1+cosh(2*({0})))/(-1+cosh(2*({0})))', a));\r\n                    break;\r\n                case SEC:\r\n                    retval = _.parse(format('(1-cos(2*({0})))/(1+cos(2*({0})))+1', a));\r\n                    break;\r\n                default:\r\n                    retval = sym;\r\n            }\r\n        }\r\n        else if(this.fname === SEC) {\r\n            retval = _.parse(format('1/cos({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === CSC) {\r\n            retval = _.parse(format('1/sin({0})^({1})', this.args[0], this.power));\r\n        }\r\n        else if(this.fname === TAN) {\r\n            if(this.power.lessThan(0)) {\r\n                retval = _.parse(format('cos({0})^(-({1}))/sin({0})^({1})', this.args[0], this.power.negate()));\r\n            }\r\n            else {\r\n                retval = _.parse(format('sin({0})^({1})/cos({0})^({1})', this.args[0], this.power));\r\n            }\r\n        }\r\n        else if(this.fname === SIN && this.power.lessThan(0)) {\r\n            retval = _.parse(format('csc({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === COS && this.power.lessThan(0)) {\r\n            retval = _.parse(format('sec({0})^(-({1}))', this.args[0], this.power.negate()));\r\n        }\r\n        else if(this.fname === SIN && this.power.equals(3)) {\r\n            retval = _.parse(format('(3*sin({0})-sin(3*({0})))/4', this.args[0]));\r\n        }\r\n        else if(this.fname === COS && this.power.equals(3)) {\r\n            retval = _.parse(format('(cos(3*({0}))+3*cos({0}))/4', this.args[0]));\r\n        }\r\n        //cos(a*x)^(2*n) or sin(a*x)^(2*n)\r\n        else if((this.fname === COS || this.fname === SIN) && even(this.power)) {\r\n            var n = this.power / 2;\r\n            //convert to a double angle\r\n            var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();\r\n            //raise to the n and expand\r\n            var transformed = _.expand(_.pow(double_angle, _.parse(n)));\r\n\r\n            retval = new Symbol(0);\r\n\r\n            transformed.each(function (s) {\r\n                var t = s.fnTransform();\r\n                retval = _.add(retval, t);\r\n            }, true);\r\n        }\r\n        else\r\n            retval = sym;\r\n\r\n        return _.multiply(retval, m);\r\n    };\r\n\r\n    Symbol.prototype.hasTrig = function () {\r\n        if(this.isConstant(true) || this.group === S)\r\n            return false;\r\n        if(this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))\r\n            return true;\r\n        if(this.symbols) {\r\n            for(var x in this.symbols)\r\n                if(this.symbols[x].hasTrig())\r\n                    return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    core.Expression.prototype.hasIntegral = function () {\r\n        return this.symbol.hasIntegral();\r\n    };\r\n    /**\r\n     * Attempts to rewrite a symbol under one common denominator\r\n     * @param {Symbol} symbol \r\n     */\r\n    core.Utils.toCommonDenominator = function (symbol) {\r\n        //transform x/a+x -> (ax+x)/a\r\n        if(symbol.isComposite() && symbol.isLinear()) {\r\n            var m = new Symbol(symbol.multiplier);\r\n            var denominator = new Symbol(1);\r\n            var numerator = new Symbol(0);\r\n            symbol.each(function (x) {\r\n                denominator = _.multiply(denominator, x.getDenom());\r\n            }, true);\r\n\r\n            //remove the denomitor in each term\r\n            symbol.each(function (x) {\r\n                var num = x.getNum();\r\n                var den = x.getDenom();\r\n                var factor = _.multiply(num, _.divide(denominator.clone(), den));\r\n                numerator = _.add(numerator, factor);\r\n            });\r\n            var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));\r\n            return retval;\r\n        }\r\n        return symbol;\r\n    };\r\n    //A function to check if a function name is an inverse trig function\r\n    core.Utils.in_inverse_trig = function (x) {\r\n        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];\r\n        return inv_trig_fns.indexOf(x) !== -1;\r\n    };\r\n    //A function to check if a function name is a trig function\r\n    core.Utils.in_trig = function (x) {\r\n        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    core.Utils.in_htrig = function (x) {\r\n        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];\r\n        return trig_fns.indexOf(x) !== -1;\r\n    };\r\n\r\n    // Matrix functions\r\n    core.Matrix.jacobian = function (eqns, vars) {\r\n        var jacobian = new core.Matrix();\r\n        //get the variables if not supplied\r\n        if(!vars) {\r\n            vars = core.Utils.arrayGetVariables(eqns);\r\n        }\r\n\r\n        vars.forEach(function (v, i) {\r\n            eqns.forEach(function (eq, j) {\r\n                var e = core.Calculus.diff(eq.clone(), v);\r\n                jacobian.set(j, i, e);\r\n            });\r\n        });\r\n\r\n        return jacobian;\r\n    };\r\n\r\n    core.Matrix.prototype.max = function () {\r\n        var max = new Symbol(0);\r\n        this.each(function (x) {\r\n            var e = x.abs();\r\n            if(e.gt(max))\r\n                max = e;\r\n        });\r\n        return max;\r\n    };\r\n\r\n    core.Matrix.cMatrix = function (value, vars) {\r\n        var m = new core.Matrix();\r\n        //make an initial guess\r\n        vars.forEach(function (v, i) {\r\n            m.set(i, 0, _.parse(value));\r\n        });\r\n        return m;\r\n    };\r\n\r\n    var all_functions = core.Utils.all_functions = function (arr) {\r\n        for(var i = 0, l = arr.length; i < l; i++)\r\n            if(arr[i].group !== FN)\r\n                return false;\r\n        return true;\r\n    },\r\n            cosAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(sin(({0})+({1}))-sin(({0})-({1})))/2', a, b));\r\n            },\r\n            cosAsinAtransform = core.Utils.cosAsinAtranform = function (symbol1, symbol2) {\r\n                //TODO: temporary fix for integrate(e^x*sin(x)*cos(x)^2).\r\n                //we technically know how to do this transform but more is needed for correct output\r\n                if(Number(symbol2.power) !== 1)\r\n                    return _.multiply(symbol1, symbol2);\r\n                var a;\r\n                a = symbol1.args[0];\r\n                return _.parse(format('(sin(2*({0})))/2', a));\r\n            },\r\n            sinAsinBtransform = core.Utils.cosAsinBtranform = function (symbol1, symbol2) {\r\n                var a, b;\r\n                a = symbol1.args[0];\r\n                b = symbol2.args[0];\r\n                return _.parse(format('(cos(({0})+({1}))-cos(({0})-({1})))/2', a, b));\r\n            },\r\n            trigTransform = core.Utils.trigTransform = function (arr) {\r\n                var map = {}, symbol, t,\r\n                        retval = new Symbol(1);\r\n                for(var i = 0, l = arr.length; i < l; i++) {\r\n                    symbol = arr[i];\r\n\r\n                    if(symbol.group === FN) {\r\n                        var fname = symbol.fname;\r\n\r\n                        if(fname === COS && map[SIN]) {\r\n\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[SIN]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[SIN]);\r\n                            }\r\n                            delete map[SIN];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[COS]) {\r\n                            if(map[COS].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = cosAsinBtransform(symbol, map[COS]);\r\n                            }\r\n                            else {\r\n                                t = cosAsinAtransform(symbol, map[COS]);\r\n                            }\r\n                            delete map[COS];\r\n\r\n                            retval = _.multiply(retval, t);\r\n                        }\r\n                        else if(fname === SIN && map[SIN]) {\r\n                            if(map[SIN].args[0].toString() !== symbol.args[0].toString()) {\r\n                                t = sinAsinBtransform(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n                            else {\r\n                                //This should actually be redundant code but let's put just in case\r\n                                t = _.multiply(symbol, map[SIN]);\r\n                                delete map[SIN];\r\n                            }\r\n\r\n                            retval = t;\r\n                        }\r\n                        else {\r\n                            map[fname] = symbol;\r\n                        }\r\n                    }\r\n                    else\r\n                        retval = _.multiply(retval, symbol);\r\n                }\r\n\r\n                //put back the remaining functions\r\n                for(var x in map)\r\n                    retval = _.multiply(retval, map[x]);\r\n\r\n                return retval;\r\n\r\n            };\r\n\r\n    core.Settings.integration_depth = 10;\r\n\r\n    core.Settings.max_lim_depth = 10;\r\n\r\n    var __ = core.Calculus = {\r\n\r\n        version: '1.4.6',\r\n\r\n        sum: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                start = Number(start);\r\n                end = Number(end);\r\n                retval = core.Utils.block(modifier, function () {\r\n                    var f = fn.text(),\r\n                            subs = {'~': true}, //lock subs. Is this even being used?\r\n                            retval = new core.Symbol(0);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        var ans = _.parse(f, subs);\r\n                        retval = _.add(retval, ans);\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('sum', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        product: function (fn, index, start, end) {\r\n            if(!(index.group === core.groups.S))\r\n                throw new core.exceptions.NerdamerTypeError('Index must be symbol. ' + text(index) + ' provided');\r\n            index = index.value;\r\n            var retval;\r\n            if(core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {\r\n                var modifier = end - start < 200 ? '' : 'PARSE2NUMBER';\r\n                retval = core.Utils.block(modifier, function () {\r\n                    start = Number(start);\r\n                    end = Number(end.multiplier);\r\n\r\n                    var f = fn.text(),\r\n                            subs = {},\r\n                            retval = new core.Symbol(1);\r\n\r\n                    for(var i = start; i <= end; i++) {\r\n                        subs[index] = new Symbol(i);\r\n                        retval = _.multiply(retval, _.parse(f, subs));\r\n                    }\r\n                    return retval;\r\n                });\r\n            }\r\n            else {\r\n                retval = _.symfunction('product', arguments);\r\n            }\r\n\r\n            return retval;\r\n        },\r\n        diff: function (symbol, wrt, nth) {\r\n            if(core.Utils.isVector(symbol)) {\r\n                var vector = new core.Vector([]);\r\n                symbol.each(function (x) {\r\n                    vector.elements.push(__.diff(x, wrt, nth));\r\n                });\r\n                return vector;\r\n            }\r\n            else if(core.Utils.isMatrix(symbol)) {\r\n                var matrix = new core.Matrix();\r\n                symbol.each(function (x, i, j) {\r\n                    matrix.set(i, j, __.diff(x, wrt, nth));\r\n                });\r\n                return matrix;\r\n            }\r\n\r\n            var d = isSymbol(wrt) ? wrt.text() : wrt;\r\n            //the nth derivative\r\n            nth = isSymbol(nth) ? nth.multiplier : nth || 1;\r\n\r\n            if(d === undefined)\r\n                d = core.Utils.variables(symbol)[0];\r\n\r\n            //unwrap sqrt\r\n            if(symbol.group === FN && symbol.fname === SQRT) {\r\n                var s = symbol.args[0],\r\n                        sp = symbol.power.clone();\r\n                //these groups go to zero anyway so why waste time?\r\n                if(s.group !== N || s.group !== P) {\r\n                    s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);\r\n                    s.multiplier = s.multiplier.multiply(symbol.multiplier);\r\n                }\r\n\r\n                symbol = s;\r\n            }\r\n\r\n            if(symbol.group === FN && !isSymbol(symbol.power)) {\r\n                var a = derive(_.parse(symbol));\r\n                var b = __.diff(symbol.args[0].clone(), d);\r\n                symbol = _.multiply(a, b);//chain rule\r\n            }\r\n            else {\r\n                symbol = derive(symbol);\r\n            }\r\n\r\n            if(nth > 1) {\r\n                nth--;\r\n                symbol = __.diff(symbol, wrt, nth);\r\n            }\r\n\r\n            return symbol;\r\n\r\n            // Equivalent to \"derivative of the outside\".\r\n            function polydiff(symbol) {\r\n                if(symbol.value === d || symbol.contains(d, true)) {\r\n                    symbol.multiplier = symbol.multiplier.multiply(symbol.power);\r\n                    symbol.power = symbol.power.subtract(new Frac(1));\r\n                    if(symbol.power.equals(0)) {\r\n                        symbol = Symbol(symbol.multiplier);\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            }\r\n            \r\n            function derive(symbol) {\r\n                var g = symbol.group, a, b, cp;\r\n\r\n                if(g === N || g === S && symbol.value !== d || g === P) {\r\n                    symbol = Symbol(0);\r\n                }\r\n                else if(g === S) {\r\n                    symbol = polydiff(symbol);\r\n                }\r\n                else if(g === CB) {\r\n                    var m = symbol.multiplier.clone();\r\n                    symbol.toUnitMultiplier();\r\n                    var retval = _.multiply(product_rule(symbol), polydiff(symbol));\r\n                    retval.multiplier = retval.multiplier.multiply(m);\r\n                    return retval;\r\n                }\r\n                else if(g === FN && symbol.power.equals(1)) {\r\n                    // Table of known derivatives\r\n                    switch(symbol.fname) {\r\n                        case LOG:\r\n                            cp = symbol.clone();\r\n                            symbol = symbol.args[0].clone();//get the arguments\r\n                            symbol.power = symbol.power.negate();\r\n                            symbol.multiplier = cp.multiplier.divide(symbol.multiplier);\r\n                            break;\r\n                        case COS:\r\n                            //cos -> -sin\r\n                            symbol.fname = SIN;\r\n                            symbol.multiplier.negate();\r\n                            break;\r\n                        case SIN:\r\n                            //sin -> cos\r\n                            symbol.fname = COS;\r\n                            break;\r\n                        case TAN:\r\n                            //tan -> sec^2\r\n                            symbol.fname = SEC;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SEC:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, TAN);\r\n                            break;\r\n                        case CSC:\r\n                            symbol = qdiff(symbol, '-cot');\r\n                            break;\r\n                        case COT:\r\n                            symbol.fname = CSC;\r\n                            symbol.multiplier.negate();\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case ASIN:\r\n                            symbol = _.parse('(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ACOS:\r\n                            symbol = _.parse('-(sqrt(1-(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case ATAN:\r\n                            symbol = _.parse('(1+(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ABS:\r\n                            m = symbol.multiplier.clone();\r\n                            symbol.toUnitMultiplier();\r\n                            //depending on the complexity of the symbol it's easier to just parse it into a new symbol\r\n                            //this should really be readdressed soon\r\n                            b = symbol.args[0].clone();\r\n                            b.toUnitMultiplier();\r\n                            symbol = _.parse(inBrackets(text(symbol.args[0])) + '/abs' + inBrackets(text(b)));\r\n                            symbol.multiplier = m;\r\n                            break;\r\n                        case 'parens':\r\n                            //see product rule: f'.g goes to zero since f' will return zero. This way we only get back\r\n                            //1*g'\r\n                            symbol = Symbol(1);\r\n                            break;\r\n                        case 'cosh':\r\n                            //cosh -> -sinh\r\n                            symbol.fname = 'sinh';\r\n                            break;\r\n                        case 'sinh':\r\n                            //sinh -> cosh\r\n                            symbol.fname = 'cosh';\r\n                            break;\r\n                        case TANH:\r\n                            //tanh -> sech^2\r\n                            symbol.fname = SECH;\r\n                            symbol.power = new Frac(2);\r\n                            break;\r\n                        case SECH:\r\n                            // Use a clone if this gives errors\r\n                            symbol = qdiff(symbol, '-tanh');\r\n                            break;\r\n                        case CSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-coth(' + arg + ')*csch(' + arg + ')');\r\n                            break;\r\n                        case COTH:\r\n                            var arg = String(symbol.args[0]);\r\n                            return _.parse('-csch(' + arg + ')^2');\r\n                            break;\r\n                        case 'asinh':\r\n                            symbol = _.parse('(sqrt(1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'acosh':\r\n                            symbol = _.parse('(sqrt(-1+(' + text(symbol.args[0]) + ')^2))^(-1)');\r\n                            break;\r\n                        case 'atanh':\r\n                            symbol = _.parse('(1-(' + text(symbol.args[0]) + ')^2)^(-1)');\r\n                            break;\r\n                        case ASECH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2-1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOTH:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2-1)');\r\n                            break;\r\n                        case ACSCH:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1/(' + arg + ')^2+1)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ASEC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACSC:\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('-1/(sqrt(1-1/(' + arg + ')^2)*(' + arg + ')^2)');\r\n                            break;\r\n                        case ACOT:\r\n                            symbol = _.parse('-1/((' + symbol.args[0] + ')^2+1)');\r\n                            break;\r\n                        case 'S':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('sin((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'C':\r\n                            var arg = String(symbol.args[0]);\r\n                            symbol = _.parse('cos((pi*(' + arg + ')^2)/2)');\r\n                            break;\r\n                        case 'Si':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sin(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Shi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('sinh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ci':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cos(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Chi':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('cosh(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Ei':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('e^(' + arg + ')/(' + arg + ')');\r\n                            break;\r\n                        case 'Li':\r\n                            var arg = symbol.args[0];\r\n                            symbol = _.parse('1/' + Settings.LOG + '(' + arg + ')');\r\n                            break;\r\n                        case 'erf':\r\n                            symbol = _.parse('(2*e^(-(' + symbol.args[0] + ')^2))/sqrt(pi)');\r\n                            break;\r\n                        case 'atan2':\r\n                            var x_ = String(symbol.args[0]),\r\n                                    y_ = String(symbol.args[1]);\r\n                            symbol = _.parse('(' + y_ + ')/((' + y_ + ')^2+(' + x_ + ')^2)');\r\n                            break;\r\n                        case 'sign':\r\n                            symbol = new Symbol(0);\r\n                            break;\r\n                        case 'sinc':\r\n                            symbol = _.parse(format('(({0})*cos({0})-sin({0}))*({0})^(-2)', symbol.args[0]));\r\n                            break;\r\n                        case Settings.LOG10:\r\n                            symbol = _.parse('1/((' + symbol.args[0] + ')*' + Settings.LOG + '(10))');\r\n                            break;\r\n                        default:\r\n                            symbol = _.symfunction('diff', [symbol, wrt]);\r\n                    }\r\n                }\r\n                else if(g === EX || g === FN && isSymbol(symbol.power)) {\r\n                    var value;\r\n                    if(g === EX) {\r\n                        value = symbol.value;\r\n                    }\r\n                    else if(g === FN && symbol.contains(d)) {\r\n                        value = symbol.fname + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    else {\r\n                        value = symbol.value + inBrackets(text(symbol.args[0]));\r\n                    }\r\n                    a = _.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone());\r\n                    b = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol.power.clone()), d);\r\n                    symbol = _.multiply(symbol, b);\r\n                }\r\n                else if(g === FN && !symbol.power.equals(1)) {\r\n                    b = symbol.clone();\r\n                    b.toLinear();\r\n                    b.toUnitMultiplier();\r\n                    symbol = _.multiply(polydiff(symbol.clone()), derive(b));\r\n                }\r\n                else if(g === CP || g === PL) {\r\n                    // Note: Do not use `parse` since this puts back the sqrt and causes a bug as in #610. Use clone.\r\n                    var c = symbol.clone();\r\n                    var result = new Symbol(0);\r\n                    for(var x in symbol.symbols) {\r\n                        result = _.add(result, __.diff(symbol.symbols[x].clone(), d));\r\n                    }\r\n                    symbol = _.multiply(polydiff(c), result);\r\n                }\r\n\r\n                symbol.updateHash();\r\n\r\n                return symbol;\r\n            }\r\n            ;\r\n\r\n            function qdiff(symbol, val, altVal) {\r\n                return _.multiply(symbol, _.parse(val + inBrackets(altVal || text(symbol.args[0]))));\r\n            }\r\n            ;\r\n\r\n            function product_rule(symbol) {\r\n                //grab all the symbols within the CB symbol\r\n                var symbols = symbol.collectSymbols(),\r\n                        result = new Symbol(0),\r\n                        l = symbols.length;\r\n                //loop over all the symbols\r\n                for(var i = 0; i < l; i++) {\r\n                    var df = __.diff(symbols[i].clone(), d);\r\n                    for(var j = 0; j < l; j++) {\r\n                        //skip the symbol of which we just pulled the derivative\r\n                        if(i !== j) {\r\n                            //multiply out the remaining symbols\r\n                            df = _.multiply(df, symbols[j].clone());\r\n                        }\r\n                    }\r\n                    //add the derivative to the result\r\n                    result = _.add(result, df);\r\n                }\r\n                return result; //done\r\n            }\r\n            ;\r\n        },\r\n        integration: {\r\n            u_substitution: function (symbols, dx) {\r\n                function try_combo(a, b, f) {\r\n                    var d = __.diff(b, dx);\r\n                    var q = f ? f(a, b) : _.divide(a.clone(), d);\r\n                    if(!q.contains(dx, true))\r\n                        return q;\r\n                    return null;\r\n                }\r\n                function do_fn_sub(fname, arg) {\r\n                    var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);\r\n                    subbed = subbed.sub(new Symbol(u), arg);\r\n                    subbed.updateHash();\r\n                    return subbed;\r\n                }\r\n\r\n                var a = symbols[0].clone(),\r\n                        b = symbols[1].clone(),\r\n                        g1 = a.group,\r\n                        g2 = b.group,\r\n                        //may cause problems if person is using this already. Will need\r\n                        //to find algorithm for detecting conflict\r\n                        u = '__u__',\r\n                        Q;\r\n                if(g1 === FN && g2 !== FN) {\r\n                    //e.g. 2*x*cos(x^2)\r\n                    var arg = a.args[0];\r\n                    Q = try_combo(b, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(a.fname, arg));\r\n                    Q = try_combo(b, a);\r\n                    if(Q) {\r\n                        return __.integration.poly_integrate(a);\r\n                    }\r\n                }\r\n                else if(g2 === FN && g1 !== FN) {\r\n                    //e.g. 2*(x+1)*cos((x+1)^2\r\n                    var arg = b.args[0];\r\n                    Q = try_combo(a, arg.clone());\r\n                    if(Q)\r\n                        return _.multiply(Q, do_fn_sub(b.fname, arg));\r\n                }\r\n                else if(g1 === FN && g2 === FN) {\r\n                    Q = try_combo(a.clone(), b.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(b.clone(), a.clone());\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                }\r\n                else if(g1 === EX && g2 !== EX) {\r\n                    var p = a.power;\r\n                    Q = try_combo(b, p.clone());\r\n                    if(!Q) {\r\n                        //one more try\r\n                        var dc = __.integration.decompose_arg(p.clone(), dx);\r\n                        //consider the possibility of a^x^(n-1)*x^n dx\r\n                        var xp = __.diff(dc[2].clone(), dx);\r\n                        var dc2 = __.integration.decompose_arg(xp.clone(), dx);\r\n                        //if their powers equal, so if dx*p == b\r\n                        if(_.multiply(dc[1], dc2[1]).power.equals(b.power)) {\r\n                            var m = _.divide(dc[0].clone(), dc2[0].clone());\r\n\r\n                            var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));\r\n                            new_val = _.multiply(new_val, new Symbol(u));\r\n                            return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());\r\n                        }\r\n\r\n                    }\r\n                    var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0),\r\n                            retval = _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n\r\n\r\n                    return retval;\r\n                }\r\n                else if(g2 === EX && g1 !== EX) {\r\n                    var p = b.power;\r\n                    Q = try_combo(a, p.clone());\r\n                    var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);\r\n                    return _.multiply(integrated.sub(new Symbol(u), p), Q);\r\n                }\r\n                else if(a.isComposite() || b.isComposite()) {\r\n                    var f = function (a, b) {\r\n                        var d = __.diff(b, dx);\r\n                        var A = core.Algebra.Factor.factor(a),\r\n                                B = core.Algebra.Factor.factor(d);\r\n                        var q = _.divide(A, B);\r\n                        return q;\r\n                    };\r\n                    var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(),\r\n                            f2 = b.isComposite() ? b.clone().toLinear() : b.clone();\r\n                    Q = try_combo(f1.clone(), f2.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(b), Q);\r\n                    Q = try_combo(f2.clone(), f1.clone(), f);\r\n                    if(Q)\r\n                        return _.multiply(__.integration.poly_integrate(a), Q);\r\n                }\r\n            },\r\n            //simple integration of a single polynomial x^(n+1)/(n+1)\r\n            poly_integrate: function (x) {\r\n                var p = x.power.toString(),\r\n                        m = x.multiplier.toDecimal(),\r\n                        s = x.toUnitMultiplier().toLinear();\r\n                if(Number(p) === -1) {\r\n                    return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));\r\n                }\r\n                return _.parse(format('({0})*({1})^(({2})+1)/(({2})+1)', m, s, p));\r\n            },\r\n            //If we're just spinning wheels we want to stop. This is why we \r\n            //wrap integration in a try catch block and call this to stop.\r\n            stop: function (msg) {\r\n                msg = msg || 'Unable to compute integral!';\r\n                core.Utils.warn(msg);\r\n                throw new NoIntegralFound(msg);\r\n            },\r\n            partial_fraction: function (input, dx, depth, opt) {\r\n                //TODO: This whole thing needs to be rolled into one but for now I'll leave it as two separate parts\r\n                if(!isSymbol(dx))\r\n                    dx = _.parse(dx);\r\n\r\n                var result, partial_fractions;\r\n                result = new Symbol(0);\r\n                partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);\r\n\r\n                if(partial_fractions.group === CB && partial_fractions.isLinear()) {\r\n                    //perform a quick check to make sure that all partial fractions are linear\r\n                    partial_fractions.each(function (x) {\r\n                        if(!x.isLinear())\r\n                            __.integration.stop();\r\n                    });\r\n                    partial_fractions.each(function (x) {\r\n                        result = _.add(result, __.integrate(x, dx, depth, opt));\r\n                    });\r\n                }\r\n                else {\r\n                    result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));\r\n                }\r\n                return result;\r\n            },\r\n            get_udv: function (symbol) {\r\n                var parts = [[/*L*/], [/*I*/], [/*A*/], [/*T*/], [/*E*/]];\r\n                //first we sort them \r\n                var setSymbol = function (x) {\r\n                    var g = x.group;\r\n                    if(g === FN) {\r\n                        var fname = x.fname;\r\n                        if(core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))\r\n                            parts[3].push(x);\r\n                        else if(core.Utils.in_inverse_trig(fname))\r\n                            parts[1].push(x);\r\n                        else if(fname === LOG)\r\n                            parts[0].push(x);\r\n                        else {\r\n                            __.integration.stop();\r\n                        }\r\n                    }\r\n                    else if(g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {\r\n                        parts[2].push(x);\r\n                    }\r\n                    else if(g === EX || x.isComposite() && !x.isLinear())\r\n                        parts[4].push(x);\r\n                    else\r\n                        __.integration.stop();\r\n                };\r\n\r\n                if(symbol.group === CB)\r\n                    symbol.each(function (x) {\r\n                        setSymbol(Symbol.unwrapSQRT(x, true));\r\n                    });\r\n                else\r\n                    setSymbol(symbol);\r\n                var u, dv = new Symbol(1);\r\n                //compile u and dv\r\n                for(var i = 0; i < 5; i++) {\r\n                    var part = parts[i], t,\r\n                            l = part.length;\r\n                    if(l > 0) {\r\n                        if(l > 1) {\r\n                            t = new Symbol(1);\r\n                            for(var j = 0; j < l; j++)\r\n                                t = _.multiply(t, part[j].clone());\r\n                        }\r\n                        else\r\n                            t = part[0].clone();\r\n\r\n                        if(!u) {\r\n                            u = t;//the first u encountered gets chosen\r\n                            u.multiplier = u.multiplier.multiply(symbol.multiplier); //the first one gets the mutliplier\r\n                        }\r\n                        else\r\n                            dv = _.multiply(dv, t); //everything else belongs to dv\r\n                    }\r\n                }\r\n\r\n                return [u, dv];\r\n            },\r\n\r\n            trig_sub: function (symbol, dx, depth, opt, parts, symbols) {\r\n                parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);\r\n                var b = parts[3],\r\n                        ax = parts[2],\r\n                        a = parts[0],\r\n                        x = parts[1];\r\n                if(x.power.equals(2) && a.greaterThan(0)) {\r\n                    //use tan(x)\r\n                    var t = core.Utils.getU(symbol), //get an appropriate u\r\n                            u = _.parse(TAN + inBrackets(t)), //u\r\n                            du = _.parse(SEC + inBrackets(t) + '^2'), //du\r\n                            f = _.multiply(symbol.sub(x, u), du);\r\n                    var integral = __.integrate(f, t, depth, opt).sub(u, x);\r\n                    core.Utils.clearU(u);\r\n                    return integral;\r\n                }\r\n            },\r\n\r\n            by_parts: function (symbol, dx, depth, o) {\r\n                o.previous = o.previous || [];\r\n                var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;\r\n                //first LIATE\r\n                udv = __.integration.get_udv(symbol);\r\n                u = udv[0];\r\n                dv = udv[1];\r\n                du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);\r\n                c = du.clone().stripVar(dx);\r\n                //strip any coefficients\r\n                du = _.divide(du, c.clone());\r\n                v = __.integrate(dv.clone(), dx, depth || 0);\r\n                vdu = _.multiply(v.clone(), du);\r\n                vdu_s = vdu.toString();\r\n                //currently only supports e^x*(some trig)\r\n                if(o.previous.indexOf(vdu_s) !== -1 && (core.Utils.in_trig(u.fname)) && dv.isE()) {\r\n                    //We're going to exploit the fact that vdu can never be constant\r\n                    //to work out way out of this cycle. We'll return the length of\r\n                    //the this.previous array until we're back at level one\r\n                    o.is_cyclic = true;\r\n                    //return the integral. \r\n                    return new Symbol(1);\r\n                }\r\n                else\r\n                    o.previous.push(vdu_s);\r\n\r\n                uv = _.multiply(u, v);\r\n                //clear the multiplier so we're dealing with a bare integral\r\n                m = vdu.multiplier.clone();\r\n                vdu.toUnitMultiplier();\r\n                integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);\r\n                integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);\r\n                retval = _.subtract(uv, integral_vdu);\r\n                //we know that there cannot be constants so they're a holdover from a cyclic integral\r\n                if(o.is_cyclic) {\r\n                    //start popping the previous stack so we know how deep in we are\r\n                    o.previous.pop();\r\n                    if(o.previous.length === 0) {\r\n                        retval = _.expand(retval);\r\n                        var rem = new Symbol(0);\r\n                        retval.each(function (x) {\r\n                            if(!x.contains(dx))\r\n                                rem = _.add(rem, x.clone());\r\n                        });\r\n                        //get the actual uv\r\n                        retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));\r\n                    }\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            /*\r\n             * dependents: [Solve, integrate]\r\n             */\r\n            decompose_arg: core.Utils.decompose_fn\r\n        },\r\n        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output\r\n        integrate: function (original_symbol, dt, depth, opt) {\r\n            //assume integration wrt independent variable if expression only has one variable\r\n            if(!dt) {\r\n                var vars = core.Utils.variables(original_symbol);\r\n                if(vars.length === 1)\r\n                    dt = vars[0];\r\n                //defaults to x\r\n                dt = dt || 'x';\r\n            }\r\n            //add support for integrating vectors\r\n            if(core.Utils.isVector(original_symbol)) {\r\n                var vector = new core.Vector([]);\r\n                original_symbol.each(function (x) {\r\n                    vector.elements.push(__.integrate(x, dt));\r\n                });\r\n                return vector;\r\n            }\r\n            if(!isNaN(dt))\r\n                _.error('variable expected but received ' + dt);\r\n            //get rid of constants right away\r\n            if(original_symbol.isConstant(true))\r\n                return _.multiply(original_symbol.clone(), _.parse(dt));\r\n\r\n            //configurations options for integral. This is needed for tracking extra options\r\n            //e.g. cyclic integrals or additional settings\r\n            opt = opt || {};\r\n            return core.Utils.block('PARSE2NUMBER', function () {\r\n                //make a note of the original symbol. Set only if undefined\r\n                depth = depth || 0;\r\n                var dx = isSymbol(dt) ? dt.toString() : dt,\r\n                        //we don't want the symbol in sqrt form. x^(1/2) is prefererred\r\n                        symbol = Symbol.unwrapSQRT(original_symbol.clone(), true),\r\n                        g = symbol.group,\r\n                        retval;\r\n\r\n                try {\r\n                    //We stop integration after x amount of recursive calls\r\n                    if(++depth > core.Settings.integration_depth)\r\n                        __.integration.stop('Maximum depth reached. Exiting!');\r\n\r\n                    //constants. We first eliminate anything that doesn't have dx. Everything after this has \r\n                    //to have dx or else it would have been taken care of below\r\n                    if(!symbol.contains(dx, true)) {\r\n                        retval = _.multiply(symbol.clone(), _.parse(dx));\r\n                    }\r\n                    //e.g. 2*x\r\n                    else if(g === S) {\r\n                        retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                    }\r\n                    else if(g === EX) {\r\n                        if(symbol.previousGroup === FN && !(symbol.fname === 'sqrt' || symbol.fname === Settings.PARENTHESIS))\r\n                            __.integration.stop();\r\n                        //check the base\r\n                        if(symbol.contains(dx) && symbol.previousGroup !== FN) {\r\n                            //if the symbol also contains dx then we stop since we currently \r\n                            //don't know what to do with it e.g. x^x\r\n                            if(symbol.power.contains(dx))\r\n                                __.integration.stop();\r\n                            else {\r\n                                var t = __.diff(symbol.clone().toLinear(), dx);\r\n                                if(t.contains(dx))\r\n                                    __.integration.stop();\r\n                                //since at this point it's the base only then we do standard single poly integration\r\n                                //e.g. x^y\r\n                                retval = __.integration.poly_integrate(symbol, dx, depth);\r\n                            }\r\n                        }\r\n                        //e.g. a^x or 9^x\r\n                        else {\r\n                            var a = __.diff(symbol.power.clone(), dx);\r\n                            if(a.contains(dx)) {\r\n                                var aa = a.stripVar(dx),\r\n                                        x = _.divide(a.clone(), aa.clone());\r\n                                if(x.group === S && x.isLinear()) {\r\n                                    aa.multiplier = aa.multiplier.divide(new Frac(2));\r\n                                    return _.parse(format('({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))', aa, dx, symbol.multiplier));\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            if(symbol.isE()) {\r\n                                if(a.isLinear())\r\n                                    retval = symbol;\r\n                                else {\r\n                                    if(a.isE() && a.power.group === S && a.power.power.equals(1))\r\n                                        retval = _.multiply(_.symfunction('Ei', [symbol.power.clone()]), symbol.power);\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                            }\r\n                            else {\r\n                                var d = _.symfunction(LOG, [_.parse(symbol.value)]);\r\n                                retval = _.divide(symbol, d);\r\n                            }\r\n                            retval = _.divide(retval, a);\r\n                        }\r\n                    }\r\n                    else if(symbol.isComposite() && symbol.isLinear()) {\r\n                        var m = _.parse(symbol.multiplier);\r\n                        symbol.toUnitMultiplier();\r\n                        retval = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            retval = _.add(retval, __.integrate(x, dx, depth));\r\n                        });\r\n                        retval = _.multiply(m, retval);\r\n                    }\r\n                    else if(g === CP) {\r\n                        if(symbol.power.greaterThan(1))\r\n                            symbol = _.expand(symbol);\r\n                        if(symbol.power.equals(1)) {\r\n                            retval = new Symbol(0);\r\n                            symbol.each(function (x) {\r\n                                retval = _.add(retval, __.integrate(x, dx, depth));\r\n                            }, true);\r\n                        }\r\n                        else {\r\n                            var p = Number(symbol.power),\r\n                                    m = symbol.multiplier.clone();//temporarily remove the multiplier\r\n                            symbol.toUnitMultiplier();\r\n                            var //below we consider the form ax+b\r\n                                    fn = symbol.clone().toLinear(), //get just the pure function without the power\r\n                                    decomp = __.integration.decompose_arg(fn, dx),\r\n                                    //I have no idea why I used bx+a and not ax+b. TODO change this to something that makes sense\r\n                                    b = decomp[3],\r\n                                    ax = decomp[2],\r\n                                    a = decomp[0],\r\n                                    x = decomp[1];\r\n                            if(p === -1 && x.group !== PL && x.power.equals(2)) {\r\n                                var b_is_positive = isInt(b) ? b > 0 : true;\r\n                                //we can now check for atan\r\n                                if(x.group === S && x.power.equals(2) && b_is_positive) {\r\n                                    ////then we have atan\r\n                                    //abs is redundants since the sign appears in both denom and num.\r\n                                    var unwrapAbs = function (s) {\r\n                                        var result = new Symbol(1);\r\n                                        s.each(function (x) {\r\n                                            result = _.multiply(result, x.fname === 'abs' ? x.args[0] : x);\r\n                                        });\r\n                                        return result;\r\n                                    };\r\n                                    var A = a.clone(),\r\n                                            B = b.clone();\r\n                                    A = _.pow(A, new Symbol(1 / 2));\r\n                                    B = _.pow(B, new Symbol(1 / 2));\r\n                                    //unwrap abs\r\n\r\n                                    var d = _.multiply(unwrapAbs(B), unwrapAbs(A)),\r\n                                            f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);\r\n                                    retval = _.divide(f, d);\r\n                                }\r\n                                else if(x.group === S && x.isLinear()) {\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                }\r\n                                else {\r\n                                    //1/(x^4+1)\r\n                                    if(x.power.equals(4)) {\r\n                                        //https://www.freemathhelp.com/forum/threads/55678-difficult-integration-int-1-(1-x-4)-dx\r\n                                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;\r\n                                        var br = inBrackets;\r\n                                        //apply rule: ax^4+b = (ax^2+2abx+b)(ax^2-2abx+b)\r\n                                        //get quadratic factors\r\n                                        A = _.parse(SQRT + br(a) + '*' + dx + '^2');\r\n                                        B = _.parse(SQRT + br(2) + '*' + br(a) + '^' + br('1/4') + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        C = _.parse(SQRT + br(b));\r\n                                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());\r\n                                        f2 = _.add(_.subtract(A, B), C);\r\n                                        //calculate numerators: [D+E, D-E] -> [2*b^(3/4)+bax, 2*b^(3/4)-bax]\r\n                                        D = _.parse(SQRT + br(2) + '*' + br(b) + '^' + br('3/4'));\r\n                                        E = _.parse(SQRT + br(b) + '*' + br(b) + '^' + br('1/4') + '*' + dx);\r\n                                        //let F = 2b2b\r\n                                        F = _.parse(2 + '*' + br(b) + '*' + SQRT + br(2) + '*' + br(b) + '^' + br('1/4'));\r\n                                        //calculate the factors\r\n                                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));\r\n                                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));\r\n                                        retval = _.add(\r\n                                                __.integrate(L1, dx, depth, opt),\r\n                                                __.integrate(L2, dx, depth, opt)\r\n                                                );\r\n                                    }\r\n                                    else\r\n                                        //let's try partial fractions\r\n                                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                }\r\n                            }\r\n                            else if(p === -1 / 2) {\r\n                                //detect asin and atan\r\n                                if(x.group === S && x.power.equals(2)) {\r\n                                    if(ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {\r\n                                        a.negate();\r\n                                        //it's asin\r\n                                        if(b.isConstant() && a.isConstant()) {\r\n                                            var d = _.symfunction(SQRT, [a.clone()]),\r\n                                                    d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);\r\n                                            retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);\r\n                                        }\r\n                                        //I'm not sure about this one. I'm trusting Wolfram Alpha here\r\n                                        else {\r\n                                            var sqrt_a = _.symfunction(SQRT, [a]),\r\n                                                    sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());\r\n                                            retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        /*WHAT HAPPENS HERE???? e.g. integrate(3/sqrt(-a+b*x^2),x) or integrate(3/sqrt(a+b*x^2),x)*/\r\n                                        __.integration.stop();\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    //This would be a case like 1/(sqrt(1-x^3) or 1/(1-(x+1)^2)\r\n                                    __.integration.stop();\r\n                                }\r\n                            }\r\n                            else if(p === 1/2 && x.power.equals(2) && a.greaterThan(0)) {\r\n                                // TODO: Revisit\r\n                                __.integration.stop();\r\n                            }\r\n                            else {\r\n                                if(x.isLinear() && x.group !== PL)\r\n                                    retval = _.divide(__.integration.poly_integrate(symbol), a);\r\n                                else if(x.power.equals(2) && a.greaterThan(0)) {\r\n                                    var sqa, sqb, aob, bsqi, n, integral, u, v, uv;\r\n                                    //1/(a*x^2+b^2)^n\r\n                                    //strip the value of b so b = 1\r\n                                    sqa = _.parse(SQRT + inBrackets(a)); //strip a so b = 1\r\n                                    sqb = _.parse(SQRT + inBrackets(b));\r\n                                    aob = _.multiply(sqa.clone(), sqb.clone()).invert();\r\n                                    bsqi = _.pow(b, new Symbol(symbol.power));\r\n                                    uv = core.Utils.getU(symbol);\r\n                                    u = _.multiply(aob, x.clone().toLinear());\r\n                                    v = _.parse(ATAN + inBrackets(u));\r\n                                    //the conversion will be 1+tan(x)^2 -> sec(x)^2\r\n                                    //since the denominator is now (sec(x)^2)^n and the numerator is sec(x)^2 \r\n                                    //then the remaining sec will be (n-1)*2;\r\n                                    var n = (Math.abs(symbol.power) - 1) * 2;\r\n                                    //1/sec(x)^n can now be converted to cos(x)^n and we can pull the integral of that\r\n                                    var integral = __.integrate(_.parse(COS + inBrackets(uv) + '^' + n));\r\n                                    core.Utils.clearU(uv);\r\n                                    return _.multiply(integral.sub(uv, v), bsqi);\r\n                                }\r\n                                else {\r\n                                    if(symbol.group !== CB && !symbol.power.lessThan(0)) {\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n                                    else {\r\n                                        var f = symbol.clone().toLinear();\r\n                                        var factored = core.Algebra.Factor.factor(f);\r\n                                        var was_factored = factored.toString() !== f.toString();\r\n                                        if(core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {\r\n                                            try {\r\n                                                var f1, fx, u, sq;\r\n                                                sq = core.Algebra.sqComplete(f, dx);\r\n                                                u = core.Utils.getU(f);\r\n                                                f1 = sq.f.sub(sq.a, u);\r\n                                                fx = _.pow(f1, _.parse(symbol.power));\r\n                                                retval = __.integrate(fx, u).sub(u, sq.a);\r\n                                            }\r\n                                            catch(e) {\r\n                                                __.integration.stop();\r\n                                            }\r\n                                        }\r\n                                        else\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                    }\r\n                                }\r\n                            }\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === FN) {\r\n                        var arg = symbol.args[0],\r\n                                m = symbol.multiplier.clone();\r\n                        symbol.toUnitMultiplier();\r\n                        var decomp = __.integration.decompose_arg(arg, dx);\r\n                        //easies way I can think of to get the coefficient and to make sure\r\n                        //that the symbol is linear wrt dx. I'm not actually trying to get the \r\n                        //derivative\r\n                        var a = decomp[0],\r\n                                x = decomp[1],\r\n                                fname = symbol.fname;\r\n                        //log is a special case that can be handled with integration by parts\r\n                        if(fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {\r\n                            /*integration by parts */\r\n                            var p = symbol.power.toString();\r\n                            if(isInt(p))\r\n                                depth = depth - p; //it needs more room to find the integral\r\n\r\n                            if(!arg.isComposite())\r\n                                retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));\r\n                            else {\r\n                                //integral u du\r\n                                var u = core.Utils.getU(symbol);\r\n                                var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));\r\n                                var du = __.diff(arg, dx);\r\n                                var u_du = _.multiply(f, du);\r\n                                var integral = __.integrate(u_du, u, depth, opt);\r\n                                retval = _.multiply(_.parse(m), integral.sub(u, arg));\r\n                            }\r\n\r\n                        }\r\n                        else if(fname === TAN && symbol.power.lessThan(0)) {\r\n                            //convert to cotangent\r\n                            var sym = symbol.clone();\r\n                            sym.power.negate();\r\n                            sym.fname = COT;\r\n                            return _.multiply(_.parse(m), __.integrate(sym, dx, depth));\r\n                        }\r\n                        else {\r\n                            if(!a.contains(dx, true) && symbol.isLinear()) { //perform a deep search for safety\r\n                                //first handle the special cases \r\n                                if(fname === ABS) {\r\n                                    //REVISIT **TODO**\r\n                                    var x = _.divide(arg.clone(), a.clone());\r\n                                    if(x.group === S && !x.power.lessThan(0)) {\r\n                                        if(core.Utils.even(x.power)) {\r\n                                            retval = __.integrate(arg, dx, depth);\r\n                                        }\r\n                                        else {\r\n                                            var integrated = __.integrate(x, dx, depth);\r\n                                            integrated.power = integrated.power.subtract(new Frac(1));\r\n                                            retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);\r\n                                        }\r\n                                    }\r\n                                    else\r\n                                        __.integration.stop();\r\n                                }\r\n                                else {\r\n                                    var ag = symbol.args[0].group,\r\n                                            decomposed = __.integration.decompose_arg(arg, dx);\r\n\r\n                                    if(!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())\r\n                                        __.integration.stop();\r\n                                    /**TODO**/ //ASIN, ACOS, ATAN\r\n                                    switch(fname) {\r\n                                        case COS:\r\n                                            retval = _.symfunction(SIN, [arg]);\r\n                                            break;\r\n                                        case SIN:\r\n                                            retval = _.symfunction(COS, [arg]);\r\n                                            retval.negate();\r\n                                            break;\r\n                                        case TAN:\r\n                                            retval = _.parse(format(Settings.LOG + '(sec({0}))', arg));\r\n                                            break;\r\n                                        case SEC:\r\n                                            retval = _.parse(format(Settings.LOG + '(tan({0})+sec({0}))', arg));\r\n                                            break;\r\n                                        case CSC:\r\n                                            retval = _.parse(format('-' + Settings.LOG + '(csc({0})+cot({0}))', arg));\r\n                                            break;\r\n                                        case COT:\r\n                                            retval = _.parse(format(Settings.LOG + '(sin({0}))', arg));\r\n                                            break;\r\n                                        case SINH:\r\n                                            retval = _.symfunction(COSH, [arg]);\r\n                                            break;\r\n                                        case COSH:\r\n                                            retval = _.symfunction(SINH, [arg]);\r\n                                            break;\r\n                                        case TANH:\r\n                                            retval = _.parse(format(Settings.LOG + '(cosh({0}))', arg));\r\n                                            break;\r\n                                        case ASEC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSC:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOT:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //inverse htrig\r\n                                        case ASECH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACSCH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                        case ACOTH:\r\n                                            retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            break;\r\n                                            //end inverse htrig\r\n                                            //htrigh\r\n                                        case SECH:\r\n                                            retval = _.parse(format('atan(sinh({0}))', arg));\r\n                                            break;\r\n                                        case CSCH:\r\n                                            retval = _.parse(format(Settings.LOG + '(tanh(({0})/2))', arg));\r\n                                            break;\r\n                                        case COTH:\r\n                                            retval = _.parse(format(Settings.LOG + '(sinh({0}))', arg));\r\n                                            break;\r\n                                            //end htrig\r\n                                        case EXP:\r\n                                            retval = __.integrate(_.parse(format('e^({0})', arg)), dx, depth);\r\n                                            break;\r\n                                        case 'S':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)', a_, b_, x));\r\n                                            break;\r\n                                        case 'C':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            var b_ = dc[3];\r\n                                            retval = _.parse(format('(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)', a_, b_, x_));\r\n                                            break;\r\n                                        case 'erf':\r\n                                            var arg = symbol.args[0].clone(),\r\n                                                    dc = __.integration.decompose_arg(arg, dx),\r\n                                                    x_ = dc[1],\r\n                                                    a_ = dc[0];\r\n                                            retval = _.parse(format('e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))', a_, x_, arg));\r\n                                            break;\r\n                                        case 'sign':\r\n                                            retval = _.multiply(symbol.clone(), arg.clone());\r\n                                            break;\r\n                                        default:\r\n                                            __.integration.stop();\r\n                                    }\r\n\r\n                                    retval = _.divide(retval, a);\r\n                                }\r\n                            }\r\n                            else if(x.isLinear()) {\r\n                                if(fname === COS || fname === SIN) {\r\n                                    var p = Number(symbol.power);\r\n                                    //check to see if it's negative and then just transform it to sec or csc\r\n                                    if(p < 0) {\r\n                                        symbol.fname = fname === SIN ? CSC : SEC;\r\n                                        symbol.invert().updateHash();\r\n                                        retval = __.integrate(symbol, dx, depth);\r\n                                    }\r\n                                    else {\r\n                                        var arg = symbol.args[0],\r\n                                                rd = symbol.clone(), //cos^(n-1)\r\n                                                rd2 = symbol.clone(), //cos^(n-2)\r\n                                                q = new Symbol((p - 1) / p), //\r\n                                                na = _.multiply(a.clone(), new Symbol(p)).invert(); //1/(n*a)\r\n                                        rd.power = rd.power.subtract(new Frac(1));\r\n                                        rd2.power = rd2.power.subtract(new Frac(2));\r\n\r\n                                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);\r\n                                        if(fname === SIN)\r\n                                            t.negate();\r\n                                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));\r\n                                    }\r\n                                }\r\n                                //tan(x)^n or cot(x)^n\r\n                                else if(fname === TAN || fname === COT) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    if(symbol.args[0].isLinear(dx)) {\r\n                                        var n = symbol.power.subtract(new Frac(1)).toString(),\r\n                                                r = symbol.clone().toUnitMultiplier(),\r\n                                                w = _.parse(format((fname === COT ? '-' : '') + '1/({2}*{0})*{3}({1})^({0})', n, arg, a, fname));\r\n                                        r.power = r.power.subtract(new Frac(2));\r\n                                        if(r.power.equals(0))\r\n                                            r = _.parse(r);\r\n                                        retval = _.subtract(w, __.integrate(r, dx, depth));\r\n                                    }\r\n                                }\r\n                                //sec(x)^n or csc(x)^n\r\n                                else if(fname === SEC || fname === CSC) {\r\n                                    //http://www.sosmath.com/calculus/integration/moretrigpower/moretrigpower.html\r\n                                    var n1 = symbol.power.subtract(new Frac(1)).toString(),\r\n                                            n2 = symbol.power.subtract(new Frac(2)).toString(),\r\n                                            f2 = fname === SEC ? TAN : COT,\r\n                                            r = symbol.clone().toUnitMultiplier(),\r\n                                            parse_str = format((fname === CSC ? '-' : '') + '1/({0}*{1})*{4}({3})^({2})*{5}({3})', a, n1, n2, arg, fname, f2),\r\n                                            w = _.parse(parse_str);\r\n                                    r.power = r.power.subtract(new Frac(2));\r\n                                    if(r.power.equals(0))\r\n                                        r = _.parse(r);\r\n                                    retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));\r\n                                }\r\n                                else if((fname === COSH || fname === SINH) && symbol.power.equals(2)) {\r\n                                    retval = __.integrate(symbol.fnTransform(), dx, depth);\r\n                                }\r\n                                else\r\n                                    __.integration.stop();\r\n                            }\r\n                            else\r\n                                __.integration.stop();\r\n\r\n                            retval.multiplier = retval.multiplier.multiply(m);\r\n                        }\r\n                    }\r\n                    else if(g === PL) {\r\n                        retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                    }\r\n                    else if(g === CB) {\r\n                        var den = symbol.getDenom();\r\n                        if(den.group === S)\r\n                            symbol = _.expand(symbol);\r\n\r\n                        //separate the coefficient since all we care about are symbols containing dx\r\n                        var coeff = symbol.stripVar(dx);\r\n                        //now get only those that apply\r\n                        var cfsymbol = _.divide(symbol.clone(), coeff.clone()); //a coeff free symbol\r\n                        //peform a correction for stripVar. This is a serious TODO!\r\n                        if(coeff.contains(dx)) {\r\n                            cfsymbol = _.multiply(cfsymbol, coeff);\r\n                            coeff = new Symbol(1);\r\n                        }\r\n\r\n                        //if we only have one symbol left then let's not waste time. Just pull the integral\r\n                        //and let the chips fall where they may\r\n                        if(cfsymbol.group !== CB) {\r\n                            if(cfsymbol.equals(1)) {\r\n                                return __.integrate(_.expand(symbol), dx, depth);\r\n                            }\r\n\r\n                            //only factor for multivariate which are polynomials\r\n                            if(cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {\r\n                                cfsymbol = core.Algebra.Factor.factor(cfsymbol);\r\n                            }\r\n\r\n                            retval = __.integrate(cfsymbol, dx, depth);\r\n                        }\r\n                        else {\r\n                            //we collect the symbols and sort them descending group, descending power, descending alpabethically\r\n                            var symbols = cfsymbol.collectSymbols().sort(function (a, b) {\r\n                                if(a.group === b.group) {\r\n                                    if(Number(a.power) === Number(b.power))\r\n                                        if(a < b)\r\n                                            return 1; //I want sin first\r\n                                        else\r\n                                            return -1;\r\n                                    return b.power - a.power; //descending power\r\n                                }\r\n                                return b.group - a.group; //descending groups\r\n                            }).map(function (x) {\r\n                                var unwrapped = Symbol.unwrapSQRT(x, true);\r\n                                if(unwrapped.fname === EXP) {\r\n                                    return _.parse(format('({1})*e^({0})', unwrapped.args[0], unwrapped.multiplier));\r\n                                }\r\n                                return unwrapped;\r\n                            });\r\n                            var l = symbols.length;\r\n                            if(symbol.power < 0) {\r\n                                if(l === 2) {\r\n                                    return __.integrate(_.expand(symbol), dx, depth, opt);\r\n                                }\r\n                            }\r\n                            //otherwise the denominator is one lumped together symbol \r\n                            else {\r\n                                //generate an image for \r\n                                if(l === 2) {\r\n                                    //try u substitution\r\n                                    try {\r\n                                        retval = __.integration.u_substitution(symbols, dx);\r\n                                    }\r\n                                    catch(e) {/* failed :`(*/\r\n                                        ;\r\n                                    }\r\n\r\n                                    if(!retval) {\r\n                                        //no success with u substitution so let's try known combinations\r\n                                        //are they two functions\r\n                                        var g1 = symbols[0].group,\r\n                                                g2 = symbols[1].group,\r\n                                                sym1 = symbols[0],\r\n                                                sym2 = symbols[1],\r\n                                                fn1 = sym1.fname,\r\n                                                fn2 = sym2.fname;\r\n                                        //reset the symbol minus the coeff\r\n                                        symbol = _.multiply(sym1.clone(), sym2.clone());\r\n                                        if(g1 === FN && g2 === FN) {\r\n                                            if(fn1 === LOG || fn2 === LOG) {\r\n                                                retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);\r\n                                            }\r\n                                            else {\r\n                                                symbols.sort(function (a, b) {\r\n                                                    return b.fname > a.fname;\r\n                                                });\r\n                                                var arg1 = sym1.args[0];\r\n                                                //make sure the arguments are suitable. We don't know how to integrate non-linear arguments\r\n                                                if(!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))\r\n                                                    __.integration.stop();\r\n\r\n                                                var decomp = __.integration.decompose_arg(arg1, dx);\r\n                                                x = decomp[1],\r\n                                                        a = decomp[0];\r\n                                                if(!x.isLinear()) //again... linear arguments only wrt x\r\n                                                    __.integration.stop();\r\n\r\n                                                //they have to have the same arguments and then we have cleared all the check to \r\n                                                //make sure we can integrate FN & FN\r\n                                                var arg2 = sym2.args[0];\r\n                                                //make sure that their argument matches\r\n                                                if(arg1.equals(arg2)) {\r\n                                                    if(fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {\r\n                                                        if(sym1.power.lessThan(0))\r\n                                                            __.integration.stop();//we don't know how to handle, sin(x)^n/cos(x)^m where m > n,  yet\r\n                                                        //if it's in the form sin(x)^n*cos(x)^n then we can just return tan(x)^n which we know how to integrate\r\n                                                        if(fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {\r\n                                                            sym1.fname = TAN;\r\n                                                            sym1.updateHash();\r\n                                                            retval = __.integrate(sym1, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            if(even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {\r\n                                                                //transform sin^(2*n) to (1-cos^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-cos({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else if(even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {\r\n                                                                //transform cos^(2*n) to (1-sin^2)^n\r\n                                                                var n = Number(sym1.power) / 2,\r\n                                                                        new_sym = _.parse(format('(1-sin({0})^2)^({1})', sym1.args[0], n));\r\n                                                                retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);\r\n                                                            }\r\n                                                            else {\r\n                                                                var p1_even = core.Utils.even(sym1.power),\r\n                                                                        p2_even = core.Utils.even(sym2.power);\r\n                                                                retval = new Symbol(0);\r\n                                                                if(!p1_even || !p2_even) {\r\n                                                                    var u, r, trans;\r\n                                                                    //since cos(x) is odd it carries du. If sin was odd then it would be the other way around\r\n                                                                    //know that p1 satifies the odd portion in this case. If p2 did than it would contain r\r\n                                                                    if(!p1_even) {\r\n                                                                        //u = sin(x)\r\n                                                                        u = sym2;\r\n                                                                        r = sym1;\r\n                                                                    }\r\n                                                                    else {\r\n                                                                        u = sym1;\r\n                                                                        r = sym2;\r\n                                                                    }\r\n                                                                    //get the sign of du. In this case r carries du as stated before and D(cos(x),x) = -sin(x)\r\n                                                                    var sign = u.fname === COS ? -1 : 1,\r\n                                                                            n = r.power,\r\n                                                                            //remove the du e.g. cos(x)^2*sin(x)^3 dx -> cos(x)^2*sin(x)^2*sin(x). We're left with two \r\n                                                                            //even powers afterwards which can be transformed\r\n                                                                            k = (n - 1) / 2,\r\n                                                                            //make the transformation cos(x)^2 = 1 - sin(x)^2\r\n                                                                            trans = _.parse('(1-' + u.fname + core.Utils.inBrackets(arg1) + '^2)^' + k),\r\n                                                                            sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));\r\n                                                                    //we can now just loop through and integrate each since it's now just a polynomial with functions\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integration.poly_integrate(x.clone()));\r\n                                                                    });\r\n                                                                }\r\n                                                                else {\r\n                                                                    //performs double angle transformation\r\n                                                                    var double_angle = function (symbol) {\r\n                                                                        var p = symbol.power,\r\n                                                                                k = p / 2, e;\r\n                                                                        if(symbol.fname === COS)\r\n                                                                            e = '((1/2)+(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n                                                                        else\r\n                                                                            e = '((1/2)-(cos(2*(' + symbol.args[0] + '))/2))^' + k;\r\n\r\n                                                                        return _.parse(e);\r\n                                                                    };\r\n                                                                    //they're both even so transform both using double angle identities and we'll just\r\n                                                                    //be able to integrate by the sum of integrals\r\n                                                                    var a = double_angle(sym1),\r\n                                                                            b = double_angle(sym2),\r\n                                                                            t = _.multiply(a, b);\r\n                                                                    var sym = _.expand(t);\r\n                                                                    sym.each(function (x) {\r\n                                                                        retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                                    });\r\n                                                                    return _.multiply(retval, coeff);\r\n                                                                }\r\n                                                            }\r\n                                                        }\r\n                                                    }\r\n                                                    //tan(x)*sec(x)^n \r\n                                                    else if(fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {\r\n                                                        retval = _.parse(format('sec({0})^({1})/({1})', sym1.args[0], sym1.power));\r\n                                                    }\r\n                                                    else if(fn1 === TAN && fn2 === SEC && x.isLinear()) {\r\n                                                        //remaining: tan(x)^3*sec(x)^6\r\n                                                        if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                            retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);\r\n                                                        }\r\n                                                        else if(even(sym1.power)) {\r\n                                                            var p = Number(sym1.power) / 2;\r\n                                                            //transform tangent\r\n                                                            var t = _.parse(format('(sec({0})^2-1)^({1})', sym1.args[0], p));\r\n                                                            retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);\r\n                                                        }\r\n                                                        else\r\n                                                            __.integration.stop();\r\n                                                    }\r\n                                                    else if(fn1 === SEC && fn2 === COS) {\r\n                                                        sym1.fname = COS;\r\n                                                        sym1.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    else if(fn1 === SIN && fn2 === CSC) {\r\n                                                        sym2.fname = SIN;\r\n                                                        sym2.invert().updateHash();\r\n                                                        retval = __.integrate(_.multiply(sym1, sym2), dx, depth);\r\n                                                    }\r\n                                                    //tan/cos\r\n                                                    else if(fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2);\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                    else {\r\n                                                        var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());\r\n                                                        retval = __.integrate(_.expand(t), dx, depth);\r\n                                                    }\r\n                                                }\r\n                                                //TODO: In progress\r\n                                                else if((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {\r\n\r\n                                                    if(sym1.isLinear() && sym2.isLinear()) {\r\n                                                        //if in the form cos(a*x)*sin(b*x)\r\n                                                        if(sym1.args[0].isLinear() && sym2.args[0].isLinear()) {\r\n                                                            //use identity (sin(b*x+a*x)+sin(b*x-a*x))/2\r\n                                                            var ax, bx;\r\n                                                            if(fn2 === SIN) {\r\n                                                                ax = sym1.args[0];\r\n                                                                bx = sym2.args[0];\r\n                                                            }\r\n                                                            else {\r\n                                                                bx = sym1.args[0];\r\n                                                                ax = sym2.args[0];\r\n                                                            }\r\n\r\n                                                            //make the transformation\r\n                                                            f = _.parse(format('(sin(({1})+({0}))+sin(({1})-({0})))/2', ax.toString(), bx.toString()));\r\n\r\n                                                            //integrate it\r\n                                                            retval = __.integrate(f, dx, depth);\r\n                                                        }\r\n                                                        else {\r\n                                                            var transformed = trigTransform(symbols);\r\n                                                            retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                    else {\r\n                                                        var transformed = new Symbol(1);\r\n                                                        symbols.map(function (sym) {\r\n                                                            var s = sym.fnTransform();\r\n                                                            transformed = _.multiply(transformed, s);\r\n                                                        });\r\n                                                        var t = _.expand(transformed);\r\n\r\n                                                        retval = __.integrate(t, dx, depth);\r\n\r\n                                                        if(retval.hasIntegral()) {\r\n                                                            retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                                else {\r\n                                                    __.integration.stop();\r\n                                                }\r\n\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === FN && g2 === S) {\r\n                                            var sym1_is_linear = sym1.isLinear();\r\n                                            if(sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Ci', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COS && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Chi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === COSH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Si', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SIN && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))\r\n                                                retval = _.symfunction('Shi', [sym1.args[0]]);\r\n                                            else if(sym1.fname === SINH && sym2.power.equals(-1)) {\r\n                                                retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === LOG && sym2.power.equals(-1)) {\r\n                                                //log(x)^n/x = log(x)^(n+1)/(n+1)\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else if(sym1.fname === 'erf') {\r\n                                                if(sym2.power.equals(1)) {\r\n                                                    var dc = __.integration.decompose_arg(sym1.args[0], dx),\r\n                                                            a_ = dc[0],\r\n                                                            x_ = dc[1],\r\n                                                            arg = sym1.args[0].toString();\r\n                                                    retval = _.parse(format('(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)', a_, x_, arg))\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                //since group S is guaranteed convergence we need not worry about tracking depth of integration\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === EX && g2 === S) {\r\n                                            var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;\r\n                                            if(sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {\r\n                                                retval = _.symfunction('Ei', [sym1.power.clone()]);\r\n                                            }\r\n                                            else if(fn1 === LOG && x.value === sym2.value) {\r\n                                                retval = __.integration.poly_integrate(sym1, dx, depth);\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                        else if(g1 === PL && g2 === S) {\r\n                                            //first try to reduce the top\r\n                                            if(sym2.value === sym1.value && sym1.power.equals(-1)) {\r\n                                                //find the lowest power in the denominator\r\n                                                var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));\r\n                                                //get the lowest common value between denominator and numerator\r\n                                                var pc = Math.min(pd, sym2.power);\r\n                                                //reduce both denominator and numerator by that factor\r\n                                                var factor = sym2.clone();\r\n                                                factor.power = new Frac(pc);\r\n                                                sym2 = _.divide(sym2, factor.clone()); //reduce the denominator\r\n                                                var t = new Symbol(0);\r\n                                                sym1.each(function (x) {\r\n                                                    t = _.add(t, _.divide(x.clone(), factor.clone()));\r\n                                                });\r\n                                                t.multiplier = sym1.multiplier;\r\n                                                symbol = _.divide(sym2, t);\r\n                                            }\r\n                                            else {\r\n                                                symbol = _.expand(symbol);\r\n                                            }\r\n                                            retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                        }\r\n                                        else if(g1 === CP && g2 === S) {\r\n                                            var f = sym1.clone().toLinear(),\r\n                                                    f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);\r\n                                            //handle cases x^(2*n)/sqrt(1-x^2)\r\n                                            if(sym1.power.equals(-1 / 2)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);\r\n                                                var a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {\r\n                                                    //if the substitution \r\n                                                    var c = _.divide(_.multiply(_.pow(b.clone(), new Symbol(2)),\r\n                                                            _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])),\r\n                                                            _.pow(a.clone(), new Symbol(2)));\r\n                                                    c = _.multiply(c, _.symfunction(SQRT, [b]).invert());\r\n                                                    var dummy = _.parse('sin(u)');\r\n                                                    dummy.power = dummy.power.multiply(sym2.power);\r\n                                                    var integral = __.integrate(dummy, 'u', depth);\r\n                                                    var bksub = _.parse(ASIN + '(' + SQRT + '(' + a + '/' + b + ')*' + dx + ')');\r\n                                                    retval = _.multiply(c, integral.sub(new Symbol('u'), bksub));\r\n                                                }\r\n                                                else if(p1 === -1 / 2) {\r\n                                                    var u_transform = function (f, u) {\r\n                                                        var integral = _.parse(__.integrate(f, dx, depth, opt).sub(dx, format(u, dx)));\r\n                                                        if(!integral.hasIntegral())\r\n                                                            return integral;\r\n                                                    }\r\n                                                    if(p2 === -1) {\r\n                                                        retval = u_transform(\r\n                                                                _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                    else if(p2 === -2) {\r\n                                                        //apply transformation to see if it matches asin(x)\r\n                                                        retval = u_transform(\r\n                                                                _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),\r\n                                                                'sqrt(1-1/({0})^2)'\r\n                                                                );\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                            else if(sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {\r\n                                                retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else if(!sym1.power.lessThan(0) && isInt(sym1.power)) {\r\n                                                //sum of integrals\r\n                                                var expanded = _.expand(sym1);\r\n                                                retval = new Symbol(0);\r\n                                                expanded.each(function (x) {\r\n                                                    if(x.group === PL) {\r\n                                                        x.each(function (y) {\r\n                                                            retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));\r\n                                                        });\r\n                                                    }\r\n                                                    else\r\n                                                        retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x), dx, depth));\r\n                                                });\r\n                                            }\r\n                                            else if(sym1.power.lessThan(-2)) {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                            else if(sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {\r\n                                                var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                        a = decomp[0].negate(),\r\n                                                        x = decomp[1],\r\n                                                        b = decomp[3],\r\n                                                        fn = sym1.clone().toLinear();\r\n\r\n                                                if(x.group !== PL && x.isLinear()) {\r\n                                                    var p = Number(sym2.power),\r\n                                                            du = '_u_',\r\n                                                            u = new Symbol(du),\r\n                                                            //pull the integral with the subsitution\r\n                                                            U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())),\r\n                                                            scope = {};\r\n\r\n                                                    //generate a scope for resubbing the symbol\r\n                                                    scope[du] = fn;\r\n                                                    var U2 = _.parse(U, scope);\r\n                                                    retval = __.integrate(U2, dx, 0);\r\n                                                }\r\n                                                else if(sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {\r\n\r\n                                                    //factor out coefficients\r\n                                                    var factors = new core.Algebra.Classes.Factors();\r\n                                                    sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);\r\n                                                    var div = core.Algebra.divide(sym2, sym1);\r\n                                                    //it assumed that the result will be of group CB\r\n                                                    if(div.group !== CB) {\r\n                                                        retval = new Symbol(0);\r\n                                                        div.each(function (t) {\r\n                                                            retval = _.add(retval, __.integrate(t, dx, depth));\r\n                                                        });\r\n                                                        //put back the factors\r\n                                                        factors.each(function (factor) {\r\n                                                            retval = _.divide(retval, factor);\r\n                                                        });\r\n\r\n                                                        retval = _.expand(retval);\r\n                                                    }\r\n                                                    else {\r\n                                                        //try something else\r\n                                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                            }\r\n                                            else {\r\n                                                //handle cases such as (1-x^2)^(n/2)*x^(m) where n is odd ___ cracking knuckles... This can get a little hairy \r\n                                                if(sym1.power.den.equals(2)) {\r\n                                                    //assume the function is in the form (a^2-b*x^n)^(m/2)\r\n                                                    var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx),\r\n                                                            //using the above definition\r\n                                                            a = dc[3], x = dc[1], b = dc[0], bx = dc[2];\r\n                                                    if(x.power.equals(2) && b.lessThan(0)) { //if n is even && b is negative\r\n                                                        //make a equal 1 so we can do a trig sub\r\n                                                        if(!a.equals(1)) { //divide a out of everything\r\n                                                            //move a to the coeff\r\n                                                            coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));\r\n                                                        }\r\n                                                        var u = dx;\r\n                                                        var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))),\r\n                                                                du = _.symfunction(COS, [new Symbol(u)]),\r\n                                                                cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)),\r\n                                                                X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)),\r\n                                                                val = _.multiply(_.multiply(cosn, du), X),\r\n                                                                integral = __.integrate(val, u, depth);\r\n                                                        //but remember that u = asin(sqrt(b)*a*x)\r\n                                                        retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));\r\n                                                    }\r\n                                                    else {\r\n                                                        retval = __.integration.partial_fraction(symbol, dx, depth, opt);\r\n                                                    }\r\n                                                }\r\n                                                else if(f_is_linear) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx, depth);\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                        else if(sym1.isComposite() && sym2.isComposite()) {\r\n                                            //sum of integrals\r\n                                            retval = new Symbol(0);\r\n                                            if(sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {\r\n                                                //combine and pull the integral of each\r\n                                                var sym = _.expand(symbol);\r\n                                                sym.each(function (x) {\r\n                                                    retval = _.add(retval, __.integrate(x, dx, depth));\r\n                                                }, true);\r\n                                            }\r\n                                            else {\r\n                                                var p1 = Number(sym1.power),\r\n                                                        p2 = Number(sym2.power);\r\n                                                if(p1 < 0 && p2 > 0) {\r\n                                                    //swap\r\n                                                    var t = sym1;\r\n                                                    sym1 = sym2;\r\n                                                    sym2 = t;\r\n                                                }\r\n                                                if(p1 === -1 && p2 === -1) {\r\n                                                    retval = __.integration.partial_fraction(symbol, dx);\r\n                                                }\r\n                                                else {\r\n                                                    sym1.each(function (x) {\r\n                                                        var k = _.multiply(x, sym2.clone());\r\n                                                        var integral = __.integrate(k, dx, depth);\r\n                                                        retval = _.add(retval, integral);\r\n                                                    });\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                        else if(g1 === CP && symbols[0].power.greaterThan(0)) {\r\n                                            sym1 = _.expand(sym1);\r\n                                            retval = new Symbol(0);\r\n                                            sym1.each(function (x) {\r\n                                                retval = _.add(retval, __.integrate(_.multiply(x, sym2.clone()), dx, depth));\r\n                                            }, true);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {\r\n                                            sym1 = sym1.fnTransform();\r\n                                            retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);\r\n                                        }\r\n                                        else if(g1 === FN && g2 === CP || g2 === FN && g1 === CP) {\r\n                                            if(g2 === FN && g1 === CP) {\r\n                                                var t = sym1;\r\n                                                sym1 = sym2;\r\n                                                sym2 = t; //swap\r\n                                            }\r\n                                            var du, sym2_clone, p, q, sa, sb;\r\n                                            du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);\r\n                                            sym2_clone = Symbol.unwrapSQRT(sym2, true);\r\n                                            if(du.power.equals(sym2_clone.power)) {\r\n                                                p = new Symbol(sym2.power);\r\n                                                sa = du.clone().toLinear();\r\n                                                sb = sym2.clone().toLinear();\r\n                                                q = core.Algebra.divide(sa.toLinear(), sb);\r\n                                                if(q.isConstant()) {\r\n                                                    var nq = _.pow(q, p.negate());\r\n                                                    retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            var syma = sym1.clone().toLinear();\r\n                                            var symb = sym2.clone().toLinear();\r\n                                            if(g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx)\r\n                                                    && !syma.contains(dx) && !symb.contains(dx)) {\r\n                                                retval = _.parse(format('(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))',\r\n                                                        syma.toString(),\r\n                                                        symb.toString(),\r\n                                                        sym1.power.multiplier.toString(),\r\n                                                        sym2.power.multiplier.toString(),\r\n                                                        dx\r\n                                                        ));\r\n                                            }\r\n                                            else\r\n                                                retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {\r\n                                    var first = symbols[0];\r\n                                    if(first.group === CP) { //TODO {support higher powers of x in the future}\r\n                                        if(first.power.greaterThan(1))\r\n                                            first = _.expand(first);\r\n                                        var r = _.multiply(symbols[1], symbols[2]);\r\n                                        retval = new Symbol(0);\r\n                                        first.each(function (x) {\r\n                                            var t = _.multiply(x, r.clone());\r\n                                            var intg = __.integrate(t, dx, depth);\r\n                                            retval = _.add(retval, intg);\r\n                                        }, true);\r\n                                    }\r\n                                    else {\r\n                                        //try integration by parts although technically it will never work\r\n                                        retval = __.integration.by_parts(symbol, dx, depth, opt);\r\n                                    }\r\n\r\n                                }\r\n                                else if(all_functions(symbols)) {\r\n                                    var t = new Symbol(1);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        t = _.multiply(t, symbols[i].fnTransform());\r\n                                    }\r\n                                    t = _.expand(t);\r\n                                    retval = __.integrate(t, dx, depth);\r\n                                }\r\n                                else {\r\n                                    //one more go\r\n                                    var transformed = trigTransform(symbols);\r\n                                    retval = __.integrate(_.expand(transformed), dx, depth);\r\n                                }\r\n                            }\r\n\r\n                        }\r\n\r\n                        retval = _.multiply(retval, coeff);\r\n                    }\r\n                    //if an integral was found then we return it\r\n                    if(retval)\r\n                        return retval;\r\n                }\r\n\r\n                catch(error) {\r\n                    //do nothing if it's a NoIntegralFound error otherwise let it bubble\r\n                    if(!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))\r\n                        throw error;\r\n                }\r\n\r\n                //no symbol found so we return the integral again\r\n                return _.symfunction('integrate', [original_symbol, dt]);\r\n            }, false);\r\n        },\r\n        defint: function (symbol, from, to, dx) {\r\n            dx = dx || 'x'; //make x the default variable of integration\r\n            var get_value = function (integral, vars, point) {\r\n                try {\r\n                    return _.parse(integral, vars);\r\n                }\r\n                catch(e) {\r\n                    //it failed for some reason so return the limit\r\n                    var lim = __.Limit.limit(integral, dx, point);\r\n                    return lim;\r\n                }\r\n            };\r\n\r\n            var vars = core.Utils.variables(symbol),\r\n                    hasTrig = symbol.hasTrig();\r\n            var retval, integral;\r\n\r\n            // Fix #593 - Only assume the first variable if dx is not defined.\r\n            if(vars.length === 1 && !dx)\r\n                dx = vars[0];\r\n\r\n            if(!hasTrig) {\r\n                integral = __.integrate(symbol, dx);\r\n            }\r\n\r\n            if(!hasTrig && !integral.hasIntegral()) {\r\n                var upper = {},\r\n                        lower = {},\r\n                        a, b;\r\n                upper[dx] = to;\r\n                lower[dx] = from;\r\n\r\n                a = get_value(integral, upper, to, dx);\r\n                b = get_value(integral, lower, from, dx);\r\n                retval = _.subtract(a, b);\r\n            }\r\n            else if(vars.length === 1 && from.isConstant() && to.isConstant()) {\r\n\r\n                var f = core.Utils.build(symbol);\r\n                retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));\r\n            }\r\n            else\r\n                retval = _.symfunction('defint', [symbol, from, to, dx]);\r\n            return retval;\r\n        },\r\n\r\n        Limit: {\r\n            interval: function (start, end) {\r\n                return _.parse(format('[{0}, {1}]', start, end));\r\n            },\r\n            diverges: function () {\r\n                return __.Limit.interval('-Infinity', 'Infinity');\r\n            },\r\n            divide: function (f, g, x, lim, depth) {\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                var fin = f.clone(), gin = g.clone();\r\n\r\n                //But first a little \"cheating\". x/|x| ends up in an infinite loop since the d/dx |x| -> x/|x|\r\n                //To break this loop we simply provide the answer. Keep in mind that currently limit only provides\r\n                //the two-sided limit.\r\n                //Known limit\r\n                if(g.fname === ABS) {\r\n                    var sign = f.sign();\r\n                    var lim_sign = lim.sign();\r\n\r\n                    if(lim.isInfinity)\r\n                        return _.multiply(new Symbol(sign), new Symbol(lim_sign));\r\n\r\n                    else if(lim.equals(0)) {\r\n                        var fm = _.parse(f.multiplier);\r\n                        var gm = _.parse(g.multiplier);\r\n                        return _.divide(_.multiply(fm, __.Limit.interval('-1', '1')), gm);\r\n                    }\r\n                    else {\r\n                        //TODO: Support more limits\r\n                        __.Limit.diverges();\r\n                    }\r\n                }\r\n\r\n                var isInfinity = function (L) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        for(var i = 0; i < L.elements.length; i++)\r\n                            if(!L.elements[i].isInfinity)\r\n                                return false;\r\n                        return true;\r\n                    }\r\n                    return L.isInfinity;\r\n                };\r\n\r\n                var equals = function (L, v) {\r\n                    if(core.Utils.isVector(L)) {\r\n                        return false;\r\n                    }\r\n                    return L.equals(v);\r\n                };\r\n\r\n                var retval;\r\n                do {\r\n                    var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));\r\n                    var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));\r\n\r\n                    //if it's in indeterminate form apply L'Hospital's rule\r\n                    var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);\r\n                    //pull the derivatives\r\n                    if(indeterminate) {\r\n                        var ft = __.diff(f.clone(), x);\r\n                        var gt = __.diff(g.clone(), x);\r\n\r\n                        var t_symbol = _.expand(_.divide(ft, gt));\r\n                        f = t_symbol.getNum();\r\n                        g = t_symbol.getDenom();\r\n\r\n                    }\r\n                }\r\n                while(indeterminate)\r\n\r\n                //REMEMBER: \r\n                //- 1/cos(x)\r\n                //n/0 is still possible since we only checked for 0/0\r\n                var den_is_zero = lim2.equals(0);\r\n                var p = Number(gin.power);\r\n\r\n                if(lim.isConstant(true) && den_is_zero) {\r\n                    retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : undefined);\r\n                }\r\n                else if(den_is_zero) {\r\n                    retval = __.Limit.diverges();\r\n                }\r\n                else {\r\n                    retval = _.divide(lim1, lim2);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            rewriteToLog: function (symbol) {\r\n                var p = symbol.power.clone();\r\n                symbol.toLinear();\r\n                return _.pow(new Symbol('e'), _.multiply(p, _.symfunction(Settings.LOG + '', [symbol])));\r\n            },\r\n            getSubbed: function (f, x, lim) {\r\n                var retval;\r\n                //1. rewrite EX with base e\r\n                if(f.group === EX) {\r\n                    f = __.rewriteToLog(f);\r\n                }\r\n                //2. try simple substitution\r\n                try {\r\n                    retval = f.sub(x, lim);\r\n                }\r\n                catch(e) {\r\n                    //Nope. No go, so just return the unsubbed function so we can test the limit instead.\r\n                    retval = f;\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            isInterval: function (limit) {\r\n                return core.Utils.isVector(limit);\r\n            },\r\n            isConvergent: function (limit) {\r\n                //it's not convergent if it lies on the interval -Infinity to Infinity\r\n                if(\r\n                        //It lies on the interval -Infinity to Infinity\r\n                        __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity ||\r\n                        //We weren't able to calculate the limit\r\n                        limit.containsFunction('limit')\r\n                        ) {\r\n                    return false; //Then no\r\n                }\r\n                return true; //It is\r\n            },\r\n            limit: function (symbol, x, lim, depth) {\r\n                //Simplify the symbol\r\n                if(symbol.isLinear() && symbol.isComposite()) {\r\n\r\n                    //Apply sum of limits\r\n                    var limit = new Symbol(0);\r\n                    symbol.each(function (s) {\r\n                        limit = _.add(limit, __.Limit.limit(s, x, lim, depth));\r\n                    }, true);\r\n\r\n                    return limit;\r\n                }\r\n                ;\r\n\r\n                symbol = core.Algebra.Simplify.simplify(symbol);\r\n\r\n                depth = depth || 1;\r\n\r\n                if(depth++ > Settings.max_lim_depth) {\r\n                    return;\r\n                }\r\n\r\n                //store the multiplier\r\n                var m = _.parse(symbol.multiplier);\r\n                //strip the multiplier\r\n                symbol.toUnitMultiplier();\r\n                try {\r\n                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                    var retval;\r\n                    //we try the simplest option first where c is some limit\r\n                    //lim a as x->c = a where c \r\n                    if(symbol.isConstant(true)) {\r\n                        retval = symbol;\r\n                    }\r\n                    else {\r\n                        var point = {};\r\n                        point[x] = lim;\r\n                        //lim x as x->c = c where c\r\n\r\n                        try {\r\n\r\n                            //evaluate the function at the given limit\r\n                            var t = _.parse(symbol.sub(x, lim), point);\r\n\r\n                            //a constant or infinity is known so we're done\r\n                            if(t.isConstant(true) || t.isInfinity)\r\n                                retval = t;\r\n\r\n                        }\r\n                        catch(e) { /*Nothing. Maybe we tried to divide by zero.*/\r\n                        }\r\n                        ;\r\n\r\n                        if(!retval) {\r\n                            //split the symbol in the numerator and the denominator\r\n                            var num = symbol.getNum();\r\n                            var den = symbol.getDenom();\r\n\r\n                            if(den.isConstant(true)) {\r\n                                //We still don't have a limit so we generate tests.\r\n                                if(symbol.group === EX) {\r\n                                    //https://en.wikipedia.org/wiki/List_of_limits\r\n                                    //Speed boost for exponentials by detecting patterns\r\n                                    var f = symbol.clone().toLinear();\r\n                                    var p = symbol.power.clone();\r\n                                    var _num = f.getNum();\r\n                                    var _den = f.getDenom();\r\n                                    var fn = core.Utils.decompose_fn(_den, x, true);\r\n                                    //start detection of pattern (x/(x+1))^x\r\n                                    if(_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {\r\n                                        retval = _.parse(format('(1/e^({0}))', fn.b));\r\n                                    }\r\n                                    else {\r\n                                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());\r\n                                        //get the base\r\n                                        var pow = symbol_.power.clone();\r\n                                        var base = symbol_.clone().toLinear();\r\n                                        var lim_base = __.Limit.limit(base, x, lim, depth);\r\n                                        var lim_pow = __.Limit.limit(pow, x, lim, depth);\r\n                                        retval = _.pow(lim_base, lim_pow);\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === FN && symbol.args.length === 1) {\r\n                                    var evaluates;\r\n                                    //Squeeze theorem lim f(g(x)) = lim f(lim g))\r\n                                    var arg = __.Limit.limit(symbol.args[0], x, lim, depth);\r\n                                    if(core.Utils.isVector(arg)) {\r\n                                        //get the limit over that interval\r\n                                        retval = arg.map(function (e) {\r\n                                            var clone = symbol.clone();\r\n                                            clone.args[0] = e;\r\n                                            return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);\r\n                                        });\r\n\r\n                                        return _.multiply(m, retval);\r\n                                    }\r\n                                    //if the argument is constant then we're done\r\n                                    else if(arg.isConstant(true)) {\r\n\r\n                                        //double check that it evaluates\r\n                                        var trial = _.symfunction(symbol.fname, [arg]);\r\n                                        //trial evaluation\r\n                                        try {\r\n                                            evaluate(trial);\r\n                                            evaluates = true;\r\n                                        }\r\n                                        catch(e) {\r\n\r\n                                            evaluates = false;\r\n                                        }\r\n                                    }\r\n                                    if(evaluates) {\r\n                                        retval = trial;\r\n                                    }\r\n                                    else {\r\n                                        //if the limit converges. We'll deal with non-convergent ones later\r\n                                        if(__.Limit.isConvergent(arg)) {\r\n                                            if(symbol.fname === LOG) {\r\n                                                switch(arg.toString()) {\r\n                                                    //lim -> 0\r\n                                                    case '0':\r\n                                                        retval = Symbol.infinity().negate();\r\n                                                        break;\r\n                                                    case 'Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                    case '-Infinity':\r\n                                                        retval = Symbol.infinity();\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else if((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {\r\n                                                retval = __.Limit.interval(-1, 1);\r\n                                            }\r\n                                            else if((symbol.fname === TAN)) {\r\n                                                var s_arg = symbol.args[0];\r\n                                                var n = s_arg.getNum();\r\n                                                var d = s_arg.getDenom();\r\n                                                var pi = n.toUnitMultiplier();\r\n                                                if(lim.isInfinity || pi.equals('pi') && d.equals(2)) {\r\n                                                    retval = divergent();\r\n                                                }\r\n                                            }\r\n                                            else if(symbol.fname === Settings.FACTORIAL) {\r\n                                                if(arg.isInfinity)\r\n                                                    return Symbol.infinity();\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === S) {\r\n                                    if(symbol.power > 0)\r\n                                        //these functions always converge to the limit\r\n                                        return _.parse(symbol, point);\r\n                                    else {\r\n                                        //we're dealing with 1/x^n but remember that infinity has already been dealt\r\n                                        //with by substitution\r\n                                        if(core.Utils.even(symbol.power)) {\r\n                                            //even powers converge to infinity\r\n                                            retval = Symbol.infinity();\r\n                                        }\r\n                                        else {\r\n                                            //odd ones don't\r\n                                            retval = __.Limit.diverges();\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else if(symbol.group === CB) {\r\n\r\n                                    var lim1, lim2;\r\n                                    //loop through all the symbols\r\n                                    //thus => lim f*g*h = lim (f*g)*h = (lim f*g)*(lim h)\r\n                                    //symbols of lower groups are generally easier to differentiatee so get them to the right by first sorting\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return a.group - b.group;\r\n                                    });\r\n\r\n                                    var f = symbols.pop();\r\n                                    //calculate the first limit so we can keep going down the list\r\n                                    lim1 = evaluate(__.Limit.limit(f, x, lim, depth));\r\n\r\n                                    //reduces all the limits one at a time\r\n                                    while(symbols.length) {\r\n                                        //get the second limit\r\n                                        var g = symbols.pop();\r\n                                        //get the limit of g\r\n                                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));\r\n\r\n                                        //if the limit is in indeterminate form aplly L'Hospital by inverting g and then f/(1/g)\r\n                                        if((lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2))) {\r\n                                            if(g.containsFunction(LOG)) {\r\n                                                //swap them\r\n                                                g = [f, f = g][0];\r\n                                            }\r\n                                            //invert the symbol\r\n                                            g.invert();\r\n\r\n                                            // Product of infinities\r\n                                            if(lim1.isInfinity && lim2.isInfinity) {\r\n                                                lim1 = Symbol.infinity()\r\n                                            }\r\n                                            else {\r\n                                                lim1 = __.Limit.divide(f, g, x, lim, depth);\r\n                                            }\r\n                                        }\r\n                                        else {\r\n                                            //lim f*g = (lim f)*(lim g)\r\n                                            lim1 = _.multiply(lim1, lim2);\r\n                                            //let f*g equal f and h equal g \r\n                                            f = _.multiply(f, g);\r\n                                        }\r\n                                    }\r\n\r\n                                    //Done, lim1 is the limit we're looking for     \r\n                                    retval = lim1;\r\n                                }\r\n                                else if(symbol.isComposite()) {\r\n                                    var _lim;\r\n                                    if(!symbol.isLinear())\r\n                                        symbol = _.expand(symbol);\r\n                                    //Apply lim f+g = (lim f)+(lim g)\r\n                                    retval = new Symbol(0);\r\n\r\n                                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                                        return b.group - a.group;\r\n                                    });\r\n\r\n                                    var _symbols = [];\r\n                                    //Analyze the functions first\r\n                                    var fns = new Symbol(0);\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i].clone();\r\n                                        if(sym.group === FN || sym.group === CB && sym.hasFunc()) {\r\n                                            fns = _.add(fns, sym);\r\n                                        }\r\n                                        else\r\n                                            _symbols.push(sym);\r\n                                    }\r\n                                    _symbols.unshift(fns);\r\n\r\n                                    //make sure that we didn't just repackage the exact same symbol\r\n                                    if(_symbols.length !== 1) {\r\n                                        symbols = _symbols;\r\n                                    }\r\n\r\n                                    for(var i = 0, l = symbols.length; i < l; i++) {\r\n                                        var sym = symbols[i];\r\n                                        //If the addition of the limits is undefined then the limit diverges so return -infinity to infinity\r\n                                        try {\r\n                                            _lim = __.Limit.limit(sym, x, lim, depth);\r\n                                        }\r\n                                        catch(e) {\r\n                                            _lim = __.Limit.diverges();\r\n                                        }\r\n\r\n                                        try {\r\n                                            retval = _.add(retval, _lim);\r\n                                        }\r\n                                        catch(e) {\r\n                                            if(depth++ > Settings.max_lim_depth) {\r\n                                                return;\r\n                                            }\r\n                                            ;\r\n                                            retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                retval = __.Limit.divide(num, den, x, lim, depth);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //if we still don't have a solution\r\n                    if(!retval)\r\n                        //return it symbolically\r\n                        retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n                catch(e) {\r\n                    //if all else fails return the symbolic function\r\n                    retval = _.symfunction('limit', [symbol, x, lim]);\r\n                }\r\n\r\n                return _.multiply(m, retval);\r\n            }\r\n        },\r\n        Fresnel: {\r\n            S: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('sin(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('S', arguments);\r\n            },\r\n            C: function (x) {\r\n                if(x.isConstant(true)) {\r\n                    return __.defint(_.parse('cos(pi*x^2/2)'), Symbol(0), x, 'x');\r\n                }\r\n                return _.symfunction('C', arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'diff',\r\n            visible: true,\r\n            numargs: [1, 3],\r\n            build: function () {\r\n                return __.diff;\r\n            }\r\n        },\r\n        {\r\n            name: 'sum',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.sum;\r\n            }\r\n        },\r\n        {\r\n            name: 'product',\r\n            visible: true,\r\n            numargs: 4,\r\n            build: function () {\r\n                return __.product;\r\n            }\r\n        },\r\n        {\r\n            name: 'integrate',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.integrate;\r\n            }\r\n        },\r\n        {\r\n            name: 'defint',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.defint;\r\n            }\r\n        },\r\n        {\r\n            name: 'S',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.S;\r\n            }\r\n        },\r\n        {\r\n            name: 'C',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Fresnel.C;\r\n            }\r\n        },\r\n        {\r\n            name: 'limit',\r\n            visible: true,\r\n            numargs: [3, 4],\r\n            build: function () {\r\n                return __.Limit.limit;\r\n            }\r\n        }\r\n    ]);\r\n    //link registered functions externally\r\n    nerdamer.updateAPI();\r\n\r\n})();", "/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * License : MIT\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n\r\n/* global module, Function */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n}\r\n\r\n(function () {\r\n    \"use strict\";\r\n\r\n    /*shortcuts*/\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            N = core.groups.N,\r\n            P = core.groups.P,\r\n            S = core.groups.S,\r\n            EX = core.groups.EX,\r\n            FN = core.groups.FN,\r\n            PL = core.groups.PL,\r\n            CP = core.groups.CP,\r\n            CB = core.groups.CB,\r\n            keys = core.Utils.keys,\r\n            even = core.Utils.even,\r\n            variables = core.Utils.variables,\r\n            format = core.Utils.format,\r\n            round = core.Utils.round,\r\n            Frac = core.Frac,\r\n            isInt = core.Utils.isInt,\r\n            Symbol = core.Symbol,\r\n            CONST_HASH = core.Settings.CONST_HASH,\r\n            math = core.Utils.importFunctions(),\r\n            evaluate = core.Utils.evaluate;\r\n    //*************** CLASSES ***************//\r\n    /**\r\n     * Converts a symbol into an equivalent polynomial arrays of \r\n     * the form [[coefficient_1, power_1],[coefficient_2, power_2], ... ]\r\n     * Univariate polymials only. \r\n     * @param {Symbol|Number} symbol\r\n     * @param {String} variable The variable name of the polynomial\r\n     * @param {int} order\r\n     */\r\n    function Polynomial(symbol, variable, order) {\r\n        if(core.Utils.isSymbol(symbol)) {\r\n            this.parse(symbol);\r\n            this.variable = this.variable || variable;\r\n        }\r\n        else if(!isNaN(symbol)) {\r\n            order = order || 0;\r\n            if(variable === undefined)\r\n                throw new core.exceptions.InvalidVariableNameError('Polynomial expects a variable name when creating using order');\r\n            this.coeffs = [];\r\n            this.coeffs[order] = symbol;\r\n            this.fill(symbol);\r\n        }\r\n        else if(typeof symbol === 'string') {\r\n            this.parse(_.parse(symbol));\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Polynomial given an array of coefficients\r\n     * @param {int[]} arr\r\n     * @param {String} variable\r\n     * @returns {Polynomial}\r\n     */\r\n    Polynomial.fromArray = function (arr, variable) {\r\n        if(typeof variable === 'undefined')\r\n            throw new core.exceptions.InvalidVariableNameError('A variable name must be specified when creating polynomial from array');\r\n        var p = new Polynomial();\r\n        p.coeffs = arr;\r\n        p.variable = variable;\r\n        return p;\r\n    };\r\n\r\n    Polynomial.fit = function (c1, c2, n, base, p, variable) {\r\n        //after having looped through and mod 10 the number to get the matching factor\r\n        var terms = new Array(p + 1),\r\n                t = n - c2;\r\n        terms[0] = c2; //the constants is assumed to be correct\r\n        //constant for x^p is also assumed know so add\r\n        terms[p] = c1;\r\n        t -= c1 * Math.pow(base, p);\r\n        //start fitting\r\n        for(var i = p - 1; i > 0; i--) {\r\n            var b = Math.pow(base, i), //we want as many wholes as possible\r\n                    q = t / b,\r\n                    sign = Math.sign(q);\r\n            var c = sign * Math.floor(Math.abs(q));\r\n            t -= c * b;\r\n            terms[i] = c;\r\n        }\r\n        if(t !== 0)\r\n            return null;\r\n        for(var i = 0; i < terms.length; i++)\r\n            terms[i] = new Frac(terms[i]);\r\n\r\n        return Polynomial.fromArray(terms, variable);\r\n    };\r\n\r\n    Polynomial.prototype = {\r\n        /**\r\n         * Converts Symbol to Polynomial\r\n         * @param {Symbol} symbol\r\n         * @param {Array} c - a collector array\r\n         * @returns {Polynomial}\r\n         */\r\n        parse: function (symbol, c) {\r\n            this.variable = variables(symbol)[0];\r\n            if(!symbol.isPoly())\r\n                throw core.exceptions.NerdamerTypeError('Polynomial Expected! Received ' + core.Utils.text(symbol));\r\n            c = c || [];\r\n            if(!symbol.power.absEquals(1))\r\n                symbol = _.expand(symbol);\r\n\r\n            if(symbol.group === core.groups.N) {\r\n                c[0] = symbol.multiplier;\r\n            }\r\n            else if(symbol.group === core.groups.S) {\r\n                c[symbol.power.toDecimal()] = symbol.multiplier;\r\n            }\r\n            else {\r\n                for(var x in symbol.symbols) {\r\n                    var sub = symbol.symbols[x],\r\n                            p = sub.power;\r\n                    if(core.Utils.isSymbol(p))\r\n                        throw new core.exceptions.NerdamerTypeError('power cannot be a Symbol');\r\n\r\n                    p = sub.group === N ? 0 : p.toDecimal();\r\n                    if(sub.symbols) {\r\n                        this.parse(sub, c);\r\n                    }\r\n                    else {\r\n                        c[p] = sub.multiplier;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.coeffs = c;\r\n\r\n            this.fill();\r\n        },\r\n        /**\r\n         * Fills in the holes in a polynomial with zeroes\r\n         * @param {Number} x - The number to fill the holes with\r\n         */\r\n        fill: function (x) {\r\n            x = Number(x) || 0;\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(this.coeffs[i] === undefined) {\r\n                    this.coeffs[i] = new Frac(x);\r\n                }\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Removes higher order zeros or a specific coefficient\r\n         * @returns {Array}\r\n         */\r\n        trim: function () {\r\n            var l = this.coeffs.length;\r\n            while(l--) {\r\n                var c = this.coeffs[l];\r\n                var equalsZero = c.equals(0);\r\n                if(c && equalsZero) {\r\n                    if(l === 0)\r\n                        break;\r\n                    this.coeffs.pop();\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /*\r\n         * Returns polynomial mod p **currently fails**\r\n         * @param {Number} p\r\n         * @returns {Polynomial}\r\n         */\r\n        modP: function (p) {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = this.coeffs[i];\r\n                if(c < 0) { //go borrow\r\n                    var b; //a coefficient > 0\r\n                    for(var j = i; j < l; j++) {//starting from where we left off\r\n                        if(this.coeffs[j] > 0) {\r\n                            b = this.coeffs[j];\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if(b) { //if such a coefficient exists\r\n                        for(j; j > i; j--) { //go down the line and adjust using p\r\n                            this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));\r\n                            this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));\r\n                        }\r\n                        c = this.coeffs[i]; //reset c\r\n                    }\r\n                }\r\n\r\n                var d = c.mod(p);\r\n                var w = c.subtract(d).divide(p);\r\n                if(!w.equals(0)) {\r\n                    var up_one = i + 1;\r\n                    var next = this.coeffs[up_one] || new Frac(0);\r\n                    next = next.add(w);\r\n                    this.coeffs[up_one] = new Frac(next);\r\n                    this.coeffs[i] = new Frac(d);\r\n                }\r\n            }\r\n\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        add: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.add(b);\r\n            }\r\n            return this;\r\n        },\r\n        /**\r\n         * Adds together 2 polynomials\r\n         * @param {Polynomial} poly\r\n         */\r\n        subtract: function (poly) {\r\n            var l = Math.max(this.coeffs.length, poly.coeffs.length);\r\n            for(var i = 0; i < l; i++) {\r\n                var a = (this.coeffs[i] || new Frac(0)),\r\n                        b = (poly.coeffs[i] || new Frac(0));\r\n                this.coeffs[i] = a.subtract(b);\r\n            }\r\n            return this;\r\n        },\r\n        divide: function (poly) {\r\n            var variable = this.variable,\r\n                    dividend = core.Utils.arrayClone(this.coeffs),\r\n                    divisor = core.Utils.arrayClone(poly.coeffs),\r\n                    n = dividend.length,\r\n                    mp = divisor.length - 1,\r\n                    quotient = [];\r\n\r\n            //loop through the dividend\r\n            for(var i = 0; i < n; i++) {\r\n                var p = n - (i + 1);\r\n                //get the difference of the powers\r\n                var d = p - mp;\r\n                //get the quotient of the coefficients\r\n                var q = dividend[p].divide(divisor[mp]);\r\n\r\n                if(d < 0)\r\n                    break;//the divisor is not greater than the dividend\r\n                //place it in the quotient\r\n                quotient[d] = q;\r\n\r\n                for(var j = 0; j <= mp; j++) {\r\n                    //reduce the dividend\r\n                    dividend[j + d] = dividend[j + d].subtract((divisor[j].multiply(q)));\r\n                }\r\n            }\r\n\r\n            //clean up\r\n            var p1 = Polynomial.fromArray(dividend, variable || 'x').trim(), //pass in x for safety\r\n                    p2 = Polynomial.fromArray(quotient, variable || 'x');\r\n            return [p2, p1];\r\n        },\r\n        multiply: function (poly) {\r\n            var l1 = this.coeffs.length, l2 = poly.coeffs.length,\r\n                    c = []; //array to be returned\r\n            for(var i = 0; i < l1; i++) {\r\n                var x1 = this.coeffs[i];\r\n                for(var j = 0; j < l2; j++) {\r\n                    var k = i + j, //add the powers together\r\n                            x2 = poly.coeffs[j],\r\n                            e = c[k] || new Frac(0); //get the existing term from the new array\r\n                    c[k] = e.add(x1.multiply(x2)); //multiply the coefficients and add to new polynomial array\r\n                }\r\n            }\r\n            this.coeffs = c;\r\n            return this;\r\n        },\r\n        /**\r\n         * Checks if a polynomial is zero\r\n         * @returns {Boolean}\r\n         */\r\n        isZero: function () {\r\n            var l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /** \r\n         * Substitutes in a number n into the polynomial p(n)\r\n         * @param {Number} n\r\n         * @returns {Frac}\r\n         */\r\n        sub: function (n) {\r\n            var sum = new Frac(0), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var t = this.coeffs[i];\r\n                if(!t.equals(0))\r\n                    sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));\r\n            }\r\n            return sum;\r\n        },\r\n        /**\r\n         * Returns a clone of the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        clone: function () {\r\n            var p = new Polynomial();\r\n            p.coeffs = this.coeffs;\r\n            p.variable = this.variable;\r\n            return p;\r\n        },\r\n        /**\r\n         * Gets the degree of the polynomial\r\n         * @returns {Number}\r\n         */\r\n        deg: function () {\r\n            this.trim();\r\n            return this.coeffs.length - 1;\r\n        },\r\n        /**\r\n         * Returns a lead coefficient\r\n         * @returns {Frac}\r\n         */\r\n        lc: function () {\r\n            return this.coeffs[this.deg()].clone();\r\n        },\r\n        /**\r\n         * Converts polynomial into a monic polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        monic: function () {\r\n            var lc = this.lc(), l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++)\r\n                this.coeffs[i] = this.coeffs[i].divide(lc);\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the GCD of two polynomials\r\n         * @param {Polynomial} poly\r\n         * @returns {Polynomial}\r\n         */\r\n        gcd: function (poly) {\r\n            //get the maximum power of each\r\n            var mp1 = this.coeffs.length - 1,\r\n                    mp2 = poly.coeffs.length - 1,\r\n                    T;\r\n            //swap so we always have the greater power first\r\n            if(mp1 < mp2) {\r\n                return poly.gcd(this);\r\n            }\r\n            var a = this;\r\n\r\n            while(!poly.isZero()) {\r\n                var t = poly.clone();\r\n                a = a.clone();\r\n                T = a.divide(t);\r\n                poly = T[1];\r\n                a = t;\r\n            }\r\n\r\n            var gcd = core.Math2.QGCD.apply(null, a.coeffs);\r\n            if(!gcd.equals(1)) {\r\n                var l = a.coeffs.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    a.coeffs[i] = a.coeffs[i].divide(gcd);\r\n                }\r\n            }\r\n            return a;\r\n        },\r\n        /**\r\n         * Differentiates the polynomial\r\n         * @returns {Polynomial}\r\n         */\r\n        diff: function () {\r\n            var new_array = [], l = this.coeffs.length;\r\n            for(var i = 1; i < l; i++)\r\n                new_array.push(this.coeffs[i].multiply(new Frac(i)));\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Integrates the polynomial\r\n         * @returns {Polynomial} \r\n         */\r\n        integrate: function () {\r\n            var new_array = [0], l = this.coeffs.length;\r\n            for(var i = 0; i < l; i++) {\r\n                var c = new Frac(i + 1);\r\n                new_array[c] = this.coeffs[i].divide(c);\r\n            }\r\n            this.coeffs = new_array;\r\n            return this;\r\n        },\r\n        /**\r\n         * Returns the Greatest common factor of the polynomial\r\n         * @param {bool} toPolynomial - true if a polynomial is wanted\r\n         * @returns {Frac|Polynomial}\r\n         */\r\n        gcf: function (toPolynomial) {\r\n            //get the first nozero coefficient and returns its power\r\n            var fnz = function (a) {\r\n                for(var i = 0; i < a.length; i++)\r\n                    if(!a[i].equals(0))\r\n                        return i;\r\n            },\r\n                    ca = [];\r\n            for(var i = 0; i < this.coeffs.length; i++) {\r\n                var c = this.coeffs[i];\r\n                if(!c.equals(0) && ca.indexOf(c) === -1)\r\n                    ca.push(c);\r\n            }\r\n            var p = [core.Math2.QGCD.apply(undefined, ca), fnz(this.coeffs)].toDecimal();\r\n\r\n            if(toPolynomial) {\r\n                var parr = [];\r\n                parr[p[1] - 1] = p[0];\r\n                p = Polynomial.fromArray(parr, this.variable).fill();\r\n            }\r\n\r\n            return p;\r\n        },\r\n        /**\r\n         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2\r\n         * @param {bool} incl_img - Include imaginary numbers \r\n         */\r\n        quad: function (incl_img) {\r\n            var roots = [];\r\n            if(this.coeffs.length > 3)\r\n                throw new Error('Cannot calculate quadratic order of ' + (this.coeffs.length - 1));\r\n            if(this.coeffs.length === 0)\r\n                throw new Error('Polynomial array has no terms');\r\n            var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];\r\n            var dsc = b * b - 4 * a * c;\r\n            if(dsc < 0 && !incl_img)\r\n                return roots;\r\n            else {\r\n                roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);\r\n                roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);\r\n            }\r\n            return roots;\r\n        },\r\n        /**\r\n         * Makes polynomial square free\r\n         * @returns {Array}\r\n         */\r\n        squareFree: function () {\r\n\r\n            var a = this.clone(),\r\n                    i = 1,\r\n                    b = a.clone().diff(),\r\n                    c = a.clone().gcd(b),\r\n                    w = a.divide(c)[0];\r\n            var output = Polynomial.fromArray([new Frac(1)], a.variable);\r\n            while(!c.equalsNumber(1)) {\r\n                var y = w.gcd(c);\r\n                var z = w.divide(y)[0];\r\n                //one of the factors may have shown up since it's square but smaller than the \r\n                //one where finding\r\n                if(!z.equalsNumber(1) && i > 1) {\r\n                    var t = z.clone();\r\n                    for(var j = 1; j < i; j++)\r\n                        t.multiply(z.clone());\r\n                    z = t;\r\n                }\r\n                output = output.multiply(z);\r\n                i++;\r\n                w = y;\r\n                c = c.divide(y)[0];\r\n            }\r\n\r\n            return [output, w, i];\r\n        },\r\n        /**\r\n         * Converts polynomial to Symbol\r\n         * @returns {Symbol}\r\n         */\r\n        toSymbol: function () {\r\n            var l = this.coeffs.length,\r\n                    variable = this.variable;\r\n            if(l === 0)\r\n                return new core.Symbol(0);\r\n            var end = l - 1, str = '';\r\n\r\n            for(var i = 0; i < l; i++) {\r\n                //place the plus sign for all but the last one\r\n                var plus = i === end ? '' : '+',\r\n                        e = this.coeffs[i];\r\n                if(!e.equals(0))\r\n                    str += (e + '*' + variable + '^' + i + plus);\r\n            }\r\n            return _.parse(str);\r\n        },\r\n        /**\r\n         * Checks if polynomial is equal to a number\r\n         * @param {Number} x\r\n         * @returns {Boolean}\r\n         */\r\n        equalsNumber: function (x) {\r\n            this.trim();\r\n            return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);\r\n        },\r\n        toString: function () {\r\n            return this.toSymbol().toString();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * TODO\r\n     * ===================================================================================\r\n     * THIS METHOD HAS A NASTY HIDDEN BUG. IT HAS INCONSISTENT RETURN TYPES PRIMARILY DUE TO \r\n     * WRONG ASSUMPTIONS AT THE BEGINNING. THE ASSUMPTION WAS THAT COEFFS WERE ALWAYS GOING BE NUMBERS\r\n     * NOT TAKING INTO ACCOUNT THAT IMAGINARY NUMBERS. FIXING THIS BREAKS WAY TOO MANY TESTS \r\n     * AT THEM MOMENT WHICH I DON'T HAVE TO FIX\r\n     * ===================================================================================\r\n     * If the symbols is of group PL or CP it will return the multipliers of each symbol\r\n     * as these are polynomial coefficients. CB symbols are glued together by multiplication\r\n     * so the symbol multiplier carries the coefficients for all contained symbols.\r\n     * For S it just returns it's own multiplier. This function doesn't care if it's a polynomial or not\r\n     * @param {Array} c The coefficient array\r\n     * @param {boolean} with_order \r\n     * @return {Array}\r\n     */\r\n    Symbol.prototype.coeffs = function (c, with_order) {\r\n        if(with_order && !this.isPoly(true))\r\n            _.error('Polynomial expected when requesting coefficients with order');\r\n        c = c || [];\r\n        var s = this.clone().distributeMultiplier();\r\n        if(s.isComposite()) {\r\n            for(var x in s.symbols) {\r\n                var sub = s.symbols[x];\r\n                if(sub.isComposite()) {\r\n                    sub.clone().distributeMultiplier().coeffs(c, with_order);\r\n                }\r\n                else {\r\n                    if(with_order)\r\n                        c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;\r\n                    else {\r\n                        c.push(sub.multiplier);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if(with_order)\r\n                c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;\r\n            else {\r\n                if(s.group === CB && s.isImaginary()) {\r\n                    var m = new Symbol(s.multiplier);\r\n                    s.each(function (x) {\r\n                        //add the imaginary part\r\n                        if(x.isConstant(true) || x.imaginary)\r\n                            m = _.multiply(m, x);\r\n                    });\r\n                    c.push(m);\r\n                }\r\n                else\r\n                    c.push(s.multiplier);\r\n            }\r\n        }\r\n        //fill the holes\r\n        if(with_order) {\r\n            for(var i = 0; i < c.length; i++)\r\n                if(c[i] === undefined)\r\n                    c[i] = new Symbol(0);\r\n        }\r\n        return c;\r\n    };\r\n    Symbol.prototype.tBase = function (map) {\r\n        if(typeof map === 'undefined')\r\n            throw new Error('Symbol.tBase requires a map object!');\r\n        var terms = [];\r\n        var symbols = this.collectSymbols(null, null, null, true),\r\n                l = symbols.length;\r\n        for(var i = 0; i < l; i++) {\r\n            var symbol = symbols[i],\r\n                    g = symbol.group,\r\n                    nterm = new MVTerm(symbol.multiplier, [], map);\r\n            if(g === CB) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n                    nterm.terms[map[x]] = sym.power;\r\n                }\r\n            }\r\n            else {\r\n                nterm.terms[map[symbol.value]] = symbol.power;\r\n            }\r\n\r\n            terms.push(nterm.fill());\r\n            nterm.updateCount();\r\n        }\r\n        return terms;\r\n    };\r\n    Symbol.prototype.altVar = function (x) {\r\n        var m = this.multiplier.toString(), p = this.power.toString();\r\n        return (m === '1' ? '' : m + '*') + x + (p === '1' ? '' : '^' + p);\r\n    };\r\n    /**\r\n     * Checks to see if the symbols contain the same variables\r\n     * @param {Symbol} symbol\r\n     * @returns {Boolean}\r\n     */\r\n    Symbol.prototype.sameVars = function (symbol) {\r\n        if(!(this.symbols || this.group === symbol.group))\r\n            return false;\r\n        for(var x in this.symbols) {\r\n            var a = this.symbols[x], b = symbol.symbols[x];\r\n            if(!b)\r\n                return false;\r\n            if(a.value !== b.value)\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Groups the terms in a symbol with respect to a variable\r\n     * For instance the symbol {a*b^2*x^2+a*b*x^2+x+6} returns [6,1,a*b+a*b^2]\r\n     * @returns {Factors}\r\n     */\r\n    Symbol.prototype.groupTerms = function (x) {\r\n        x = String(x);\r\n        var f, p, egrouped;\r\n        var grouped = [];\r\n        this.each(function (e) {\r\n            if(e.group === PL) {\r\n                egrouped = e.groupTerms(x);\r\n                for(var i = 0; i < egrouped.length; i++) {\r\n                    var el = egrouped[i];\r\n                    if(el)\r\n                        grouped[i] = el;\r\n                }\r\n            }\r\n            else {\r\n                f = core.Utils.decompose_fn(e, x, true);\r\n                p = f.x.value === x ? Number(f.x.power) : 0;\r\n                //check if there's an existing value\r\n                grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);\r\n            }\r\n        });\r\n        return grouped;\r\n    };\r\n    /**\r\n     * Use this to collect Factors\r\n     * @returns {Symbol[]}\r\n     */\r\n    Symbol.prototype.collectFactors = function () {\r\n        var factors = [];\r\n        if(this.group === CB)\r\n            this.each(function (x) {\r\n                factors.push(x.clone());\r\n            });\r\n        else\r\n            factors.push(this.clone());\r\n        return factors;\r\n    };\r\n    /**\r\n     * A container class for factors\r\n     * @returns {Factors}\r\n     */\r\n    function Factors() {\r\n        this.factors = {};\r\n        this.length = 0;\r\n    }\r\n    ;\r\n    Factors.prototype.getNumberSymbolics = function () {\r\n        var n = 0;\r\n        this.each(function (x) {\r\n            if(!x.isConstant(true))\r\n                n++;\r\n        });\r\n        return n;\r\n    };\r\n    /**\r\n     * Adds the factors to the factor object\r\n     * @param {Symbo} s\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.add = function (s) {\r\n        if(s.equals(0))\r\n            return this; //nothing to add\r\n\r\n        //we don't want to carry -1 as a factor. If a factor already exists,\r\n        //then add the minus one to that factor and return.\r\n        if(s.equals(-1) && this.length > 0) {\r\n            var fo = core.Utils.firstObject(this.factors, null, true);\r\n            this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());\r\n            delete this.factors[fo.key];\r\n            this.length--;\r\n            return this;\r\n        }\r\n\r\n        if(s.group === CB) {\r\n            var factors = this;\r\n            if(!s.multiplier.equals(1))\r\n                factors.add(new Symbol(s.multiplier));\r\n            s.each(function (x) {\r\n                factors.add(x);\r\n            });\r\n        }\r\n        else {\r\n            if(this.preAdd) //if a preAdd function was defined call it to do prep\r\n                s = this.preAdd(s);\r\n            if(this.pFactor) //if the symbol isn't linear add back the power\r\n                s = _.pow(s, new Symbol(this.pFactor));\r\n\r\n            var is_constant = s.isConstant();\r\n            if(is_constant && s.equals(1))\r\n                return this; //don't add 1\r\n            var v = is_constant ? s.value : s.text();\r\n            if(v in this.factors) {\r\n                this.factors[v] = _.multiply(this.factors[v], s);\r\n                //did the addition cancel out the existing factor? If so remove it and decrement the length\r\n                if(this.factors[v].equals(1)) {\r\n                    delete this.factors[v];\r\n                    this.length--;\r\n                }\r\n            }\r\n            else {\r\n                this.factors[v] = s;\r\n                this.length++;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Converts the factor object to a Symbol\r\n     * @returns {Symbol}\r\n     */\r\n    Factors.prototype.toSymbol = function () {\r\n        var factored = new Symbol(1);\r\n        var factors = Object.values(this.factors).sort(function (a, b) {\r\n            return a.group > b.group;\r\n        });\r\n\r\n        for(var i = 0, l = factors.length; i < l; i++) {\r\n            var f = factors[i];\r\n\r\n            //don't wrap group S or FN\r\n            var factor = f.power.equals(1) && f.fname !== '' /* don't wrap it twice */ ?\r\n                    _.symfunction(core.PARENTHESIS, [f]) : f;\r\n\r\n            factored = _.multiply(factored, factor);\r\n        }\r\n        if(factored.fname === '')\r\n            factored = Symbol.unwrapPARENS(factored);\r\n        return factored;\r\n    };\r\n    /**\r\n     * Merges 2 factor objects into one\r\n     * @param {Factor} o\r\n     * @returns {Factors}\r\n     */\r\n    Factors.prototype.merge = function (o) {\r\n        for(var x in o) {\r\n            if(x in this.factors)\r\n                this.factors[x] = _.multiply(this.factors[x], o[x]);\r\n            else\r\n                this.factors[x] = o[x];\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * The iterator for the factor object\r\n     * @param {Function} f - callback\r\n     * @returns {Factor}\r\n     */\r\n    Factors.prototype.each = function (f) {\r\n        for(var x in this.factors) {\r\n            var factor = this.factors[x];\r\n            if(factor.fname === core.PARENTHESIS && factor.isLinear())\r\n                factor = factor.args[0];\r\n            f.call(this, factor, x);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Return the number of factors contained in the factor object\r\n     * @returns {int}\r\n     */\r\n    Factors.prototype.count = function () {\r\n        return keys(this.factors).length;\r\n    };\r\n    /**\r\n     * Cleans up factors from -1\r\n     * @returns {undefined}\r\n     */\r\n    Factors.prototype.clean = function () {\r\n        try {\r\n            var h = core.Settings.CONST_HASH;\r\n            if(this.factors[h].lessThan(0)) {\r\n                if(this.factors[h].equals(-1))\r\n                    delete this.factors[h];\r\n                else\r\n                    this.factors[h].negate();\r\n                this.each(function (x) {\r\n                    x.negate();\r\n                });\r\n            }\r\n        }\r\n        catch(e) {\r\n        }\r\n        ;\r\n    };\r\n    Factors.prototype.toString = function () {\r\n        return this.toSymbol().toString();\r\n    };\r\n\r\n    //a wrapper for performing multivariate division\r\n    function MVTerm(coeff, terms, map) {\r\n        this.terms = terms || [];\r\n        this.coeff = coeff;\r\n        this.map = map; //careful! all maps are the same object\r\n        this.sum = new core.Frac(0);\r\n        this.image = undefined;\r\n    }\r\n    ;\r\n    MVTerm.prototype.updateCount = function () {\r\n        this.count = this.count || 0;\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            if(!this.terms[i].equals(0))\r\n                this.count++;\r\n        }\r\n        return this;\r\n    };\r\n    MVTerm.prototype.getVars = function () {\r\n        var vars = [];\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var term = this.terms[i],\r\n                    rev_map = this.getRevMap();\r\n            if(!term.equals(0))\r\n                vars.push(this.rev_map[i]);\r\n        }\r\n        return vars.join(' ');\r\n    };\r\n    MVTerm.prototype.len = function () {\r\n        if(typeof this.count === 'undefined') {\r\n            this.updateCount();\r\n        }\r\n        return this.count;\r\n    };\r\n    MVTerm.prototype.toSymbol = function (rev_map) {\r\n        rev_map = rev_map || this.getRevMap();\r\n        var symbol = new Symbol(this.coeff);\r\n        for(var i = 0; i < this.terms.length; i++) {\r\n            var v = rev_map[i],\r\n                    t = this.terms[i];\r\n            if(t.equals(0) || v === CONST_HASH)\r\n                continue;\r\n            var mapped = new Symbol(v);\r\n            mapped.power = t;\r\n            symbol = _.multiply(symbol, mapped);\r\n        }\r\n        return symbol;\r\n    };\r\n    MVTerm.prototype.getRevMap = function () {\r\n        if(this.rev_map)\r\n            return this.rev_map;\r\n        var o = {};\r\n        for(var x in this.map)\r\n            o[this.map[x]] = x;\r\n        this.rev_map = o;\r\n        return o;\r\n    };\r\n    MVTerm.prototype.generateImage = function () {\r\n        this.image = this.terms.join(' ');\r\n        return this;\r\n    },\r\n            MVTerm.prototype.getImg = function () {\r\n                if(!this.image)\r\n                    this.generateImage();\r\n                return this.image;\r\n            },\r\n            MVTerm.prototype.fill = function () {\r\n                var l = this.map.length;\r\n                for(var i = 0; i < l; i++) {\r\n                    if(typeof this.terms[i] === 'undefined')\r\n                        this.terms[i] = new core.Frac(0);\r\n                    else {\r\n                        this.sum = this.sum.add(this.terms[i]);\r\n                    }\r\n                }\r\n                return this;\r\n            };\r\n    MVTerm.prototype.divide = function (mvterm) {\r\n        var c = this.coeff.divide(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.multiply = function (mvterm) {\r\n        var c = this.coeff.multiply(mvterm.coeff),\r\n                l = this.terms.length,\r\n                new_mvterm = new MVTerm(c, [], this.map);\r\n        for(var i = 0; i < l; i++) {\r\n            new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);\r\n            new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);\r\n        }\r\n        return new_mvterm;\r\n    };\r\n    MVTerm.prototype.isZero = function () {\r\n        return this.coeff.equals(0);\r\n    };\r\n    MVTerm.prototype.toString = function () {\r\n        return '{ coeff: ' + this.coeff.toString() + ', terms: [' +\r\n                this.terms.join(',') + ']: sum: ' + this.sum.toString() + ', count: ' + this.count + '}';\r\n    };\r\n\r\n    core.Utils.toMapObj = function (arr) {\r\n        var c = 0, o = {};\r\n        for(var i = 0; i < arr.length; i++) {\r\n            var v = arr[i];\r\n            if(typeof o[v] === 'undefined') {\r\n                o[v] = c;\r\n                c++;\r\n            }\r\n        }\r\n        o.length = c;\r\n        return o;\r\n    };\r\n    core.Utils.filledArray = function (v, n, clss) {\r\n        var a = [];\r\n        while(n--) {\r\n            a[n] = clss ? new clss(v) : v;\r\n        }\r\n        return a;\r\n    };\r\n    core.Utils.arrSum = function (arr) {\r\n        var sum = 0, l = arr.length;\r\n        for(var i = 0; i < l; i++)\r\n            sum += arr[i];\r\n        return sum;\r\n    };\r\n    /**\r\n     * Determines if 2 arrays have intersecting elements.\r\n     * @param {Array} a\r\n     * @param {Array} b\r\n     * @returns {Boolean} True if a and b have intersecting elements.\r\n     */\r\n    core.Utils.haveIntersection = function (a, b) {\r\n        var t;\r\n        if(b.length > a.length)\r\n            t = b, b = a, a = t; // indexOf to loop over shorter\r\n        return a.some(function (e) {\r\n            return b.indexOf(e) > -1;\r\n        });\r\n    };\r\n    /**\r\n     * Substitutes out functions as variables so they can be used in regular algorithms\r\n     * @param {Symbol} symbol\r\n     * @param {Object} map\r\n     * @returns {String} The expression string\r\n     */\r\n    core.Utils.subFunctions = function (symbol, map) {\r\n        map = map || {};\r\n        var subbed = [];\r\n        symbol.each(function (x) {\r\n            if(x.group === FN || x.previousGroup === FN) {\r\n                //we need a new variable name so why not use one of the existing\r\n                var val = core.Utils.text(x, 'hash'), tvar = map[val];\r\n                if(!tvar) {\r\n                    //generate a unique enough name\r\n                    var t = x.fname + keys(map).length;\r\n                    map[val] = t;\r\n                    subbed.push(x.altVar(t));\r\n                }\r\n                else\r\n                    subbed.push(x.altVar(tvar));\r\n            }\r\n            else if(x.group === CB || x.group === PL || x.group === CP) {\r\n                subbed.push(core.Utils.subFunctions(x, map));\r\n            }\r\n            else\r\n                subbed.push(x.text());\r\n        });\r\n        if(symbol.group === CP || symbol.group === PL)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('+')));\r\n        ;\r\n        if(symbol.group === CB)\r\n            return symbol.altVar(core.Utils.inBrackets(subbed.join('*')));\r\n        return symbol.text();\r\n    };\r\n    core.Utils.getFunctionsSubs = function (map) {\r\n        var subs = {};\r\n        //prepare substitutions\r\n        for(var x in map)\r\n            subs[map[x]] = _.parse(x);\r\n        return subs;\r\n    };\r\n\r\n    var __ = core.Algebra = {\r\n        version: '1.4.6',\r\n        proots: function (symbol, decp) {\r\n            //the roots will be rounded up to 7 decimal places.\r\n            //if this causes trouble you can explicitly pass in a different number of places\r\n            //rarr for polynomial of power n is of format [n, coeff x^n, coeff x^(n-1), ..., coeff x^0]\r\n            decp = decp || 7;\r\n            var zeros = 0;\r\n            var known_roots = [];\r\n            var get_roots = function (rarr, powers, max) {\r\n                var roots = calcroots(rarr, powers, max).concat(known_roots);\r\n                for(var i = 0; i < zeros; i++)\r\n                    roots.unshift(0);\r\n                return roots;\r\n            };\r\n\r\n            if(symbol instanceof Symbol && symbol.isPoly()) {\r\n                symbol.distributeMultiplier();\r\n                //make it so the symbol has a constants as the lowest term\r\n                if(symbol.group === PL) {\r\n                    var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));\r\n                    var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();\r\n                    symbol = _.expand(_.divide(symbol, lowest_symbol));\r\n                    known_roots.push(0); //add zero since this is a known root\r\n                }\r\n                if(symbol.group === core.groups.S) {\r\n                    return [0];\r\n                }\r\n                else if(symbol.group === core.groups.PL) {\r\n                    var powers = keys(symbol.symbols),\r\n                            minpower = core.Utils.arrayMin(powers),\r\n                            symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + '^' + minpower));\r\n                }\r\n\r\n                var variable = keys(symbol.symbols).sort().pop(),\r\n                        sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable],\r\n                        g = sym.group,\r\n                        powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols),\r\n                        rarr = [],\r\n                        max = core.Utils.arrayMax(powers); //maximum power and degree of polynomial to be solved\r\n\r\n                // Prepare the data\r\n                for(var i = 1; i <= max; i++) {\r\n                    var c = 0; //if there is no power then the hole must be filled with a zero\r\n                    if(powers.indexOf(i + '') !== -1) {\r\n                        if(g === S) {\r\n                            c = sym.multiplier;\r\n                        }\r\n                        else {\r\n                            c = sym.symbols[i].multiplier;\r\n                        }\r\n                    }\r\n                    // Insert the coeffient but from the front\r\n                    rarr.unshift(c);\r\n                }\r\n\r\n                rarr.push(symbol.symbols[CONST_HASH].multiplier);\r\n\r\n                if(sym.group === S)\r\n                    rarr[0] = sym.multiplier;//the symbol maybe of group CP with one variable\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else if(core.Utils.isArray(symbol)) {\r\n                var parr = symbol;\r\n                var rarr = [],\r\n                        powers = [],\r\n                        last_power = 0;\r\n                for(var i = 0; i < parr.length; i++) {\r\n\r\n                    var coeff = parr[i][0],\r\n                            pow = parr[i][1],\r\n                            d = pow - last_power - 1;\r\n                    //insert the zeros\r\n                    for(var j = 0; j < d; j++)\r\n                        rarr.unshift(0);\r\n\r\n                    rarr.unshift(coeff);\r\n                    if(pow !== 0)\r\n                        powers.push(pow);\r\n                    last_power = pow;\r\n                }\r\n                var max = Math.max.apply(undefined, powers);\r\n\r\n                return get_roots(rarr, powers, max);\r\n            }\r\n            else {\r\n                throw new core.exceptions.NerdamerTypeError('Cannot calculate roots. Symbol must be a polynomial!');\r\n            }\r\n\r\n            function calcroots(rarr, powers, max) {\r\n                var MAXDEGREE = 100; // Degree of largest polynomial accepted by this script.\r\n\r\n                // Make a clone of the coefficients before appending the max power\r\n                var p = rarr.slice(0);\r\n\r\n                // Divide the string up into its individual entries, which--presumably--are separated by whitespace\r\n                rarr.unshift(max);\r\n\r\n                if(max > MAXDEGREE) {\r\n                    throw new core.exceptions.ValueLimitExceededError(\"This utility accepts polynomials of degree up to \" + MAXDEGREE + \". \");\r\n                }\r\n\r\n                var zeroi = [], // Vector of imaginary components of roots\r\n                        degreePar = {};    // degreePar is a dummy variable for passing the parameter POLYDEGREE by reference\r\n                degreePar.Degree = max;\r\n\r\n                for(i = 0; i < max; i++) {\r\n                    zeroi.push(0);\r\n                }\r\n                var zeror = zeroi.slice(0); // Vector of real components of roots\r\n\r\n                // Find the roots\r\n                //--> Begin Jenkins-Traub\r\n\r\n                /*\r\n                 * A verbatim copy of Mr. David Binner's Jenkins-Traub port\r\n                 */\r\n                function QuadSD_ak1(NN, u, v, p, q, iPar) {\r\n                    // Divides p by the quadratic 1, u, v placing the quotient in q and the remainder in a, b\r\n                    // iPar is a dummy variable for passing in the two parameters--a and b--by reference\r\n                    q[0] = iPar.b = p[0];\r\n                    q[1] = iPar.a = -(u * iPar.b) + p[1];\r\n\r\n                    for(var i = 2; i < NN; i++) {\r\n                        q[i] = -(u * iPar.a + v * iPar.b) + p[i];\r\n                        iPar.b = iPar.a;\r\n                        iPar.a = q[i];\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function calcSC_ak1(DBL_EPSILON, N, a, b, iPar, K, u, v, qk) {\r\n                    // This routine calculates scalar quantities used to compute the next K polynomial and\r\n                    // new estimates of the quadratic coefficients.\r\n                    // calcSC -\tinteger variable set here indicating how the calculations are normalized\r\n                    // to avoid overflow.\r\n                    // iPar is a dummy variable for passing in the nine parameters--a1, a3, a7, c, d, e, f, g, and h --by reference\r\n\r\n                    // sdPar is a dummy variable for passing the two parameters--c and d--into QuadSD_ak1 by reference\r\n                    var sdPar = new Object(),\r\n                            // TYPE = 3 indicates the quadratic is almost a factor of K\r\n                            dumFlag = 3;\r\n\r\n                    // Synthetic division of K by the quadratic 1, u, v\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(N, u, v, K, qk, sdPar);\r\n                    iPar.c = sdPar.a;\r\n                    iPar.d = sdPar.b;\r\n\r\n                    if(Math.abs(iPar.c) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 1]))) {\r\n                        if(Math.abs(iPar.d) <= (100.0 * DBL_EPSILON * Math.abs(K[N - 2])))\r\n                            return dumFlag;\r\n                    }\r\n\r\n                    iPar.h = v * b;\r\n                    if(Math.abs(iPar.d) >= Math.abs(iPar.c)) {\r\n                        // TYPE = 2 indicates that all formulas are divided by d\r\n                        dumFlag = 2;\r\n                        iPar.e = a / (iPar.d);\r\n                        iPar.f = (iPar.c) / (iPar.d);\r\n                        iPar.g = u * b;\r\n                        iPar.a3 = (iPar.e) * ((iPar.g) + a) + (iPar.h) * (b / (iPar.d));\r\n                        iPar.a1 = -a + (iPar.f) * b;\r\n                        iPar.a7 = (iPar.h) + ((iPar.f) + u) * a;\r\n                    }\r\n                    else {\r\n                        // TYPE = 1 indicates that all formulas are divided by c;\r\n                        dumFlag = 1;\r\n                        iPar.e = a / (iPar.c);\r\n                        iPar.f = (iPar.d) / (iPar.c);\r\n                        iPar.g = (iPar.e) * u;\r\n                        iPar.a3 = (iPar.e) * a + ((iPar.g) + (iPar.h) / (iPar.c)) * b;\r\n                        iPar.a1 = -(a * ((iPar.d) / (iPar.c))) + b;\r\n                        iPar.a7 = (iPar.g) * (iPar.d) + (iPar.h) * (iPar.f) + a;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function nextK_ak1(DBL_EPSILON, N, tFlag, a, b, iPar, K, qk, qp) {\r\n                    // Computes the next K polynomials using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in three parameters--a1, a3, and a7\r\n                    var temp;\r\n                    if(tFlag == 3) {\t// Use unscaled form of the recurrence\r\n                        K[1] = K[0] = 0.0;\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = qk[i - 2];\r\n                        }\r\n                        return;\r\n                    }\r\n\r\n                    temp = ((tFlag == 1) ? b : a);\r\n                    if(Math.abs(iPar.a1) > (10.0 * DBL_EPSILON * Math.abs(temp))) {\r\n                        // Use scaled form of the recurrence\r\n                        iPar.a7 /= iPar.a1;\r\n                        iPar.a3 /= iPar.a1;\r\n                        K[0] = qp[0];\r\n                        K[1] = -(qp[0] * iPar.a7) + qp[1];\r\n                        for(var i = 2; i < N; i++)\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3 + qp[i];\r\n                    }\r\n                    else {\r\n                        // If a1 is nearly zero, then use a special form of the recurrence\r\n                        K[0] = 0.0;\r\n                        K[1] = -(qp[0] * iPar.a7);\r\n                        for(var i = 2; i < N; i++) {\r\n                            K[i] = -(qp[i - 1] * iPar.a7) + qk[i - 2] * iPar.a3;\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c, d, f, g, h, u, v, K, N, p) {\r\n                    // Compute new estimates of the quadratic coefficients using the scalars computed in calcSC_ak1\r\n                    // iPar is a dummy variable for passing in the two parameters--uu and vv--by reference\r\n                    // iPar.a = uu, iPar.b = vv\r\n\r\n                    var a4, a5, b1, b2, c1, c2, c3, c4, temp;\r\n                    iPar.b = iPar.a = 0.0;// The quadratic is zeroed\r\n\r\n                    if(tFlag != 3) {\r\n                        if(tFlag != 2) {\r\n                            a4 = a + u * b + h * f;\r\n                            a5 = c + (u + v * f) * d;\r\n                        }\r\n                        else {\r\n                            a4 = (a + g) * f + h;\r\n                            a5 = (f + u) * c + v * d;\r\n                        }\r\n\r\n                        // Evaluate new quadratic coefficients\r\n                        b1 = -(K[N - 1] / p[N]);\r\n                        b2 = -(K[N - 2] + b1 * p[N - 1]) / p[N];\r\n                        c1 = v * b2 * a1;\r\n                        c2 = b1 * a7;\r\n                        c3 = b1 * b1 * a3;\r\n                        c4 = -(c2 + c3) + c1;\r\n                        temp = -c4 + a5 + b1 * a4;\r\n                        if(temp != 0.0) {\r\n                            iPar.a = -((u * (c3 + c2) + v * (b1 * a1 + b2 * a7)) / temp) + u;\r\n                            iPar.b = v * (1.0 + c4 / temp);\r\n                        }\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function Quad_ak1(a, b1, c, iPar) {\r\n                    // Calculates the zeros of the quadratic a*Z^2 + b1*Z + c\r\n                    // The quadratic formula, modified to avoid overflow, is used to find the larger zero if the\r\n                    // zeros are real and both zeros are complex. The smaller real zero is found directly from\r\n                    // the product of the zeros c/a.\r\n\r\n                    // iPar is a dummy variable for passing in the four parameters--sr, si, lr, and li--by reference\r\n\r\n                    var b, d, e;\r\n                    iPar.sr = iPar.si = iPar.lr = iPar.li = 0.0;\r\n\r\n                    if(a == 0) {\r\n                        iPar.sr = ((b1 != 0) ? -(c / b1) : iPar.sr);\r\n                        return;\r\n                    }\r\n                    if(c == 0) {\r\n                        iPar.lr = -(b1 / a);\r\n                        return;\r\n                    }\r\n\r\n                    // Compute discriminant avoiding overflow\r\n                    b = b1 / 2.0;\r\n                    if(Math.abs(b) < Math.abs(c)) {\r\n                        e = ((c >= 0) ? a : -a);\r\n                        e = -e + b * (b / Math.abs(c));\r\n                        d = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c));\r\n                    }\r\n                    else {\r\n                        e = -((a / b) * (c / b)) + 1.0;\r\n                        d = Math.sqrt(Math.abs(e)) * (Math.abs(b));\r\n                    }\r\n\r\n                    if(e >= 0) {\r\n                        // Real zeros\r\n                        d = ((b >= 0) ? -d : d);\r\n                        iPar.lr = (-b + d) / a;\r\n                        iPar.sr = ((iPar.lr != 0) ? (c / (iPar.lr)) / a : iPar.sr);\r\n                    }\r\n                    else {\r\n                        // Complex conjugate zeros\r\n                        iPar.lr = iPar.sr = -(b / a);\r\n                        iPar.si = Math.abs(d / a);\r\n                        iPar.li = -(iPar.si);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function QuadIT_ak1(DBL_EPSILON, N, iPar, uu, vv, qp, NN, sdPar, p, qk, calcPar, K) {\r\n                    // Variable-shift K-polynomial iteration for a quadratic factor converges only if the\r\n                    // zeros are equimodular or nearly so.\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // sdPar is a dummy variable for passing the two parameters--a and b--in by reference\r\n                    // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --in by reference\r\n\r\n                    // qPar is a dummy variable for passing the four parameters--szr, szi, lzr, and lzi--into Quad_ak1 by reference\r\n                    var qPar = new Object(),\r\n                            ee, mp, omp, relstp, t, u, ui, v, vi, zm,\r\n                            i, j = 0, tFlag, triedFlag = 0;   // Integer variables\r\n\r\n                    iPar.NZ = 0;// Number of zeros found\r\n                    u = uu; // uu and vv are coefficients of the starting quadratic\r\n                    v = vv;\r\n\r\n                    do {\r\n                        qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                        Quad_ak1(1.0, u, v, qPar);\r\n                        iPar.szr = qPar.sr;\r\n                        iPar.szi = qPar.si;\r\n                        iPar.lzr = qPar.lr;\r\n                        iPar.lzi = qPar.li;\r\n\r\n                        // Return if roots of the quadratic are real and not close to multiple or nearly\r\n                        // equal and of opposite sign.\r\n                        if(Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))\r\n                            break;\r\n\r\n                        // Evaluate polynomial by quadratic synthetic division\r\n\r\n                        QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n\r\n                        mp = Math.abs(-((iPar.szr) * (sdPar.b)) + (sdPar.a)) + Math.abs((iPar.szi) * (sdPar.b));\r\n\r\n                        // Compute a rigorous bound on the rounding error in evaluating p\r\n\r\n                        zm = Math.sqrt(Math.abs(v));\r\n                        ee = 2.0 * Math.abs(qp[0]);\r\n                        t = -((iPar.szr) * (sdPar.b));\r\n\r\n                        for(i = 1; i < N; i++) {\r\n                            ee = ee * zm + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        ee = ee * zm + Math.abs(t + sdPar.a);\r\n                        ee = (9.0 * ee + 2.0 * Math.abs(t) - 7.0 * (Math.abs((sdPar.a) + t) + zm * Math.abs((sdPar.b)))) * DBL_EPSILON;\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than 20 times this bound\r\n                        if(mp <= 20.0 * ee) {\r\n                            iPar.NZ = 2;\r\n                            break;\r\n                        }\r\n\r\n                        j++;\r\n                        // Stop iteration after 20 steps\r\n                        if(j > 20)\r\n                            break;\r\n                        if(j >= 2) {\r\n                            if((relstp <= 0.01) && (mp >= omp) && (!triedFlag)) {\r\n                                // A cluster appears to be stalling the convergence. Five fixed shift\r\n                                // steps are taken with a u, v close to the cluster.\r\n                                relstp = ((relstp < DBL_EPSILON) ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp));\r\n                                u -= u * relstp;\r\n                                v += v * relstp;\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                for(i = 0; i < 5; i++) {\r\n                                    tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                                    nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                                }\r\n\r\n                                triedFlag = 1;\r\n                                j = 0;\r\n\r\n                            }\r\n                        }\r\n                        omp = mp;\r\n\r\n                        // Calculate next K polynomial and new u and v\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, sdPar.a, sdPar.b, calcPar, K, u, v, qk);\r\n                        newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vi = sdPar.b;\r\n\r\n                        // If vi is zero, the iteration is not converging\r\n                        if(vi != 0) {\r\n                            relstp = Math.abs((-v + vi) / vi);\r\n                            u = ui;\r\n                            v = vi;\r\n                        }\r\n                    }\r\n                    while(vi != 0);\r\n                    return;\r\n                }\r\n\r\n                function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk) {\r\n                    // Variable-shift H-polynomial iteration for a real zero\r\n                    // sss\t- starting iterate = sdPar.a\r\n                    // NZ\t\t- number of zeros found = iPar.NZ\r\n                    // dumFlag\t- flag to indicate a pair of zeros near real axis, returned to iFlag\r\n\r\n                    var ee, kv, mp, ms, omp, pv, s, t,\r\n                            dumFlag, i, j, nm1 = N - 1;   // Integer variables\r\n\r\n                    iPar.NZ = j = dumFlag = 0;\r\n                    s = sdPar.a;\r\n\r\n                    for(; ; ) {\r\n                        pv = p[0];\r\n\r\n                        // Evaluate p at s\r\n                        qp[0] = pv;\r\n                        for(i = 1; i < NN; i++) {\r\n                            qp[i] = pv = pv * s + p[i];\r\n                        }\r\n                        mp = Math.abs(pv);\r\n\r\n                        // Compute a rigorous bound on the error in evaluating p\r\n                        ms = Math.abs(s);\r\n                        ee = 0.5 * Math.abs(qp[0]);\r\n                        for(i = 1; i < NN; i++) {\r\n                            ee = ee * ms + Math.abs(qp[i]);\r\n                        }\r\n\r\n                        // Iteration has converged sufficiently if the polynomial value is less than\r\n                        // 20 times this bound\r\n                        if(mp <= 20.0 * DBL_EPSILON * (2.0 * ee - mp)) {\r\n                            iPar.NZ = 1;\r\n                            iPar.szr = s;\r\n                            iPar.szi = 0.0;\r\n                            break;\r\n                        }\r\n                        j++;\r\n                        // Stop iteration after 10 steps\r\n                        if(j > 10)\r\n                            break;\r\n\r\n                        if(j >= 2) {\r\n                            if((Math.abs(t) <= 0.001 * Math.abs(-t + s)) && (mp > omp)) {\r\n                                // A cluster of zeros near the real axis has been encountered.\r\n                                // Return with iFlag set to initiate a quadratic iteration.\r\n                                dumFlag = 1;\r\n                                iPar.a = s;\r\n                                break;\r\n                            } // End if ((fabs(t) <= 0.001*fabs(s - t)) && (mp > omp))\r\n                        } //End if (j >= 2)\r\n\r\n                        // Return if the polynomial value has increased significantly\r\n                        omp = mp;\r\n\r\n                        // Compute t, the next polynomial and the new iterate\r\n                        qk[0] = kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            qk[i] = kv = kv * s + K[i];\r\n                        }\r\n\r\n                        if(Math.abs(kv) > Math.abs(K[nm1]) * 10.0 * DBL_EPSILON) {\r\n                            // Use the scaled form of the recurrence if the value of K at s is non-zero\r\n                            t = -(pv / kv);\r\n                            K[0] = qp[0];\r\n                            for(i = 1; i < N; i++) {\r\n                                K[i] = t * qk[i - 1] + qp[i];\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Use unscaled form\r\n                            K[0] = 0.0;\r\n                            for(i = 1; i < N; i++)\r\n                                K[i] = qk[i - 1];\r\n                        }\r\n\r\n                        kv = K[0];\r\n                        for(i = 1; i < N; i++) {\r\n                            kv = kv * s + K[i];\r\n                        }\r\n                        t = ((Math.abs(kv) > (Math.abs(K[nm1]) * 10.0 * DBL_EPSILON)) ? -(pv / kv) : 0.0);\r\n                        s += t;\r\n                    }\r\n                    return dumFlag;\r\n                }\r\n\r\n                function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N, p, NN, qp, u, iPar) {\r\n\r\n                    // Computes up to L2 fixed shift K-polynomials, testing for convergence in the linear or\r\n                    // quadratic case. Initiates one of the variable shift iterations and returns with the\r\n                    // number of zeros found.\r\n                    // L2\tlimit of fixed shift steps\r\n                    // iPar is a dummy variable for passing in the five parameters--NZ, lzi, lzr, szi, and szr--by reference\r\n                    // NZ\tnumber of zeros found\r\n                    var sdPar = new Object(), // sdPar is a dummy variable for passing the two parameters--a and b--into QuadSD_ak1 by reference\r\n                            calcPar = new Object(),\r\n                            // calcPar is a dummy variable for passing the nine parameters--a1, a3, a7, c, d, e, f, g, and h --into calcSC_ak1 by reference\r\n\r\n                            qk = new Array(MDP1),\r\n                            svk = new Array(MDP1),\r\n                            a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv,\r\n                            fflag, i, iFlag = 1, j, spass, stry, tFlag, vpass, vtry;     // Integer variables\r\n\r\n                    iPar.NZ = 0;\r\n                    betav = betas = 0.25;\r\n                    oss = sr;\r\n                    ovv = v;\r\n\r\n                    //Evaluate polynomial by synthetic division\r\n                    sdPar.b = sdPar.a = 0.0;\r\n                    QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                    a = sdPar.a;\r\n                    b = sdPar.b;\r\n                    calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0.0;\r\n                    tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                    for(j = 0; j < L2; j++) {\r\n                        fflag = 1;\r\n\r\n                        // Calculate next K polynomial and estimate v\r\n                        nextK_ak1(DBL_EPSILON, N, tFlag, a, b, calcPar, K, qk, qp);\r\n                        tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n\r\n                        // Use sdPar for passing in uu and vv instead of defining a brand-new variable.\r\n                        // sdPar.a = ui, sdPar.b = vi\r\n                        newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N, p);\r\n                        ui = sdPar.a;\r\n                        vv = vi = sdPar.b;\r\n\r\n                        // Estimate s\r\n                        ss = ((K[N - 1] != 0.0) ? -(p[N] / K[N - 1]) : 0.0);\r\n                        ts = tv = 1.0;\r\n\r\n                        if((j != 0) && (tFlag != 3)) {\r\n                            // Compute relative measures of convergence of s and v sequences\r\n                            tv = ((vv != 0.0) ? Math.abs((vv - ovv) / vv) : tv);\r\n                            ts = ((ss != 0.0) ? Math.abs((ss - oss) / ss) : ts);\r\n\r\n                            // If decreasing, multiply the two most recent convergence measures\r\n                            tvv = ((tv < otv) ? tv * otv : 1.0);\r\n                            tss = ((ts < ots) ? ts * ots : 1.0);\r\n\r\n                            // Compare with convergence criteria\r\n                            vpass = ((tvv < betav) ? 1 : 0);\r\n                            spass = ((tss < betas) ? 1 : 0);\r\n\r\n                            if((spass) || (vpass)) {\r\n\r\n                                // At least one sequence has passed the convergence test.\r\n                                // Store variables before iterating\r\n\r\n                                for(i = 0; i < N; i++) {\r\n                                    svk[i] = K[i];\r\n                                }\r\n                                s = ss;\r\n\r\n                                // Choose iteration according to the fastest converging sequence\r\n\r\n                                stry = vtry = 0;\r\n\r\n                                for(; ; ) {\r\n                                    if((fflag && ((fflag = 0) == 0)) && ((spass) && (!vpass || (tss < tvv)))) {\r\n                                        ;// Do nothing. Provides a quick \"short circuit\".\r\n                                    }\r\n                                    else {\r\n                                        QuadIT_ak1(DBL_EPSILON, N, iPar, ui, vi, qp, NN, sdPar, p, qk, calcPar, K);\r\n                                        a = sdPar.a;\r\n                                        b = sdPar.b;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Quadratic iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        iFlag = vtry = 1;\r\n                                        betav *= 0.25;\r\n\r\n                                        // Try linear iteration if it has not been tried and the s sequence is converging\r\n                                        if(stry || (!spass)) {\r\n                                            iFlag = 0;\r\n                                        }\r\n                                        else {\r\n                                            for(i = 0; i < N; i++)\r\n                                                K[i] = svk[i];\r\n                                        }\r\n                                    }\r\n                                    //fflag = 0;\r\n                                    if(iFlag != 0) {\r\n                                        // Use sdPar for passing in s instead of defining a brand-new variable.\r\n                                        // sdPar.a = s\r\n                                        sdPar.a = s;\r\n                                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N, p, NN, qp, K, qk);\r\n                                        s = sdPar.a;\r\n\r\n                                        if((iPar.NZ) > 0)\r\n                                            return;\r\n\r\n                                        // Linear iteration has failed. Flag that it has been tried and decrease the\r\n                                        // convergence criterion\r\n                                        stry = 1;\r\n                                        betas *= 0.25;\r\n\r\n                                        if(iFlag != 0) {\r\n                                            // If linear iteration signals an almost double real zero, attempt quadratic iteration\r\n                                            ui = -(s + s);\r\n                                            vi = s * s;\r\n                                            continue;\r\n\r\n                                        }\r\n                                    }\r\n\r\n                                    // Restore variables\r\n                                    for(i = 0; i < N; i++)\r\n                                        K[i] = svk[i];\r\n\r\n                                    // Try quadratic iteration if it has not been tried and the v sequence is converging\r\n                                    if(!vpass || vtry)\r\n                                        break;\t\t// Break out of infinite for loop\r\n\r\n                                }\r\n\r\n                                // Re-compute qp and scalar values to continue the second stage\r\n\r\n                                QuadSD_ak1(NN, u, v, p, qp, sdPar);\r\n                                a = sdPar.a;\r\n                                b = sdPar.b;\r\n\r\n                                tFlag = calcSC_ak1(DBL_EPSILON, N, a, b, calcPar, K, u, v, qk);\r\n                            }\r\n                        }\r\n                        ovv = vv;\r\n                        oss = ss;\r\n                        otv = tv;\r\n                        ots = ts;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                function rpSolve(degPar, p, zeror, zeroi) {\r\n                    var N = degPar.Degree,\r\n                            RADFAC = 3.14159265358979323846 / 180, // Degrees-to-radians conversion factor = PI/180\r\n                            LB2 = Math.LN2, // Dummy variable to avoid re-calculating this value in loop below\r\n                            MDP1 = degPar.Degree + 1,\r\n                            K = new Array(MDP1),\r\n                            pt = new Array(MDP1),\r\n                            qp = new Array(MDP1),\r\n                            temp = new Array(MDP1),\r\n                            // qPar is a dummy variable for passing the four parameters--sr, si, lr, and li--by reference\r\n                            qPar = new Object(),\r\n                            // Fxshfr_Par is a dummy variable for passing parameters by reference : NZ, lzi, lzr, szi, szr);\r\n                            Fxshfr_Par = new Object(),\r\n                            bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm,\r\n                            aa, bb, cc, sr, t, u, xxx,\r\n                            j, jj, l, NM1, NN, zerok;// Integer variables\r\n\r\n                    // Calculate the machine epsilon and store in the variable DBL_EPSILON.\r\n                    // To calculate this value, just use existing variables rather than create new ones that will be used only for this code block\r\n                    aa = 1.0;\r\n                    do {\r\n                        DBL_EPSILON = aa;\r\n                        aa /= 2;\r\n                        bb = 1.0 + aa;\r\n                    }\r\n                    while(bb > 1.0);\r\n\r\n                    var LO = Number.MIN_VALUE / DBL_EPSILON,\r\n                            cosr = Math.cos(94.0 * RADFAC), // = -0.069756474\r\n                            sinr = Math.sin(94.0 * RADFAC), // = 0.99756405\r\n                            xx = Math.sqrt(0.5), // = 0.70710678\r\n                            yy = -xx;\r\n\r\n                    Fxshfr_Par.NZ = j = 0;\r\n                    Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0.0;\r\n\r\n                    // Remove zeros at the origin, if any\r\n                    while(p[N] == 0) {\r\n                        zeror[j] = zeroi[j] = 0;\r\n                        N--;\r\n                        j++;\r\n                    }\r\n                    NN = N + 1;\r\n\r\n                    // >>>>> Begin Main Loop <<<<<\r\n                    while(N >= 1) { // Main loop\r\n                        // Start the algorithm for one zero\r\n                        if(N <= 2) {\r\n                            // Calculate the final zero or pair of zeros\r\n                            if(N < 2) {\r\n                                zeror[degPar.Degree - 1] = -(p[1] / p[0]);\r\n                                zeroi[degPar.Degree - 1] = 0;\r\n                            }\r\n                            else {\r\n                                qPar.li = qPar.lr = qPar.si = qPar.sr = 0.0;\r\n                                Quad_ak1(p[0], p[1], p[2], qPar);\r\n                                zeror[degPar.Degree - 2] = qPar.sr;\r\n                                zeroi[degPar.Degree - 2] = qPar.si;\r\n                                zeror[degPar.Degree - 1] = qPar.lr;\r\n                                zeroi[degPar.Degree - 1] = qPar.li;\r\n                            }\r\n                            break;\r\n                        }\r\n\r\n                        // Find the largest and smallest moduli of the coefficients\r\n                        moduli_max = 0.0;\r\n                        moduli_min = Number.MAX_VALUE;\r\n\r\n                        for(i = 0; i < NN; i++) {\r\n                            x = Math.abs(p[i]);\r\n                            if(x > moduli_max)\r\n                                moduli_max = x;\r\n                            if((x != 0) && (x < moduli_min))\r\n                                moduli_min = x;\r\n                        }\r\n\r\n                        // Scale if there are large or very small coefficients\r\n                        // Computes a scale factor to multiply the coefficients of the polynomial. The scaling\r\n                        // is done to avoid overflow and to avoid undetected underflow interfering with the\r\n                        // convergence criterion.\r\n                        // The factor is a power of the base.\r\n                        sc = LO / moduli_min;\r\n\r\n                        if(((sc <= 1.0) && (moduli_max >= 10)) || ((sc > 1.0) && (Number.MAX_VALUE / sc >= moduli_max))) {\r\n                            sc = ((sc == 0) ? Number.MIN_VALUE : sc);\r\n                            l = Math.floor(Math.log(sc) / LB2 + 0.5);\r\n                            factor = Math.pow(2.0, l);\r\n                            if(factor != 1.0) {\r\n                                for(i = 0; i < NN; i++)\r\n                                    p[i] *= factor;\r\n                            }\r\n                        }\r\n\r\n                        // Compute lower bound on moduli of zeros\r\n                        for(var i = 0; i < NN; i++)\r\n                            pt[i] = Math.abs(p[i]);\r\n                        pt[N] = -(pt[N]);\r\n                        NM1 = N - 1;\r\n\r\n                        // Compute upper estimate of bound\r\n                        x = Math.exp((Math.log(-pt[N]) - Math.log(pt[0])) / N);\r\n\r\n                        if(pt[NM1] != 0) {\r\n                            // If Newton step at the origin is better, use it\r\n                            xm = -pt[N] / pt[NM1];\r\n                            x = ((xm < x) ? xm : x);\r\n                        }\r\n\r\n                        // Chop the interval (0, x) until ff <= 0\r\n                        xm = x;\r\n                        do {\r\n                            x = xm;\r\n                            xm = 0.1 * x;\r\n                            ff = pt[0];\r\n                            for(var i = 1; i < NN; i++) {\r\n                                ff = ff * xm + pt[i];\r\n                            }\r\n                        }\r\n                        while(ff > 0); // End do-while loop\r\n\r\n                        dx = x;\r\n                        // Do Newton iteration until x converges to two decimal places\r\n\r\n                        do {\r\n                            df = ff = pt[0];\r\n                            for(var i = 1; i < N; i++) {\r\n                                ff = x * ff + pt[i];\r\n                                df = x * df + ff;\r\n                            } // End for i\r\n                            ff = x * ff + pt[N];\r\n                            dx = ff / df;\r\n                            x -= dx;\r\n                        }\r\n                        while(Math.abs(dx / x) > 0.005); // End do-while loop\r\n\r\n                        bnd = x;\r\n\r\n                        // Compute the derivative as the initial K polynomial and do 5 steps with no shift\r\n                        for(var i = 1; i < N; i++)\r\n                            K[i] = (N - i) * p[i] / N;\r\n                        K[0] = p[0];\r\n                        aa = p[N];\r\n                        bb = p[NM1];\r\n                        zerok = ((K[NM1] == 0) ? 1 : 0);\r\n\r\n                        for(jj = 0; jj < 5; jj++) {\r\n                            cc = K[NM1];\r\n                            if(zerok) {\r\n                                // Use unscaled form of recurrence\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = K[j - 1];\r\n                                } // End for i\r\n                                K[0] = 0;\r\n                                zerok = ((K[NM1] == 0) ? 1 : 0);\r\n                            }\r\n                            else {\r\n                                // Used scaled form of recurrence if value of K at 0 is nonzero\r\n                                t = -aa / cc;\r\n                                for(var i = 0; i < NM1; i++) {\r\n                                    j = NM1 - i;\r\n                                    K[j] = t * K[j - 1] + p[j];\r\n                                } // End for i\r\n                                K[0] = p[0];\r\n                                zerok = ((Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10.0) ? 1 : 0);\r\n                            }\r\n                        }\r\n\r\n                        // Save K for restarts with new shifts\r\n                        for(var i = 0; i < N; i++)\r\n                            temp[i] = K[i];\r\n\r\n                        // Loop to select the quadratic corresponding to each new shift\r\n                        for(jj = 1; jj <= 20; jj++) {\r\n\r\n                            // Quadratic corresponds to a double shift to a non-real point and its\r\n                            // complex conjugate. The point has modulus BND and amplitude rotated\r\n                            // by 94 degrees from the previous shift.\r\n\r\n                            xxx = -(sinr * yy) + cosr * xx;\r\n                            yy = sinr * xx + cosr * yy;\r\n                            xx = xxx;\r\n                            sr = bnd * xx;\r\n                            u = -(2.0 * sr);\r\n\r\n                            // Second stage calculation, fixed quadratic\r\n                            Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N, p, NN, qp, u, Fxshfr_Par);\r\n\r\n                            if(Fxshfr_Par.NZ != 0) {\r\n                                // The second stage jumps directly to one of the third stage iterations and\r\n                                // returns here if successful. Deflate the polynomial, store the zero or\r\n                                // zeros, and return to the main algorithm.\r\n                                j = degPar.Degree - N;\r\n                                zeror[j] = Fxshfr_Par.szr;\r\n                                zeroi[j] = Fxshfr_Par.szi;\r\n                                NN = NN - Fxshfr_Par.NZ;\r\n                                N = NN - 1;\r\n                                for(var i = 0; i < NN; i++)\r\n                                    p[i] = qp[i];\r\n                                if(Fxshfr_Par.NZ != 1) {\r\n                                    zeror[j + 1] = Fxshfr_Par.lzr;\r\n                                    zeroi[j + 1] = Fxshfr_Par.lzi;\r\n                                }\r\n                                break;\r\n                            }\r\n                            else {\r\n                                // If the iteration is unsuccessful, another quadratic is chosen after restoring K\r\n                                for(var i = 0; i < N; i++) {\r\n                                    K[i] = temp[i];\r\n                                }\r\n                            }\r\n                        }\r\n                        // Return with failure if no convergence with 20 shifts\r\n                        if(jj > 20) {\r\n                            degPar.Degree -= N;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // >>>>> End Main Loop <<<<<\r\n                    return;\r\n                }\r\n                //--> End Jenkins-Traub\r\n                rpSolve(degreePar, p, zeror, zeroi);\r\n\r\n                var l = zeroi.length;\r\n                //format the output\r\n                for(i = 0; i < l; i++) {\r\n                    // We round the imaginary part to avoid having something crazy like 5.67e-16.\r\n                    var img = round(zeroi[i], decp + 8),\r\n                            real = round(zeror[i], decp + 8);\r\n                    // Did the rounding pay off? If the rounding did nothing more than chop off a few digits then no.\r\n                    // If the rounding results in a a number at least 3 digits shorter we'll keep it else we'll keep \r\n                    // the original otherwise the rounding was worth it.\r\n                    real = decp - String(real).length > 2 ? real : zeror[i];\r\n                    var sign = img < 0 ? '-' : '';\r\n\r\n                    // Remove the zeroes\r\n                    if(real === 0) {\r\n                        real = '';\r\n                    }\r\n                    if(img === 0) {\r\n                        img = '';\r\n                    }\r\n\r\n                    // Remove 1 as the multiplier and discard imaginary part if there isn't one.\r\n                    img = Math.abs(img) === 1 ? sign + 'i' : (img ? img + '*i' : '');\r\n\r\n                    var num = (real && img) ? real + '+' + img : real + img;\r\n                    zeror[i] = num.replace(/\\+\\-/g, '-');\r\n                }\r\n                return zeror;\r\n            }\r\n        },\r\n        roots: function (symbol) {\r\n\r\n            if(symbol.isConstant(true, true)) {\r\n                return core.Utils.nroots(symbol);\r\n            }\r\n            var roots = __.proots(symbol).map(function (x) {\r\n                return _.parse(x);\r\n            });\r\n            return core.Vector.fromArray(roots);\r\n        },\r\n        froot: function (f, guess, dx) {\r\n            var newtonraph = function (xn) {\r\n                var mesh = 1e-12,\r\n                        // If the derivative was already provided then don't recalculate.\r\n                        df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())),\r\n                        // If the function was passed in as a function then don't recalculate.\r\n                        fn = f instanceof Function ? f : core.Utils.build(f),\r\n                        max = 10000,\r\n                        done = false,\r\n                        safety = 0;\r\n                while(!done) {\r\n                    var x = xn - (fn(xn) / df(xn));\r\n                    //absolute values for both x & xn ensures that we indeed have the radius    \r\n                    var r = Math.abs(x) - Math.abs(xn),\r\n                            delta = Math.abs(r);\r\n                    xn = x;\r\n\r\n                    if(delta < mesh)\r\n                        done = true;\r\n                    else if(safety > max) {\r\n                        xn = null;\r\n                        done = true;\r\n                    }\r\n\r\n                    safety++;\r\n                }\r\n                return xn;\r\n            };\r\n            return newtonraph(Number(guess));\r\n        },\r\n        quad: function (a, b, c) {\r\n            var q = function (a, b, c, sign) {\r\n                return _.parse('-(' + b + '+' + sign + '*sqrt((' + b + ')^2-4*(' + a + ')*(' + c + ')))/(2*' + a + ')');\r\n            };\r\n            return [q(a, b, c, 1), q(a, b, c, -1)];\r\n        },\r\n        sumProd: function (a, b) {\r\n            return __.quad(-b, a, -1).map(function (x) {\r\n                return x.invert();\r\n            });\r\n        },\r\n        coeffs: function (symbol, wrt, coeffs) {\r\n            wrt = String(wrt);\r\n            symbol = _.expand(symbol);\r\n            coeffs = coeffs || [new Symbol(0)];\r\n            //we cannot get coeffs for group EX\r\n            if(symbol.group === EX && symbol.contains(wrt, true))\r\n                _.error('Unable to get coefficients using expression ' + symbol.toString());\r\n            var vars = variables(symbol);\r\n            if(vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {\r\n                var a = new Polynomial(symbol).coeffs.map(function (x) {\r\n                    return new Symbol(x);\r\n                });\r\n\r\n                for(var i = 0, l = a.length; i < l; i++) {\r\n                    var coeff = a[i],\r\n                            e = coeffs[i];\r\n                    if(e)\r\n                        coeff = _.add(e, coeff);\r\n                    coeffs[i] = coeff; //transfer it all over\r\n                }\r\n            }\r\n            else {\r\n                if(!wrt)\r\n                    _.error('Polynomial contains more than one variable. Please specify which variable is to be used!');\r\n                //if the variable isn't part of this polynomial then we're looking at x^0\r\n\r\n                if(vars.indexOf(wrt) === -1) {\r\n                    coeffs[0] = _.add(symbol, coeffs[0]);\r\n                }\r\n                else {\r\n                    coeffs = coeffs || [new Symbol(0)];\r\n                    if(symbol.group === CB) {\r\n                        var s = symbol.symbols[wrt];\r\n                        if(!s)\r\n                            _.error('Expression is not a polynomial!');\r\n                        var p = Number(s.power);\r\n                        coeff = _.divide(symbol.clone(), s.clone());\r\n                        if(coeff.contains(wrt, true) || p < 0 || !isInt(p))\r\n                            _.error('Expression is not a polynomial!');\r\n                        var e = coeffs[p];\r\n                        if(e)\r\n                            coeff = _.add(e, coeff);\r\n                        coeffs[p] = coeff;\r\n                    }\r\n                    else if(symbol.group === CP) {\r\n                        symbol.each(function (x) {\r\n                            __.coeffs(x.clone(), wrt, coeffs);\r\n                        }, true);\r\n                    }\r\n                }\r\n            }\r\n            //fill holes\r\n            for(var i = 0, l = coeffs.length; i < l; i++)\r\n                if(typeof coeffs[i] === 'undefined')\r\n                    coeffs[i] = new Symbol(0);\r\n\r\n            return coeffs;\r\n        },\r\n        /**\r\n         * Get's all the powers of a particular polynomial including the denominators. The denominators powers\r\n         * are returned as negative. All remaining polynomials are returned as zero order polynomials.\r\n         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]\r\n         * @param {Symbol} e\r\n         * @param {String} for_variable\r\n         * @param {Array} powers\r\n         * @returns {Array} An array of the powers\r\n         */\r\n        //assumes you've already verified that it's a polynomial\r\n        polyPowers: function (e, for_variable, powers) {\r\n            powers = powers || [];\r\n            var g = g = e.group;\r\n            if(g === PL && for_variable === e.value) {\r\n                powers = powers.concat(keys(e.symbols));\r\n            }\r\n            else if(g === CP) {\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s];\r\n                    var g = symbol.group, v = symbol.value;\r\n                    if(g === S && for_variable === v)\r\n                        powers.push(symbol.power);\r\n                    else if(g === PL || g === CP)\r\n                        powers = __.polyPowers(symbol, for_variable, powers);\r\n                    else if(g === CB && symbol.contains(for_variable)) {\r\n                        var t = symbol.symbols[for_variable];\r\n                        if(t)\r\n                            powers.push((t.power));\r\n                    }\r\n                    else if(g === N || for_variable !== v)\r\n                        powers.push(0);\r\n                }\r\n            }\r\n            else if(g === CB && e.contains(for_variable)) {\r\n                powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);\r\n            }\r\n            return core.Utils.arrayUnique(powers).sort();\r\n        },\r\n        //The factor object\r\n        Factor: {\r\n            //splits the symbol in symbol and constant\r\n            split: function (symbol) {\r\n                var c = new Symbol(1); //the constants part\r\n                var s = new Symbol(1); //the symbolic part\r\n                __.Factor.factor(symbol, new Factors()).each(function (x) {\r\n                    var t = _.parse(x);\r\n                    if(x.isConstant(true)) {\r\n                        c = _.multiply(c, t);\r\n                    }\r\n                    else {\r\n                        s = _.multiply(s, t);\r\n                    }\r\n                });\r\n                return [c, s];\r\n            },\r\n            mix: function (o, include_negatives) {\r\n                var factors = keys(o);\r\n                var l = factors.length;\r\n                var m = [];//create a row which we'r going to be mixing\r\n                for(var i = 0; i < l; i++) {\r\n                    var factor = factors[i],\r\n                            p = o[factor];\r\n                    var ll = m.length;\r\n                    for(var j = 0; j < ll; j++) {\r\n                        var t = m[j] * factor;\r\n                        m.push(t);\r\n                        if(include_negatives)\r\n                            m.push(-t);\r\n                    }\r\n\r\n                    for(var j = 1; j <= p; j++)\r\n                        m.push(Math.pow(factor, j));\r\n                }\r\n                return m;\r\n            },\r\n            //TODO: this method is to replace common factoring\r\n            common: function (symbol, factors) {\r\n                try {\r\n                    if(symbol.group === CP) {\r\n                        //this may have the unfortunate side effect of expanding and factoring again\r\n                        //to only end up with the same result. \r\n                        //TODO: try to avoid this\r\n                        //collect the symbols and sort to have the longest first. Thinking is that the longest terms \r\n                        //has to contain the variable in order for it to be factorable\r\n                        var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function (a, b) {\r\n                            return (b.length || 1) - (a.length || 1);\r\n                        });\r\n\r\n                        var map = {}; //create a map of common factors\r\n                        var coeffs = [];\r\n                        for(var i = 0; i < symbols.length; i++) {\r\n                            var sym = symbols[i];\r\n                            coeffs.push(sym.multiplier.clone());\r\n                            sym.each(function (x) {\r\n                                var p = Number(x.power);\r\n                                //This check exits since we have a symbolic power.\r\n                                //For the future... think about removing this check and modify for symbolic powers\r\n                                if(isNaN(p))\r\n                                    throw new Error('exiting');\r\n                                //loop through the symbols and lump together common terms\r\n                                if(x.value in map) {\r\n                                    if(p < map[x.value][0])\r\n                                        map[x.value][0] = p;\r\n                                    map[x.value][1].push(x);\r\n                                }\r\n                                else\r\n                                    map[x.value] = [p, [x]];\r\n                            });\r\n                        }\r\n                        //the factor\r\n                        var factor = new Symbol(1);\r\n                        for(var x in map) {\r\n                            //if this factor is found in all terms since the length of \r\n                            //matching variable terms matches the number of original terms\r\n                            if(map[x][1].length === symbols.length) {\r\n                                //generate a symbol and multiply into the factor\r\n                                factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));\r\n                            }\r\n                        }\r\n                        //get coefficient factor\r\n                        var c = core.Math2.QGCD.apply(null, coeffs);\r\n\r\n                        if(!c.equals(1)) {\r\n                            factors.add(new Symbol(c));\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbols[i].multiplier = symbols[i].multiplier.divide(c);\r\n                            }\r\n                        }\r\n\r\n                        //if we actuall found any factors\r\n                        if(!factor.equals(1)) {\r\n                            factors.add(factor);\r\n                            symbol = new Symbol(0);\r\n                            for(var i = 0; i < symbols.length; i++) {\r\n                                symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            zeroes: function (symbol, factors) {\r\n                var exit = function () {\r\n                    throw new core.exceptions.ValueLimitExceededError('Exiting');\r\n                };\r\n                try {\r\n                    var vars, term, sum, p, e;\r\n                    symbol = _.expand(symbol.clone());\r\n                    e = symbol.toString();\r\n                    vars = variables(symbol);\r\n\r\n                    sum = new Symbol(0);\r\n\r\n                    var terms = [];\r\n                    var powers = [];\r\n\r\n                    //start setting each variable to zero\r\n                    for(var i = 0, l = vars.length; i < vars.length; i++) {\r\n                        var subs = {};\r\n                        //we want to create a subs object with all but the current variable set to zero\r\n                        for(var j = 0; j < l; j++)\r\n                            if(i !== j) //make sure we're not looking at the same variable\r\n                                subs[vars[j]] = 0;\r\n                        term = _.parse(e, subs);\r\n                        var tp = term.power;\r\n                        //the temporary power has to be an integer as well\r\n                        if(!isInt(tp))\r\n                            exit();\r\n                        terms.push(term);\r\n                        powers.push(term.power);\r\n                    }\r\n\r\n                    //get the gcd. This will be the p in (a^n+b^m)^p\r\n                    //if the gcd equals 1 meaning n = m then we need a tie breakder\r\n                    if(core.Utils.allSame(powers)) {\r\n                        //get p given x number of terms\r\n                        var n_terms = symbol.length;\r\n                        //the number of zeroes determines\r\n                        var n_zeroes = terms.length;\r\n                        if(n_zeroes === 2) {\r\n                            p = new Frac(powers[0] / (n_terms - 1));\r\n                        }\r\n                        if(n_zeroes === 3) {\r\n                            p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));\r\n                        }\r\n                        /*\r\n                         //get the lowest possible power\r\n                         //e.g. given b^4+2*a^2*b^2+a^4, the power we're looking for would be 2\r\n                         symbol.each(function(x) {\r\n                         if(x.group === CB)\r\n                         x.each(function(y) {\r\n                         if(!p || y.power.lessThan(p))\r\n                         //p = Number(y.power);\r\n                         p = y.power;\r\n                         });\r\n                         else if(!p || x.power.lessThan(p))\r\n                         //p = Number(x.power);\r\n                         p = x.power;\r\n                         });\r\n                         */\r\n                    }\r\n                    else\r\n                        //p is just the gcd of the powers\r\n                        p = core.Math2.QGCD.apply(null, powers);\r\n\r\n                    //if we don't have an integer then exit\r\n                    if(!isInt(p))\r\n                        exit();\r\n\r\n                    //build the factor\r\n                    for(var i = 0; i < terms.length; i++) {\r\n                        var t = terms[i];\r\n                        var n = t.power.clone().divide(p);\r\n                        t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));\r\n                        t.power = p.clone();\r\n                        sum = _.add(sum, t);\r\n                    }\r\n\r\n                    //by now we have the factor of zeroes. We'll know if we got it right because \r\n                    //we'll get a remainder of zero each time we divide by it\r\n                    if(sum.group !== CP)\r\n                        return symbol; //nothing to do\r\n\r\n                    while(true) {\r\n                        var d = __.div(symbol.clone(), sum.clone());\r\n                        if(d[1].equals(0)) {\r\n                            symbol = d[0];\r\n                            factors.add(sum.clone());\r\n                            if(symbol.equals(1)) //we've reached 1 so done.\r\n                                break;\r\n                        }\r\n                        else\r\n                            break;\r\n                    }\r\n                }\r\n                catch(e) {\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            },\r\n            factor: function (symbol, factors) {\r\n                // Don't try to factor constants\r\n                if(symbol.isConstant()) {\r\n                    return core.Math2.factor(symbol);\r\n                }\r\n\r\n                var _symbol = _.parse(symbol);\r\n                var retval = __.Factor._factor(_symbol, factors);\r\n                if(retval.equals(symbol)) {\r\n                    return retval;\r\n                }\r\n\r\n                if(retval.group === CB) {\r\n                    var t = new Symbol(1);\r\n                    var p = _.parse(retval.power);\r\n                    //store the multiplier and strip it\r\n                    var m = _.parse(retval.multiplier);\r\n\r\n                    retval.toUnitMultiplier();\r\n\r\n                    /* \r\n                     * NOTE: for sign issues with factor START DEBUGGING HERE\r\n                     */\r\n                    //move the sign to t\r\n                    if(retval.multiplier.lessThan(0)) {\r\n                        t.negate();\r\n                        retval.negate();\r\n                    }\r\n\r\n                    retval.each(function (x) {\r\n                        // Related to #566. Since the symbol's group may not have been properly\r\n                        // updated, it's easier to just parse the symbol and have the parser \r\n                        // do the update for us.\r\n                        var factored = _.parse(__.Factor._factor(x));\r\n\r\n                        if(factored.group === CB) {\r\n                            // Include the multiplier\r\n                            m = _.multiply(m, Symbol.create(factored.multiplier));\r\n                            factored.each(function (y) {\r\n                                var _factored = _.parse(__.Factor._factor(y));\r\n                                t = _.multiply(t, _factored);\r\n                                if(_factored.group === CB) {\r\n                                    m = _.multiply(m, Symbol.create(_factored.multiplier));\r\n                                }\r\n                            });\r\n                        }\r\n                        else {\r\n                            t = _.multiply(t, factored);\r\n                        }\r\n                    });\r\n\r\n                    //put back the multiplier and power\r\n                    retval = _.pow(_.multiply(m, t), p);\r\n                }\r\n\r\n                return retval;\r\n            },\r\n            quadFactor: function (symbol, factors) {\r\n                if(symbol.isPoly() && __.degree(symbol.equals(2))) {\r\n                    //We've  already checked that we're dealing with a polynomial\r\n                    var v = core.Utils.variables(symbol)[0]; //get the variable\r\n                    var coeffs = __.coeffs(symbol, v);\r\n                    //factor the lead coefficient\r\n                    var cf = __.Factor._factor(coeffs[2].clone());\r\n                    //check if we have factors\r\n                    if(cf.group === CB) {\r\n                        var symbols = cf.collectSymbols();\r\n                        //if the factors are greater than 2 we're done so exit\r\n                        if(symbols.length > 2)\r\n                            return symbol;\r\n                        //if we have two factors then attempt to factor the polynomial\r\n                        //let the factors be f1 and f1\r\n                        //let the factors be (ax+b)(cx+d)\r\n                        //let the coefficients be c1x^2+c2x+c3\r\n                        //then a(x1)+c(x2)=c2 and x1*x2=c3\r\n                        //we can solve for x1 and x2\r\n                        var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));\r\n                        var b = _.parse(coeffs[1]).negate();\r\n                        var a = _.parse(symbols[1]);\r\n                        //solve the system\r\n                        var root = __.quad(a, b, c).filter(function (x) {\r\n                            if(core.Utils.isInt(x))\r\n                                return x;\r\n                        });\r\n                        //if we have one root then find the other one by dividing the constant\r\n                        if(root.length === 1) {\r\n                            var root1 = root[0];\r\n                            var root2 = _.divide(coeffs[0], _.parse(root1));\r\n                            if(core.Utils.isInt(root2)) {\r\n                                //we found them both\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[1], v, root2)));\r\n                                factors.add(_.parse(format('({0})*({1})+({2})', symbols[0], v, root1)));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            cubeFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var symbols = symbol.collectSymbols();\r\n                    // The symbol should be in the form of a^3+-b^3. The length\r\n                    // should therefore only be two. If it's any different from this\r\n                    // then we're done\r\n                    if(symbols.length === 2) {\r\n                        // Store the signs and then strip them from the symbols\r\n                        var sign_a = symbols[0].sign();\r\n                        var a = symbols[0].clone().abs();\r\n                        var sign_b = symbols[1].sign();\r\n                        var b = symbols[1].clone().abs();\r\n                        // Check if they're cube\r\n                        if(a.isCube() && b.isCube()) {\r\n                            // Keep the negative sign on the right, meaning b is always negative.\r\n                            if(sign_a < sign_b) {\r\n                                // Swap the signs and then the values\r\n                                [sign_a, sign_b] = [sign_b, sign_a];\r\n                                [a, b] = [b, a];\r\n                            }\r\n\r\n                            // Get teh roots\r\n                            var m_root_a = _.parse(a.getNth(3));\r\n                            var m_root_b = _.parse(b.getNth(3));\r\n\r\n                            // Remove the cube for both\r\n                            var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_a);\r\n                            var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse('1/3'))), m_root_b);\r\n\r\n                            if(sign_a === 1 && sign_b === -1) {\r\n                                // Apply difference of cubes rule\r\n                                factors.add(_.parse(format('(({0})-({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2+({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                            else if(sign_a === 1 && sign_b === 1) {\r\n                                // Apply sum of cubes rule\r\n                                factors.add(_.parse(format('(({0})+({1}))', x, y)));\r\n                                factors.add(_.parse(format('(({0})^2-({0})*({1})+({1})^2)', x, y)));\r\n                                symbol = Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            _factor: function (symbol, factors) {\r\n                var g = symbol.group;\r\n                //some items cannot be factored any further so return those right away\r\n                if(symbol.group === FN) {\r\n                    var arg = symbol.args[0];\r\n                    if(arg.group === S && arg.isSimple()) {\r\n                        return symbol;\r\n                    }\r\n                }\r\n                else if(symbol.group === S && symbol.isSimple()) {\r\n                    return symbol;\r\n                }\r\n\r\n                // Expand the symbol to get it in a predictable form. If this step\r\n                // is skipped some factors are missed.\r\n                //if(symbol.group === CP && !(even(symbol.power) && symbol.multiplier.lessThan(0))) {\r\n                if(symbol.group === CP) {\r\n                    symbol.distributeMultiplier(true);\r\n                    var t = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        if((x.group === CP && x.power.greaterThan(1) || x.group === CB))\r\n                            x = _.expand(x);\r\n                        t = _.add(t, x);\r\n                    });\r\n                    t.power = symbol.power;\r\n\r\n                    symbol = t;\r\n                }\r\n\r\n                if(symbol.group === FN && symbol.fname !== 'sqrt') {\r\n                    symbol = core.Utils.evaluate(symbol);\r\n                }\r\n\r\n                //make a copy of the symbol to return if something goes wrong\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    if(symbol.group === CB) {\r\n                        var p = _.parse(symbol.power);\r\n\r\n                        var den_array, num_array, den, num, dfact, nfact;\r\n                        //grab the denominator and strip the multiplier and power. Store them in an array\r\n                        den_array = __.Simplify.strip(symbol.getDenom());\r\n                        num_array = __.Simplify.strip(symbol.getNum());\r\n\r\n                        den = den_array.pop();\r\n                        num = num_array.pop();\r\n\r\n                        //if the numerator equals the symbol then we've hit the simplest form and then we're done\r\n                        if(num.equals(symbol)) {\r\n                            return symbol;\r\n                        }\r\n                        nfact = __.Factor.factor(num);\r\n                        dfact = __.Factor.factor(den);\r\n\r\n                        var n = __.Simplify.unstrip(num_array, nfact);\r\n                        var d = __.Simplify.unstrip(den_array, dfact);\r\n\r\n                        var retval = _.divide(n, d);\r\n\r\n                        return retval;\r\n                    }\r\n                    if(symbol.group === S) {\r\n                        return symbol; //absolutely nothing to do\r\n                    }\r\n\r\n                    if(symbol.isConstant()) {\r\n                        if(symbol.equals(1))\r\n                            return symbol.clone();\r\n                        var ret = core.Math2.factor(symbol);\r\n                        return ret;\r\n                    }\r\n\r\n                    var p = symbol.power.clone();\r\n\r\n                    if(isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {\r\n                        var sign = p.sign();\r\n                        symbol.toLinear();\r\n                        factors = factors || new Factors();\r\n                        var map = {};\r\n                        symbol = _.parse(core.Utils.subFunctions(symbol, map));\r\n                        if(keys(map).length > 0) { //it might have functions\r\n                            factors.preAdd = function (factor) {\r\n                                var ret = _.parse(factor, core.Utils.getFunctionsSubs(map));\r\n                                return ret;\r\n                            };\r\n                        }\r\n\r\n                        //strip the power\r\n                        if(!symbol.isLinear()) {\r\n                            factors.pFactor = symbol.power.toString();\r\n                            symbol.toLinear();\r\n                        }\r\n\r\n                        var vars = variables(symbol);\r\n                        //bypass for imaginary. TODO: find a better solution\r\n                        if(symbol.isImaginary()) {\r\n                            vars.push(core.Settings.IMAGINARY);\r\n                        }\r\n                        var multiVar = vars.length > 1;\r\n\r\n                        //minor optimization. Seems to cut factor time by half in some cases.\r\n                        if(multiVar) {\r\n                            var all_S = true, all_unit = true;\r\n                            symbol.each(function (x) {\r\n                                if(x.group !== S)\r\n                                    all_S = false;\r\n                                if(!x.multiplier.equals(1))\r\n                                    all_unit = false;\r\n                            });\r\n\r\n                            if(all_S && all_unit) {\r\n                                return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));\r\n                            }\r\n                        }\r\n\r\n                        //factor the coefficients\r\n                        var coeff_factors = new Factors();\r\n\r\n                        symbol = __.Factor.coeffFactor(symbol, coeff_factors);\r\n\r\n                        coeff_factors.each(function (x) {\r\n                            // If the factor was negative but was within a square then it becomes positive\r\n                            if(even(p) && x.lessThan(0)) {\r\n                                x.negate();\r\n                            }\r\n\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        //factor the power\r\n                        var power_factors = new Factors();\r\n                        symbol = __.Factor.powerFactor(symbol, power_factors);\r\n                        power_factors.each(function (x) {\r\n                            if(sign < 0)\r\n                                x.invert();\r\n                            factors.add(x);\r\n                        });\r\n\r\n                        if(!multiVar) {\r\n                            //pass in vars[0] for safety\r\n                            var v = vars[0];\r\n\r\n                            symbol = __.Factor.squareFree(symbol, factors, v);\r\n\r\n                            var t_factors = new Factors();\r\n\r\n                            symbol = __.Factor.trialAndError(symbol, t_factors, v);\r\n\r\n                            //generate a symbol based off the last factors\r\n                            var tf_symbol = t_factors.toSymbol();\r\n                            //if nothing was factored then return the factors\r\n                            if(tf_symbol.equals(untouched)) {\r\n                                return tf_symbol;\r\n                            }\r\n\r\n                            for(var x in t_factors.factors) {\r\n                                //store the current factor in t_factor\r\n                                var t_factor = t_factors.factors[x];\r\n                                factors.add(_.pow(t_factor, _.parse(p)));\r\n                            }\r\n                            //if we still don't have a factor and it's quadratic then let's just do a quad factor\r\n                            if(symbol.equals(untouched)) {\r\n                                symbol = __.Factor.quadFactor(symbol, factors);\r\n                            }\r\n\r\n                        }\r\n                        else {\r\n                            // Try sum and difference of cubes\r\n                            symbol = __.Factor.cubeFactor(symbol, factors);\r\n\r\n                            symbol = __.Factor.mfactor(symbol, factors);\r\n\r\n                            //put back the sign of power\r\n                            factors.each(function (x) {\r\n                                if(sign < 0)\r\n                                    x.power.negate();\r\n                            });\r\n                        }\r\n\r\n                        //last minute clean up\r\n                        symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));\r\n                        \r\n                        var addPower = factors.length === 1;\r\n                        \r\n                        factors.add(_.pow(symbol, _.parse(p)));\r\n\r\n                        var retval = factors.toSymbol();\r\n                        \r\n                        // We may have only factored out the symbol itself so we end up with a factor of one \r\n                        // where the power needs to be placed back\r\n                        // e.g. factor((2*y+p)^2). Here we end up having a factor of 1 remaining and a p of 2.\r\n                        if(addPower && symbol.equals(1) && retval.isLinear()) {\r\n                            retval = _.pow(retval, _.parse(p));\r\n                        }\r\n                        \r\n                        return retval;\r\n                    }\r\n\r\n                    return symbol;\r\n                }\r\n                catch(e) {\r\n                    //no need to stop the show because something went wrong :). Just return the unfactored.\r\n                    return untouched;\r\n                }\r\n            },\r\n            reduce: function (symbol, factors) {\r\n                if(symbol.group === CP && symbol.length === 2) {\r\n                    var symbols = symbol.collectSymbols().sort(function (a, b) {\r\n                        return b.multiplier - a.multiplier;\r\n                    });\r\n                    if(symbols[0].power.equals(symbols[1].power)) {\r\n                        //x^n-a^n\r\n                        var n = _.parse(symbols[0].power),\r\n                                a = symbols[0].clone().toLinear(),\r\n                                b = symbols[1].clone().toLinear();\r\n\r\n                        //apply rule: (a-b)*sum(a^(n-i)*b^(i-1),1,n)\r\n                        factors.add(_.add(a.clone(), b.clone()));\r\n                        //flip the sign\r\n                        b.negate();\r\n                        //turn n into a number\r\n                        var nn = Number(n);\r\n                        //the remainder\r\n                        var result = new Symbol(0);\r\n                        for(var i = 1; i <= nn; i++) {\r\n                            var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))),\r\n                                    bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));\r\n                            result = _.add(result, _.multiply(aa, bb));\r\n                        }\r\n                        return result;\r\n                    }\r\n                }\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Makes Symbol square free\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @@param {String} variable The variable which is being factored \r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            squareFree: function (symbol, factors, variable) {\r\n                if(symbol.isConstant() || symbol.group === S)\r\n                    return symbol;\r\n\r\n                var poly = new Polynomial(symbol, variable);\r\n                var sqfr = poly.squareFree();\r\n                var p = sqfr[2];\r\n                //if we found a square then the p entry in the array will be non-unit\r\n                if(p !== 1) {\r\n                    //make sure the remainder doesn't have factors\r\n                    var t = sqfr[1].toSymbol();\r\n                    t.power = t.power.multiply(new Frac(p));\r\n                    //send the factor to be fatored to be sure it's completely factored\r\n                    factors.add(__.Factor.factor(t));\r\n\r\n                    var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);\r\n\r\n                    return retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * Factors the powers such that the lowest power is a constant\r\n             * @param {Symbol} symbol\r\n             * @param {Factors} factors\r\n             * @returns {[Symbol, Factor]}\r\n             */\r\n            powerFactor: function (symbol, factors) {\r\n                //only PL need apply\r\n                if(symbol.group !== PL || symbol.previousGroup === EX)\r\n                    return symbol;\r\n                var k = keys(symbol.symbols);\r\n                //we expect only numeric powers so return all else\r\n                if(!core.Utils.allNumeric(k))\r\n                    return symbol;\r\n\r\n                var d = core.Utils.arrayMin(k);\r\n                var retval = new Symbol(0);\r\n                var q = _.parse(symbol.value + '^' + d);\r\n                symbol.each(function (x) {\r\n                    x = _.divide(x, q.clone());\r\n                    retval = _.add(retval, x);\r\n                });\r\n\r\n                factors.add(q);\r\n                return retval;\r\n            },\r\n            /**\r\n             * Removes GCD from coefficients\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @returns {Symbol}\r\n             */\r\n            coeffFactor: function (symbol, factors) {\r\n                if(symbol.isComposite()) {\r\n                    var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());\r\n\r\n                    if(!gcd.equals(1)) {\r\n                        symbol.each(function (x) {\r\n                            if(x.isComposite()) {\r\n                                x.each(function (y) {\r\n                                    y.multiplier = y.multiplier.divide(gcd);\r\n                                });\r\n                            }\r\n                            else\r\n                                x.multiplier = x.multiplier.divide(gcd);\r\n                        });\r\n                        symbol.updateHash();\r\n                    }\r\n                    else {\r\n                        // TODO: This should probably go to the prototype\r\n                        var power = function (symbol) {\r\n                            var p;\r\n                            if(symbol.group === CB) {\r\n                                p = 0;\r\n                                symbol.each(function (x) {\r\n                                    p += x.power;\r\n                                });\r\n                            }\r\n                            else {\r\n                                p = Number(symbol.power);\r\n                            }\r\n                            return p;\r\n                        };\r\n                        // Factor out negatives from the lead term\r\n                        var terms = symbol.collectSymbols(null, null, null, true).sort(function (a, b) {\r\n                            // Push constants to the back\r\n                            if(a.isConstant(true))\r\n                                return 1;\r\n                            return b.power - a.power;\r\n                        });\r\n\r\n                        var LT = terms[0];\r\n\r\n                        // Check if the LT is indeed the greatest\r\n                        if(power(LT) > power(terms[1]) || terms[1].isConstant(true)) {\r\n                            if(LT.multiplier.lessThan(0)) {\r\n                                // Although the symbol should always be linear at this point, remove the negative for squares\r\n                                // to be safe.\r\n                                factors.add(new Symbol(-1));\r\n\r\n                                symbol.each(function (x) {\r\n                                    x.negate();\r\n                                }, true);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n\r\n                    if(factors) {\r\n                        factors.add(new Symbol(gcd));\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            /**\r\n             * The name says it all :)\r\n             * @param {Symbol} symbol\r\n             * @param {Factor} factors\r\n             * @@param {String} variable \r\n             * @returns {Symbol}\r\n             */\r\n            trialAndError: function (symbol, factors, variable) {\r\n                var untouched = symbol.clone();\r\n                try {\r\n                    // At temp holder for the factors. If all goes well then\r\n                    // they'll be moved to the actual factors.\r\n                    var factor_array = [];\r\n\r\n                    if(symbol.isConstant() || symbol.group === S)\r\n                        return symbol;\r\n                    var poly = new Polynomial(symbol, variable),\r\n                            cnst = poly.coeffs[0],\r\n                            cfactors = core.Math2.ifactor(cnst),\r\n                            roots = __.proots(symbol);\r\n                    for(var i = 0; i < roots.length; i++) {\r\n                        var r = roots[i],\r\n                                p = 1;\r\n                        if(!isNaN(r)) { //if it's a number\r\n                            for(var x in cfactors) {\r\n                                //check it's raised to a power\r\n                                var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);\r\n                                if(isInt(n)) {\r\n                                    r = x; //x must be the root since n gave us a whole\r\n                                    p = n;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            var root = new Frac(r),\r\n                                    terms = [new Frac(root.num).negate()];\r\n                            terms[p] = new Frac(root.den);\r\n                            //convert to Frac. The den is coeff of LT and the num is coeff of constant\r\n                            var div = Polynomial.fromArray(terms, poly.variable).fill(),\r\n                                    t = poly.divide(div);\r\n                            if(t[1].equalsNumber(0)) { //if it's zero we have a root and divide it out\r\n                                poly = t[0];\r\n                                // factors.add(div.toSymbol());\r\n                                factor_array.push(div.toSymbol());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(!poly.equalsNumber(1)) {\r\n                        poly = __.Factor.search(poly, factors);\r\n                    }\r\n\r\n                    // Move the factors over since all went well.\r\n                    factor_array.forEach(function (x) {\r\n                        factors.add(x);\r\n                    });\r\n\r\n                    return poly.toSymbol();\r\n                }\r\n                catch(e) {\r\n                    return untouched;\r\n                }\r\n            },\r\n            search: function (poly, factors, base) {\r\n                base = base || 10; //I like 10 because numbers exhibit similar behaviours at 10\r\n                var v = poly.variable; //the polynmial variable name\r\n                /**\r\n                 * Attempt to remove a root by division given a number by first creating\r\n                 * a polynomial fromt he given information\r\n                 * @param {int} c1 - coeffient for the constant\r\n                 * @param {int} c2 - coefficient for the LT\r\n                 * @param {int} n - the number to be used to construct the polynomial\r\n                 * @param {int} p - the power at which to create the polynomial\r\n                 * @returns {null|Polynomial} - returns polynomial if successful otherwise null\r\n                 */\r\n                var check = function (c1, c2, n, p) {\r\n                    var candidate = Polynomial.fit(c1, c2, n, base, p, v);\r\n                    if(candidate && candidate.coeffs.length > 1) {\r\n                        var t = poly.divide(candidate);\r\n                        if(t[1].equalsNumber(0)) {\r\n                            factors.add(candidate.toSymbol());\r\n                            return [t[0], candidate];\r\n                        }\r\n                    }\r\n                    return null;\r\n                };\r\n                var cnst = poly.coeffs[0];\r\n                var cfactors = core.Math2.ifactor(cnst);\r\n                var lc = poly.lc();\r\n                var ltfactors = core.Math2.ifactor(lc);\r\n                var subbed = poly.sub(base);\r\n                var isubbed = core.Math2.ifactor(subbed);\r\n                var nfactors = __.Factor.mix(isubbed, subbed < 0);\r\n                var cp = Math.ceil(poly.coeffs.length / 2);\r\n                var lc_is_neg = lc.lessThan(0);\r\n                var cnst_is_neg = cnst.lessThan(0);\r\n                ltfactors['1'] = 1;\r\n                cfactors['1'] = 1;\r\n                while(cp--) {\r\n                    for(var x in ltfactors) {\r\n                        for(var y in cfactors) {\r\n                            for(var i = 0; i < nfactors.length; i++) {\r\n                                var factor_found = check(x, y, nfactors[i], cp);\r\n                                if(factor_found) {\r\n                                    poly = factor_found[0];\r\n                                    if(!core.Utils.isPrime(poly.sub(base)))\r\n                                        poly = __.Factor.search(poly, factors);\r\n                                    return poly;\r\n                                }\r\n                                else if(!factor_found) {\r\n                                    if(lc_is_neg && cnst_is_neg)\r\n                                        factor_found = check(-x, -y, nfactors[i], cp);\r\n                                    else if(lc_is_neg)\r\n                                        factor_found = check(-x, y, nfactors[i], cp); //check a negative lc\r\n                                    else if(cnst_is_neg)\r\n                                        factor_found = check(x, -y, nfactors[i], cp); //check a negative constant\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return poly;\r\n            },\r\n            /**\r\n             * Equivalent of square free factor for multivariate polynomials\r\n             * @param {type} symbol\r\n             * @param {type} factors\r\n             * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}\r\n             */\r\n            mSqfrFactor: function (symbol, factors) {\r\n                if(symbol.group !== FN) {\r\n                    var vars = variables(symbol).reverse();\r\n\r\n                    // Loop through all the variable and remove the partial derivatives\r\n                    for(var i = 0; i < vars.length; i++) {\r\n                        do {\r\n                            if(vars[i] === symbol.value) {\r\n                                //the derivative tells us nothing since this symbol is already the factor\r\n                                factors.add(symbol);\r\n                                symbol = new Symbol(1);\r\n                                continue;\r\n                            }\r\n\r\n                            var diff = core.Calculus.diff(symbol, vars[i]);\r\n\r\n                            var d = __.Factor.coeffFactor(diff);\r\n\r\n                            if(d.equals(0))\r\n                                break;\r\n\r\n                            //trial division to see if factors have whole numbers. \r\n                            //This can be optimized by stopping as soon as can_divide is false\r\n                            //this will also need utilize big number at some point\r\n                            var can_divide = true;\r\n                            if(d.isConstant() && symbol.isComposite()) {\r\n                                //check the coefficients\r\n\r\n                                symbol.each(function (x) {\r\n                                    if(x.multiplier % d !== 0)\r\n                                        can_divide = false;\r\n                                }, true);\r\n                            }\r\n\r\n                            //if we can divide then do so\r\n                            if(can_divide) {\r\n\r\n                                var div = __.div(symbol, d.clone()),\r\n                                        is_factor = div[1].equals(0);\r\n                                \r\n                                // Break infinite loop for factoring e^t*x-1\r\n                                if((symbol.equals(div[0]) && div[1].equals(0))) {\r\n                                    break;\r\n                                }\r\n                                \r\n                                if(div[0].isConstant()) {\r\n                                    factors.add(div[0]);\r\n                                    break;\r\n                                }\r\n                                \r\n                            }\r\n                            else\r\n                                is_factor = false;\r\n\r\n                            if(is_factor) {\r\n                                factors.add(div[0]);\r\n                                symbol = d;\r\n                            }\r\n                        }\r\n                        while(is_factor)\r\n                    }\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //difference of squares factorization\r\n            sqdiff: function (symbol, factors) {\r\n                if(symbol.isConstant('all')) {\r\n                    // Nothing to do\r\n                    return symbol;\r\n                }\r\n\r\n                try {\r\n                    var remove_square = function (x) {\r\n                        return core.Utils.block('POSITIVE_MULTIPLIERS', function () {\r\n                            return Symbol.unwrapPARENS(math.sqrt(math.abs(x)));\r\n                        }, true);\r\n                    };\r\n                    var separated = core.Utils.separate(symbol.clone());\r\n\r\n                    var obj_array = [];\r\n\r\n                    //get the unique variables\r\n                    for(var x in separated) {\r\n                        if(x !== 'constants') {\r\n                            obj_array.push(separated[x]);\r\n                        }\r\n                    }\r\n                    obj_array.sort(function (a, b) {\r\n                        return b.power - a.power;\r\n                    });\r\n\r\n                    //if we have the same number of variables as unique variables then we can apply the difference of squares\r\n                    if(obj_array.length === 2) {\r\n                        var a, b;\r\n                        a = obj_array.pop();\r\n                        b = obj_array.pop();\r\n\r\n                        if(even(a.power) && even(b.power)\r\n                                && a.sign() === b.sign()\r\n                                && a.group === S && b.group === S) {\r\n                            throw new Error('Unable to factor');\r\n                        }\r\n                        ;\r\n\r\n                        if(a.isComposite() && b.power.equals(2)) {\r\n                            //remove the square from b\r\n                            b = remove_square(b);\r\n                            var f = __.Factor.factor(_.add(a, separated.constants));\r\n                            if(f.power.equals(2)) {\r\n                                f.toLinear();\r\n                                factors.add(_.subtract(f.clone(), b.clone()));\r\n                                factors.add(_.add(f, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            a = a.powSimp();\r\n                            b = b.powSimp();\r\n\r\n                            if((a.group === S || a.fname === '') && a.power.equals(2) && (b.group === S || b.fname === '') && b.power.equals(2) && !separated.constants) {\r\n                                if(a.multiplier.lessThan(0)) {\r\n                                    var t = b;\r\n                                    b = a;\r\n                                    a = t;\r\n                                }\r\n                                if(a.multiplier.greaterThan(0)) {\r\n                                    a = remove_square(a);\r\n                                    b = remove_square(b);\r\n                                }\r\n\r\n                                factors.add(_.subtract(a.clone(), b.clone()));\r\n                                factors.add(_.add(a, b));\r\n                                symbol = new Symbol(1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch(e) {\r\n                    ;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            //factoring for multivariate\r\n            mfactor: function (symbol, factors) {\r\n\r\n                if(symbol.group === FN) {\r\n                    if(symbol.fname === 'sqrt') {\r\n                        var factors2 = new Factors(),\r\n                                arg = __.Factor.common(symbol.args[0].clone(), factors2);\r\n                        arg = __.Factor.coeffFactor(arg, factors2);\r\n                        symbol = _.multiply(_.symfunction('sqrt', [arg]), _.parse(symbol.multiplier));\r\n                        factors2.each(function (x) {\r\n                            symbol = _.multiply(symbol, _.parse(core.Utils.format('sqrt({0})', x)));\r\n                        });\r\n                    }\r\n                    else\r\n                        factors.add(symbol);\r\n                }\r\n                else {\r\n\r\n                    //square free factorization\r\n                    symbol = __.Factor.mSqfrFactor(symbol, factors);\r\n\r\n                    //try factor out common factors\r\n                    //symbol = __.Factor.common(symbol, factors);\r\n\r\n                    var vars = variables(symbol),\r\n                            symbols = symbol.collectSymbols().map(function (x) {\r\n                        return Symbol.unwrapSQRT(x);\r\n                    }),\r\n                            sorted = {},\r\n                            maxes = {},\r\n                            l = vars.length, n = symbols.length;\r\n                    //take all the variables in the symbol and organize by variable name\r\n                    //e.g. a^2+a^2+b*a -> {a: {a^3, a^2, b*a}, b: {b*a}}\r\n\r\n                    for(var i = 0; i < l; i++) {\r\n                        var v = vars[i];\r\n                        sorted[v] = new Symbol(0);\r\n                        for(var j = 0; j < n; j++) {\r\n                            var s = symbols[j];\r\n                            if(s.contains(v)) {\r\n                                var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();\r\n                                if(!maxes[v] || p < maxes[v])\r\n                                    maxes[v] = p;\r\n                                sorted[v] = _.add(sorted[v], s.clone());\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    for(var x in sorted) {\r\n                        var r = _.parse(x + '^' + maxes[x]);\r\n                        var div = _.divide(sorted[x], r);\r\n                        var new_factor = _.expand(div);\r\n\r\n                        if(new_factor.equals(1))\r\n                            break; //why divide by one. Just move \r\n                        var divided = __.div(symbol.clone(), new_factor);\r\n\r\n                        if(divided[0].equals(0)) {\r\n                            //cant factor anymore\r\n                            break;\r\n                        }\r\n\r\n                        // We potentially ended up with fractional coefficients when the\r\n                        // trial division was performed. We need to remove \r\n                        // This check will more then likely become superfluous with improvements\r\n                        // to polynomial division\r\n                        if(divided[1].equals(0)) {\r\n                            var has_fractions = false;\r\n\r\n                            divided[0].each(function (x) {\r\n                                if(!isInt(x.multiplier)) {\r\n                                    has_fractions = true;\r\n                                }\r\n                            });\r\n\r\n                            // The factor isn't really a factor and needs to be put back\r\n                            if(has_fractions) {\r\n                                divided[1] = _.expand(_.multiply(divided[1], new_factor));\r\n                                // Since the new factor is not just one, we exit.\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);\r\n\r\n                        if(divided[1].equals(0) && !neg_numeric_factor) { //we found at least one factor\r\n\r\n                            //factors.add(new_factor);\r\n                            var d = __.div(symbol.clone(), divided[0].clone());\r\n                            var r = d[0];\r\n\r\n                            // Nothing left to do since we didn't get a reduction\r\n                            if(r.equals(0)) {\r\n                                return symbol;\r\n                            }\r\n\r\n                            symbol = d[1];\r\n                            //we don't want to just flip the sign. If the remainder is -1 then we accomplished nothing\r\n                            //and we just return the symbol;\r\n                            //If r equals zero then there's nothing left to do so we're done\r\n\r\n                            if(r.equals(-1) && !symbol.equals(0))\r\n                                return symbol;\r\n\r\n                            var factor = divided[0];\r\n\r\n                            if(symbol.equals(factor)) {\r\n                                var rem = __.Factor.reduce(factor, factors);\r\n\r\n                                if(!symbol.equals(rem))\r\n                                    return __.Factor.mfactor(rem, factors);\r\n\r\n                                return rem;\r\n                            }\r\n                            else {\r\n                                factors.add(factor);\r\n                                //if the remainder of the symbol is zero then we're done. TODO: Rethink this logic a bit.\r\n                                if(symbol.equals(0))\r\n                                    return r;\r\n                            }\r\n\r\n                            if(r.isConstant('all')) {\r\n                                factors.add(r);\r\n                                return r;\r\n                            }\r\n\r\n                            return __.Factor.mfactor(r, factors);\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                //difference of squares factorization\r\n                symbol = __.Factor.sqdiff(symbol, factors);\r\n\r\n                //factors by fishing for zeroes\r\n                symbol = __.Factor.zeroes(symbol, factors);\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        /**\r\n         * Checks to see if a set of \"equations\" is linear. \r\n         * @param {type} set\r\n         * @returns {Boolean}\r\n         */\r\n        allLinear: function (set) {\r\n            var l = set.length;\r\n            for(var i = 0; i < l; i++) {\r\n                if(!__.isLinear(set[i]))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        /*\r\n         * Checks to see if the \"equation\" is linear\r\n         * @param {Symbol} e\r\n         * @returns {boolean}\r\n         */\r\n        isLinear: function (e) {\r\n            var status = false, g = e.group;\r\n            if(g === PL || g === CP) {\r\n                status = true;\r\n                for(var s in e.symbols) {\r\n                    var symbol = e.symbols[s], sg = symbol.group;\r\n                    if(sg === FN || sg === EX) {\r\n                        status = false;\r\n                    }\r\n                    if(sg === CB) {\r\n                        //needs further checking since it might be imaginary\r\n                        status = variables(symbol).length === 1;\r\n                    }\r\n                    else {\r\n                        if(sg === PL || sg === CP)\r\n                            status = __.isLinear(symbol);\r\n                        else {\r\n                            if(symbol.group !== N && symbol.power.toString() !== '1') {\r\n                                status = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if(g === S && e.power === 1)\r\n                status = true;\r\n            return status;\r\n        },\r\n        gcd: function () {\r\n            var args;\r\n            if(arguments.length === 1 && arguments[0] instanceof core.Vector)\r\n                args = arguments[0].elements;\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //short-circuit early\r\n            if(args.length === 0)\r\n                return new Symbol(1);\r\n            else if(args.length === 1)\r\n                return args[0];\r\n\r\n            var appeared = [], evaluate = false;\r\n            for(var i = 0; i < args.length; i++) {\r\n                if(args[i].group === FN && args[i].fname === 'gcd')\r\n                {\r\n                    //compress gcd(a,gcd(b,c)) into gcd(a,b,c)\r\n                    args = args.concat(arguments[i].args);\r\n                    //do not keep gcd in args\r\n                    args.splice(i, 1);\r\n                }\r\n                else\r\n                {\r\n                    //Look if there are any common variables such that\r\n                    //gcd(a,b) => gcd(a,b); gcd(a,a) => a\r\n                    var vars = variables(args[i]);\r\n                    if(core.Utils.haveIntersection(vars, appeared))\r\n                    {\r\n                        //Ok, there are common variables\r\n                        evaluate = true;\r\n                        break;\r\n                    }\r\n                    else\r\n                        appeared = appeared.concat(vars);\r\n                }\r\n            }\r\n\r\n            //appeared.length is 0 when all arguments are group N\r\n            if(evaluate || appeared.length === 0) {\r\n                //TODO: distribute exponent so that (a^-1*b^-1)^-1 => a*b\r\n                if(args.every(function (symbol) {\r\n                    return symbol.getDenom().equals(1)\r\n                })) {\r\n                    var aggregate = args[0];\r\n\r\n                    for(var i = 1; i < args.length; i++) {\r\n                        aggregate = __.gcd_(args[i], aggregate);\r\n                    }\r\n                    return aggregate;\r\n                }\r\n                else {\r\n                    //gcd_ cannot handle denominators correctly\r\n                    return _.divide(__.gcd.apply(null, args.map(function (symbol) {\r\n                        return symbol.getNum();\r\n                    })),\r\n                            __.lcm.apply(null, args.map(function (symbol) {\r\n                                return symbol.getDenom();\r\n                            })));\r\n                }\r\n            }\r\n            else\r\n                return _.symfunction('gcd', args);\r\n        },\r\n        gcd_: function (a, b) {\r\n            if(a.group === FN || a.group === P)\r\n                a = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(a);\r\n                });\r\n\r\n            if(b.group === FN)\r\n                b = core.Utils.block('PARSE2NUMBER', function () {\r\n                    return _.parse(b);\r\n                });\r\n\r\n            if(a.isConstant() && b.isConstant()) {\r\n                // return core.Math2.QGCD(new Frac(+a), new Frac(+b));\r\n                return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));\r\n            }\r\n\r\n            var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();\r\n            a = _.multiply(a.clone(), den.clone());\r\n            b = _.multiply(b.clone(), den.clone());\r\n\r\n            //feels counter intuitive but it works. Issue #123 (nerdamer(\"gcd(x+y,(x+y)^2)\"))\r\n            a = _.expand(a);\r\n            b = _.expand(b);\r\n\r\n            if(a.group === CB || b.group === CB) {\r\n                var q = _.divide(a.clone(), b.clone()); //get the quotient\r\n                var t = _.multiply(b.clone(), q.getDenom().invert());//multiply by the denominator\r\n                //if they have a common factor then the result will not equal one \r\n                if(!t.equals(1))\r\n                    return t;\r\n            }\r\n\r\n            //just take the gcd of each component when either of them is in group EX\r\n            if(a.group === EX || b.group === EX)\r\n            {\r\n                var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));\r\n                var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));\r\n                var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));\r\n                return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));\r\n            }\r\n\r\n            if(a.length < b.length) { //swap'm\r\n                var t = a;\r\n                a = b;\r\n                b = t;\r\n            }\r\n            var vars_a = variables(a), vars_b = variables(b);\r\n            if((vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0])\r\n                    || vars_a.length === 1 && vars_b.length === 0\r\n                    || vars_a.length === 0 && vars_b.length === 1) {\r\n                a = new Polynomial(a);\r\n                b = new Polynomial(b);\r\n                return _.divide(a.gcd(b).toSymbol(), den);\r\n            }\r\n            else {\r\n                //get the gcd of the multipiers\r\n                //get rid of gcd in coeffs\r\n                var multipliers = [];\r\n                a.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n                b.each(function (x) {\r\n                    multipliers.push(x.multiplier);\r\n                });\r\n\r\n                var T;\r\n                while(!b.equals(0)) {\r\n                    var t = b.clone();\r\n                    a = a.clone();\r\n                    T = __.div(a, t);\r\n\r\n                    b = T[1];\r\n                    if(T[0].equals(0)) {\r\n                        //return _.multiply(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), b);\r\n                        return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);\r\n                    }\r\n                    a = t;\r\n                }\r\n\r\n                var gcd = core.Math2.QGCD.apply(undefined, multipliers);\r\n\r\n                if(!gcd.equals(1)) {\r\n                    a.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(gcd);\r\n                    });\r\n                }\r\n\r\n                //return symbolic function for gcd in indeterminate form\r\n                if(a.equals(1) && !a.isConstant() && !b.isConstant())\r\n                    return _.divide(_.symfunction('gcd', arguments), den);\r\n\r\n                return _.divide(a, den);\r\n            }\r\n        },\r\n        lcm: function () {\r\n            //https://math.stackexchange.com/a/319310\r\n            //generalization of the 2-variable formula of lcm\r\n\r\n            var args;\r\n            if(arguments.length === 1)\r\n                if(arguments[0] instanceof core.Vector)\r\n                    args = arguments[0].elements;\r\n                else\r\n                    _.error('lcm expects either 1 vector or 2 or more arguments');\r\n            else\r\n                args = core.Utils.arguments2Array(arguments);\r\n\r\n            //product of all arguments\r\n            //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n            var numer = args.reduce(function (prev, curr) {\r\n                return _.multiply(prev, curr.clone())\r\n            }, new Symbol(1));\r\n\r\n            //gcd of complementary terms\r\n            var denom_args =\r\n                    //https://stackoverflow.com/a/18223072\r\n                //take all complementary terms, e.g.\r\n                //[a,b,c] => [a*b, b*c, a*c]\r\n                //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]\r\n                (function (input, size) {\r\n                        size = Number(size);\r\n                        var results = [], result, mask, i, total = Math.pow(2, input.length);\r\n                        for(mask = size; mask < total; mask++) {\r\n                            result = [];\r\n                            i = input.length - 1;\r\n\r\n                            do {\r\n                                if((mask & (1 << i)) !== 0) {\r\n                                    result.push(input[i]);\r\n                                }\r\n                            }\r\n                            while(i--);\r\n\r\n                            if(result.length === size) {\r\n                                results.push(result);\r\n                            }\r\n                        }\r\n                        return results;\r\n                        //start with new Symbol(1) so that prev.clone() which makes unnessesary clones can be avoided\r\n                    })(arguments, arguments.length - 1).map(function (x) {\r\n                return x.reduce(function (prev, curr) {\r\n                    return _.multiply(prev, curr.clone())\r\n                }, new Symbol(1))\r\n            });\r\n\r\n            var denom;\r\n            //don't eat the gcd term if all arguments are symbols\r\n            if(args.every(function (x) {\r\n                return core.Utils.isVariableSymbol(x)\r\n            }))\r\n                denom = _.symfunction('gcd', core.Utils.arrayUnique(denom_args));\r\n            else\r\n                denom = __.gcd.apply(null, denom_args);\r\n            //divide product of all arguments by gcd of complementary terms\r\n            var div = _.divide(numer, denom);\r\n            return div;\r\n        },\r\n        /**\r\n         * Divides one expression by another\r\n         * @param {Symbol} symbol1\r\n         * @param {Symbol} symbol2\r\n         * @returns {Array}\r\n         */\r\n        divide: function (symbol1, symbol2) {\r\n            var result, remainder, factored, den;\r\n            factored = core.Algebra.Factor.factor(symbol1.clone());\r\n            den = factored.getDenom();\r\n            if(!den.isConstant('all')) {\r\n                symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));\r\n            }\r\n            else\r\n                //reset the denominator since we're not dividing by it anymore\r\n                den = new Symbol(1);\r\n            result = __.div(symbol1, symbol2);\r\n            remainder = _.divide(result[1], symbol2);\r\n            return _.divide(_.add(result[0], remainder), den);\r\n        },\r\n        div: function (symbol1, symbol2) {\r\n            // If all else fails then assume that division failed with\r\n            // a remainder of zero and the original quotient\r\n            var fail = [new Symbol(0), symbol1.clone()];\r\n\r\n            try {\r\n\r\n                // Division by constants\r\n                if(symbol2.isConstant('all')) {\r\n                    symbol1.each(function (x) {\r\n                        x.multiplier = x.multiplier.divide(symbol2.multiplier);\r\n                    });\r\n                    return [symbol1, new Symbol(0)];\r\n                }\r\n                // So that factorized symbols don't affect the result\r\n                symbol1 = _.expand(symbol1);\r\n                symbol2 = _.expand(symbol2);\r\n                // Special case. May need revisiting\r\n                if(symbol1.group === S && symbol2.group === CP) {\r\n                    var x = symbol1.value;\r\n                    var f = core.Utils.decompose_fn(symbol2.clone(), x, true);\r\n                    if(symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {\r\n                        var k = Symbol.create(symbol1.multiplier);\r\n                        return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];\r\n                    }\r\n                }\r\n                if(symbol1.group === S && symbol2.group === S) {\r\n                    var r = _.divide(symbol1.clone(), symbol2.clone());\r\n                    if(r.isConstant()) //we have a whole\r\n                        return [r, new Symbol(0)];\r\n                    return [new Symbol(0), symbol1.clone()];\r\n                }\r\n                var symbol1_has_func = symbol1.hasFunc(),\r\n                        symbol2_has_func = symbol2.hasFunc(),\r\n                        parse_funcs = false;\r\n\r\n                //substitute out functions so we can treat them as regular variables\r\n                if(symbol1_has_func || symbol2_has_func) {\r\n                    parse_funcs = true;\r\n                    var map = {},\r\n                            symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)),\r\n                            symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)),\r\n                            subs = core.Utils.getFunctionsSubs(map);\r\n                }\r\n                //get a list of the variables\r\n                var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))),\r\n                        quot, rem;\r\n\r\n                //treat imaginary numbers as variables\r\n                if(symbol1.isImaginary() || symbol2.isImaginary()) {\r\n                    vars.push(core.Settings.IMAGINARY);\r\n                }\r\n\r\n                if(vars.length === 1) {\r\n                    var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));\r\n                    quot = q[0].toSymbol();\r\n                    rem = q[1].toSymbol();\r\n                }\r\n                else {\r\n                    vars.push(CONST_HASH); //this is for the numbers\r\n                    var reconvert = function (arr) {\r\n                        var symbol = new Symbol(0);\r\n                        for(var i = 0; i < arr.length; i++) {\r\n                            var x = arr[i].toSymbol();\r\n                            symbol = _.add(symbol, x);\r\n                        }\r\n                        return symbol;\r\n                    };\r\n\r\n                    // Silly Martin. This is why you document. I don't remember now\r\n                    var get_unique_max = function (term, any) {\r\n                        var max = Math.max.apply(null, term.terms),\r\n                                count = 0, idx;\r\n\r\n                        if(!any) {\r\n                            for(var i = 0; i < term.terms.length; i++) {\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    count++;\r\n                                }\r\n                                if(count > 1)\r\n                                    return;\r\n                            }\r\n                        }\r\n                        if(any) {\r\n                            for(i = 0; i < term.terms.length; i++)\r\n                                if(term.terms[i].equals(max)) {\r\n                                    idx = i;\r\n                                    break;\r\n                                }\r\n                        }\r\n                        return [max, idx, term];\r\n                    };\r\n\r\n                    // Tries to find an LT in the dividend that will satisfy division\r\n                    var get_det = function (s, lookat) {\r\n                        lookat = lookat || 0;\r\n                        var det = s[lookat], l = s.length;\r\n                        if(!det)\r\n                            return;\r\n                        //eliminate the first term if it doesn't apply\r\n                        var umax = get_unique_max(det);\r\n                        for(var i = lookat + 1; i < l; i++) {\r\n                            var term = s[i],\r\n                                    is_equal = det.sum.equals(term.sum);\r\n                            if(!is_equal && umax) {\r\n                                break;\r\n                            }\r\n                            if(is_equal) {\r\n                                // Check the differences of their maxes. The one with the biggest difference governs\r\n                                // e.g. x^2*y^3 vs x^2*y^3 is unclear but this isn't the case in x*y and x^2\r\n                                var max1, max2, idx1, idx2, l2 = det.terms.length;\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var item1 = det.terms[j], item2 = term.terms[j];\r\n                                    if(typeof max1 === 'undefined' || item1.greaterThan(max1)) {\r\n                                        max1 = item1;\r\n                                        idx1 = j;\r\n                                    }\r\n                                    if(typeof max2 === 'undefined' || item2.greaterThan(max2)) {\r\n                                        max2 = item2;\r\n                                        idx2 = j;\r\n                                    }\r\n                                }\r\n                                //check their differences\r\n                                var d1 = max1.subtract(term.terms[idx1]),\r\n                                        d2 = max2.subtract(det.terms[idx2]);\r\n                                if(d2 > d1) {\r\n                                    umax = [max2, idx2, term];\r\n                                    break;\r\n                                }\r\n                                if(d1 > d2) {\r\n                                    umax = [max1, idx1, det];\r\n                                    break;\r\n                                }\r\n                            }\r\n                            else {\r\n                                //check if it's a suitable pick to determine the order\r\n                                umax = get_unique_max(term);\r\n                                //if(umax) return umax;\r\n                                if(umax)\r\n                                    break;\r\n                            }\r\n                            umax = get_unique_max(term); //calculate a new unique max\r\n                        }\r\n\r\n                        //if still no umax then any will do since we have a tie\r\n                        if(!umax)\r\n                            return get_unique_max(s[0], true);\r\n                        var e, idx;\r\n                        for(var i = 0; i < s2.length; i++) {\r\n                            var cterm = s2[i].terms;\r\n                            //confirm that this is a good match for the denominator\r\n                            idx = umax[1];\r\n                            if(idx === cterm.length - 1)\r\n                                return;\r\n                            e = cterm[idx];\r\n                            if(!e.equals(0))\r\n                                break;\r\n                        }\r\n                        if(e.equals(0))\r\n                            return get_det(s, ++lookat); //look at the next term\r\n\r\n                        return umax;\r\n                    };\r\n\r\n                    var t_map = core.Utils.toMapObj(vars);\r\n                    var init_sort = function (a, b) {\r\n                        return b.sum.subtract(a.sum);\r\n                    };\r\n                    var is_larger = function (a, b) {\r\n                        if(!a || !b)\r\n                            return false; //it's empty so...\r\n                        for(var i = 0; i < a.terms.length; i++) {\r\n                            if(a.terms[i].lessThan(b.terms[i]))\r\n                                return false;\r\n                        }\r\n                        return true;\r\n                    };\r\n\r\n                    var s1 = symbol1.tBase(t_map).sort(init_sort),\r\n                            s2 = symbol2.tBase(t_map).sort(init_sort);\r\n                    var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1; //since the num is already larger than we can get the det from denom\r\n                    var det = get_det(target);//we'll begin by assuming that this will let us know which term \r\n                    var quotient = [];\r\n                    if(det) {\r\n                        var lead_var = det[1];\r\n                        var can_divide = function (a, b) {\r\n                            if(a[0].sum.equals(b[0].sum))\r\n                                return a.length >= b.length;\r\n                            return true;\r\n                        };\r\n\r\n                        var try_better_lead_var = function (s1, s2, lead_var) {\r\n                            var checked = [];\r\n                            for(var i = 0; i < s1.length; i++) {\r\n                                var t = s1[i];\r\n                                for(var j = 0; j < t.terms.length; j++) {\r\n                                    var cf = checked[j], tt = t.terms[j];\r\n                                    if(i === 0)\r\n                                        checked[j] = tt; //add the terms for the first one\r\n                                    else if(cf && !cf.equals(tt))\r\n                                        checked[j] = undefined;\r\n                                }\r\n                            }\r\n                            for(var i = 0; i < checked.length; i++) {\r\n                                var t = checked[i];\r\n                                if(t && !t.equals(0))\r\n                                    return i;\r\n                            }\r\n                            return lead_var;\r\n                        };\r\n                        var sf = function (a, b) {\r\n                            var l1 = a.len(), l2 = b.len();\r\n                            var blv = b.terms[lead_var], alv = a.terms[lead_var];\r\n                            if(l2 > l1 && blv.greaterThan(alv))\r\n                                return l2 - l1;\r\n                            return blv.subtract(alv);\r\n                        };\r\n\r\n                        //check to see if there's a better lead_var\r\n                        lead_var = try_better_lead_var(s1, s2, lead_var);\r\n                        //reorder both according to the max power\r\n                        s1.sort(sf); //sort them both according to the leading variable power\r\n                        s2.sort(sf);\r\n\r\n                        //try to adjust if den is larger\r\n                        var fdt = s2[0], fnt = s1[0];\r\n\r\n                        var den = new MVTerm(new Frac(1), [], fnt.map);\r\n                        if(fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {\r\n                            for(var i = 0; i < fnt.terms.length; i++) {\r\n                                var d = fdt.terms[i].subtract(fnt.terms[i]);\r\n                                if(!d.equals(0)) {\r\n                                    var nd = d.add(new Frac(1));\r\n                                    den.terms[i] = d;\r\n                                    for(var j = 0; j < s1.length; j++) {\r\n                                        s1[j].terms[i] = s1[j].terms[i].add(nd);\r\n                                    }\r\n                                }\r\n                                else\r\n                                    den.terms[i] = new Frac(0);\r\n                            }\r\n                        }\r\n\r\n                        var dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                        var safety = 0;\r\n                        var max = 200;\r\n\r\n                        while(dividend_larger && can_divide(s1, s2)) {\r\n                            if(safety++ > max) {\r\n                                throw new core.exceptions.InfiniteLoopError('Unable to compute!');\r\n                            }\r\n\r\n                            var q = s1[0].divide(s2[0]);\r\n\r\n                            quotient.push(q); //add what's divided to the quotient\r\n                            s1.shift();//the first one is guaranteed to be gone so remove from dividend\r\n                            for(var i = 1; i < s2.length; i++) { //loop through the denominator\r\n                                var t = s2[i].multiply(q).generateImage(),\r\n                                        l2 = s1.length;\r\n                                //if we're subtracting from 0\r\n                                if(l2 === 0) {\r\n                                    t.coeff = t.coeff.neg();\r\n                                    s1.push(t);\r\n                                    s1.sort(sf);\r\n                                }\r\n\r\n                                for(var j = 0; j < l2; j++) {\r\n                                    var cur = s1[j];\r\n                                    if(cur.getImg() === t.getImg()) {\r\n                                        cur.coeff = cur.coeff.subtract(t.coeff);\r\n                                        if(cur.coeff.equals(0)) {\r\n                                            core.Utils.remove(s1, j);\r\n                                            j--; //adjust the iterator\r\n                                        }\r\n                                        break;\r\n                                    }\r\n                                    if(j === l2 - 1) {\r\n                                        t.coeff = t.coeff.neg();\r\n                                        s1.push(t);\r\n                                        s1.sort(sf);\r\n                                    }\r\n                                }\r\n                            }\r\n                            dividend_larger = is_larger(s1[0], s2[0]);\r\n\r\n                            if(!dividend_larger && s1.length >= s2.length) {\r\n                                //One more try since there might be a terms that is larger than the LT of the divisor\r\n                                for(var i = 1; i < s1.length; i++) {\r\n                                    dividend_larger = is_larger(s1[i], s2[0]);\r\n                                    if(dividend_larger) {\r\n                                        //take it from its current position and move it to the front\r\n                                        s1.unshift(core.Utils.remove(s1, i));\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    quot = reconvert(quotient);\r\n                    rem = reconvert(s1);\r\n\r\n                    if(typeof den !== 'undefined') {\r\n                        den = den.toSymbol();\r\n                        quot = _.divide(quot, den.clone());\r\n                        rem = _.divide(rem, den);\r\n                    }\r\n                }\r\n\r\n                //put back the functions\r\n                if(parse_funcs) {\r\n                    quot = _.parse(quot.text(), subs);\r\n                    rem = _.parse(rem.text(), subs);\r\n                }\r\n\r\n                return [quot, rem];\r\n            }\r\n            catch(e) {\r\n                return fail;\r\n            }\r\n\r\n        },\r\n        line: function (v1, v2, x) {\r\n            if(core.Utils.isArray(v1))\r\n                v1 = core.Utils.convertToVector(v1);\r\n            if(core.Utils.isArray(v2))\r\n                v2 = core.Utils.convertToVector(v2);\r\n            x = _.parse(x || 'x');\r\n            if(!core.Utils.isVector(v1) || !core.Utils.isVector(v2))\r\n                _.error('Line expects a vector! Received \"' + v1 + '\" & \"' + v2 + '\"');\r\n            var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()),\r\n                    dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()),\r\n                    m = _.divide(dy, dx),\r\n                    a = _.multiply(x, m.clone()),\r\n                    b = _.multiply(v1.e(1).clone(), m);\r\n            return _.add(_.subtract(a, b), v1.e(2).clone());\r\n        },\r\n        PartFrac: {\r\n            createTemplate: function (den, denom_factors, f_array, v) {\r\n                //clean up the denominator function by factors so it reduces nicely\r\n                den = __.Factor.factor(den);\r\n\r\n                //clean up factors. This is so inefficient but factors are wrapped in parens for safety\r\n                den.each(function (x, key) {\r\n                    if(x.group === FN && x.fname === '' && x.args[0].group === S) {\r\n                        var y = x.args[0];\r\n                        if(this.symbols) {\r\n                            delete this.symbols[key];\r\n                            this.symbols[y.value] = y;\r\n                        }\r\n                        else {\r\n                            den = x.args[0];\r\n                        }\r\n                    }\r\n                });\r\n\r\n                var factors, factors_vec, f, p, deg, degrees, m;\r\n                factors = denom_factors.collectFactors();\r\n                factors_vec = []; //a vector for the template\r\n                degrees = [];\r\n                m = new Symbol(1);\r\n\r\n                for(var i = 0; i < factors.length; i++) { //loop through the factors\r\n                    var factor = Symbol.unwrapPARENS(factors[i]);\r\n                    //if in he for P^n where P is polynomial and n = integer\r\n                    if(factor.power.greaterThan(1)) {\r\n                        p = Number(factor.power);\r\n                        f = factor.clone().toLinear(); //remove the power so we have only the function\r\n                        deg = Number(__.degree(f, v)); //get the degree of f\r\n                        //expand the factor\r\n                        for(var j = 0; j < p; j++) {\r\n                            var efactor = _.pow(f.clone(), new Symbol(j + 1));\r\n                            f_array.push(efactor.clone());\r\n                            var d = _.divide(den.clone(), efactor.clone());\r\n                            degrees.push(deg);\r\n                            factors_vec.push(d);\r\n                        }\r\n                    }\r\n                    /*\r\n                     Possible bug.\r\n                     Removed: causes 1/(20+24*x+4*x^2) to result in (-1/64)*(5+x)^(-1)+(1/64)*(1+x)^(-1)\r\n                     else if(factor.isConstant('all')) {\r\n                     m = _.multiply(m, factor);\r\n                     }\r\n                     */\r\n                    else {\r\n                        //get the degree of the factor so we tack it on tot he factor. This should probably be an array\r\n                        //but for now we note it on the symbol\r\n                        deg = Number(__.degree(factor, v));\r\n                        f_array.push(factor);\r\n                        var d = _.divide(den.clone(), factor.clone());\r\n                        d = _.expand(Symbol.unwrapPARENS(d));\r\n                        degrees.push(deg);\r\n                        factors_vec.push(d);\r\n                    }\r\n                }\r\n                //put back the constant\r\n                f_array = f_array.map(function (x) {\r\n                    return _.multiply(x, m.clone());\r\n                });\r\n                return [f_array, factors_vec, degrees];\r\n            },\r\n            partfrac: function (symbol, v, as_array) {\r\n\r\n                var vars = variables(symbol);\r\n\r\n                v = v || _.parse(vars[0]); //make wrt optional and assume first variable\r\n                try {\r\n                    var num, den, factors, tfactors, ofactors, nterms, degrees,\r\n                            dterms, max, M, c, powers, div, r, factors_vec, ks,\r\n                            template, tfactors;\r\n                    num = _.expand(symbol.getNum());\r\n                    den = _.expand(symbol.getDenom().toUnitMultiplier());\r\n                    //move the entire multipier to the numerator\r\n                    num.multiplier = symbol.multiplier;\r\n                    //we only have a meaningful change if n factors > 1. This means that\r\n                    //the returned group will be a CB\r\n                    //collect the terms wrt the x\r\n                    nterms = num.groupTerms(v);\r\n                    //divide out wholes if top is larger\r\n                    if(Number(__.degree(num, v)) >= Number(__.degree(den, v))) {\r\n                        div = __.div(num.clone(), _.expand(den.clone()));\r\n                        r = div[0]; //remove the wholes\r\n                        num = div[1]; //work with the remainder\r\n                        nterms = num.groupTerms(v); //recalculate the nterms\r\n                    }\r\n                    else\r\n                        r = new Symbol(0);\r\n\r\n                    if(Number(__.degree(den, v)) === 1) {\r\n                        var q = _.divide(num, den);\r\n                        if(as_array)\r\n                            return [r, q];\r\n                        return _.add(r, q);\r\n                    }\r\n                    //first factor the denominator. This means that the strength of this\r\n                    //algorithm depends on how well we can factor the denominator. \r\n                    ofactors = __.Factor.factor(den);\r\n                    //create the template. This method will create the template for solving \r\n                    //the partial fractions. So given x/(x-1)^2 the template creates A/(x-1)+B/(x-1)^2\r\n                    template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);\r\n                    tfactors = template[0]; //grab the factors\r\n                    factors_vec = template[1]; //grab the factor vectors\r\n                    degrees = template[2]; //grab the degrees\r\n                    //make note of the powers of each term\r\n                    powers = [nterms.length];\r\n                    //create the dterms vector\r\n                    dterms = [];\r\n                    factors = [];\r\n                    ks = [];\r\n                    var factor, deg;\r\n                    factors_vec.map(function (x, idx) {\r\n                        factor = tfactors[idx];\r\n                        deg = degrees[idx];\r\n                        for(var i = 0; i < deg; i++) {\r\n                            factors.push(factor.clone());\r\n                            var k = Symbol.create(v, i);\r\n                            var t = _.expand(_.multiply(x, k.clone())).groupTerms(v);\r\n                            //make a note of the power which corresponds to the length of the array\r\n                            var p = t.length;\r\n                            powers.push(p);\r\n                            dterms.push(t);\r\n                            ks.push(k.clone());\r\n                        }\r\n                    });\r\n                    //get the max power\r\n                    max = core.Utils.arrayMax(powers);\r\n\r\n                    //fill the holes and create a matrix\r\n                    c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();\r\n                    //for each of the factors we do the same\r\n                    M = new core.Matrix();\r\n                    for(var i = 0; i < dterms.length; i++) {\r\n                        M.elements.push(core.Utils.fillHoles(dterms[i], max));\r\n                    }\r\n\r\n                    //solve the system of equations\r\n                    var partials = _.multiply(M.transpose().invert(), c);\r\n                    //the results are backwards to reverse it\r\n                    //partials.elements.reverse();\r\n                    //convert it all back\r\n                    var retval = as_array ? [r] : r;\r\n                    partials.each(function (e, i) {\r\n                        var term = _.multiply(ks[i], _.divide(e, factors[i]));\r\n                        if(as_array)\r\n                            retval.push(term);\r\n                        else\r\n                            retval = _.add(retval, term);\r\n                    });\r\n\r\n                    //done\r\n                    return retval;\r\n                }\r\n                catch(e) {\r\n                    //try to group symbols\r\n                    try {\r\n                        if(symbol.isComposite()) {\r\n                            //group denominators\r\n                            var denominators = {};\r\n\r\n                            symbol.each(function (x) {\r\n                                var d = x.getDenom();\r\n                                var n = x.getNum();\r\n                                var e = denominators[d];\r\n                                denominators[d] = e ? _.add(e, n) : n;\r\n                            });\r\n\r\n                            var t = new Symbol(0);\r\n\r\n                            for(var x in denominators) {\r\n                                t = _.add(t, _.divide(denominators[x], _.parse(x)));\r\n                            }\r\n\r\n                            symbol = t;\r\n                        }\r\n                    }\r\n                    catch(e2) {\r\n                    }\r\n                    ;\r\n                }\r\n                ;\r\n\r\n                return symbol;\r\n            }\r\n        },\r\n        degree: function (symbol, v, o) {\r\n            o = o || {\r\n                nd: [], //numeric\r\n                sd: [], //symbolic\r\n                depth: 0 //call depth\r\n            };\r\n\r\n            if(!v) {\r\n                var vars = variables(symbol);\r\n                //The user must specify the variable for multivariate\r\n                if(vars.length > 1)\r\n                    throw new Error('You must specify the variable for multivariate polynomials!');\r\n                //if it's empty then we're dealing with a constant\r\n                if(vars.length === 0)\r\n                    return new Symbol(0);\r\n                //assume the variable for univariate\r\n                v = _.parse(vars[0]);\r\n            }\r\n\r\n            //store the group\r\n            var g = symbol.group;\r\n            //we're going to trust the user and assume no EX. Calling isPoly \r\n            //would eliminate this but no sense in checking twice. \r\n            if(symbol.isComposite()) {\r\n                symbol = symbol.clone();\r\n                symbol.distributeExponent();\r\n                symbol.each(function (x) {\r\n                    o.depth++; //mark a depth increase\r\n                    __.degree(x, v, o);\r\n                    o.depth--; //we're back\r\n                });\r\n            }\r\n            else if(symbol.group === CB) {\r\n                symbol.each(function (x) {\r\n                    o.depth++;\r\n                    __.degree(x, v, o);\r\n                    o.depth++;\r\n                });\r\n            }\r\n            else if(g === EX && symbol.value === v.value) {\r\n                o.sd.push(symbol.power.clone());\r\n            }\r\n            else if(g === S && symbol.value === v.value) {\r\n                o.nd.push(_.parse(symbol.power));\r\n            }\r\n            else\r\n                o.nd.push(new Symbol(0));\r\n\r\n            //get the max out of the array\r\n            var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : undefined;\r\n\r\n            if(o.depth === 0 && o.sd.length > 0) {\r\n                if(deg !== undefined)\r\n                    o.sd.unshift(deg);\r\n                return _.symfunction('max', o.sd);\r\n            }\r\n            if(!core.Utils.isSymbol(deg))\r\n                deg = _.parse(deg);\r\n            //return the degree\r\n            return deg;\r\n        },\r\n        /**\r\n         * Attempts to complete the square of a polynomial\r\n         * @param {type} symbol\r\n         * @param {type} v\r\n         * @param {type} raw\r\n         * @throws {Error} \r\n         * @returns {Object|Symbol[]}\r\n         */\r\n        sqComplete: function (symbol, v, raw) {\r\n            if(!core.Utils.isSymbol(v))\r\n                v = _.parse(v);\r\n            var stop = function (msg) {\r\n                msg = msg || 'Stopping';\r\n                throw new core.exceptions.ValueLimitExceededError(msg);\r\n            };\r\n            //if not CP then nothing to do\r\n            if(!symbol.isPoly(true))\r\n                stop('Must be a polynomial!');\r\n\r\n            //declare vars\r\n            var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;\r\n\r\n            br = core.Utils.inBrackets;\r\n            //make a copy\r\n            symbol = symbol.clone();\r\n            deg = core.Algebra.degree(symbol, v); //get the degree of polynomial\r\n            //must be in form ax^2 +/- bx +/- c\r\n            if(!deg.equals(2))\r\n                stop('Cannot complete square for degree ' + deg);\r\n            //get the coeffs\r\n            coeffs = core.Algebra.coeffs(symbol, v);\r\n            a = coeffs[2];\r\n            //store the sign\r\n            sign = coeffs[1].sign();\r\n            //divide the linear term by two and square it\r\n            b = _.divide(coeffs[1], new Symbol(2));\r\n            //add the difference to the constant\r\n            c = _.pow(b.clone(), new Symbol(2));\r\n            if(raw)\r\n                return [a, b, d];\r\n            sqrt_a = math.sqrt(a);\r\n            e = _.divide(math.sqrt(c), sqrt_a.clone());\r\n            //calculate d which is the constant\r\n            d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));\r\n            //compute the square part\r\n            sym = _.parse(br(sqrt_a.clone() + '*' + v + (sign < 0 ? '-' : '+') + e));\r\n            return {\r\n                a: sym,\r\n                c: d,\r\n                f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())\r\n            };\r\n        },\r\n        Simplify: {\r\n            strip: function (symbol) {\r\n                var c = _.parse(symbol.multiplier);\r\n                symbol.toUnitMultiplier();\r\n                var p = _.parse(symbol.power);\r\n                symbol.toLinear();\r\n                return [c, p, symbol];\r\n            },\r\n            unstrip: function (cp, symbol) {\r\n                var c = cp[0];\r\n                var p = cp[1];\r\n                return _.multiply(c, _.pow(symbol, p));\r\n            },\r\n            complexSimp: function (num, den) {\r\n                var ac, bd, bc, ad, cd, r1, r2, i1, i2;\r\n                r1 = num.realpart();\r\n                i1 = num.imagpart();\r\n                r2 = den.realpart();\r\n                i2 = den.imagpart();\r\n                //apply complex arithmatic rule\r\n                ac = _.multiply(r1.clone(), r2.clone());\r\n                bd = _.multiply(i1.clone(), i2.clone());\r\n                bc = _.multiply(r2.clone(), i1);\r\n                ad = _.multiply(r1, i2.clone());\r\n                cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));\r\n\r\n                return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);\r\n            },\r\n            trigSimp: function (symbol) {\r\n                if(symbol.containsFunction(['cos', 'sin', 'tan'])) {\r\n                    symbol = symbol.clone();\r\n                    //remove power and multiplier\r\n                    var sym_array = __.Simplify.strip(symbol);\r\n                    symbol = sym_array.pop();\r\n                    //the default return value is the symbol\r\n                    var retval = symbol.clone();\r\n\r\n                    //rewrite the symbol\r\n                    if(symbol.group === CP) {\r\n                        var sym = new Symbol(0);\r\n                        symbol.each(function (x) {\r\n                            //rewrite the function\r\n                            var tr = __.Simplify.trigSimp(x.fnTransform());\r\n                            sym = _.add(sym, tr);\r\n                        }, true);\r\n\r\n                        //put back the power and multiplier and return\r\n                        retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));\r\n                    }\r\n                    else if(symbol.group === CB) {\r\n\r\n                        var n = symbol.getNum();\r\n                        var d = symbol.getDenom();\r\n\r\n                        //try for tangent\r\n                        if(n.fname === 'sin' && d.fname === 'cos' && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {\r\n                            retval = _.parse(core.Utils.format('({0})*({1})*tan({2})^({3})', d.multiplier, n.multiplier, n.args[0], n.power));\r\n                        }\r\n                        if(retval.group === CB) {\r\n                            var t = new Symbol(1);\r\n                            retval.each(function (x) {\r\n                                if(x.fname === 'tan') {\r\n                                    x = _.parse(core.Utils.format('({0})*sin({1})^({2})/cos({1})^({2})', x.multiplier, __.Simplify.simplify(x.args[0]), x.power));\r\n                                }\r\n                                t = _.multiply(t, x);\r\n                            });\r\n                            retval = t;\r\n                        }\r\n                    }\r\n\r\n\r\n                    retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();\r\n\r\n                    symbol = retval;\r\n                }\r\n\r\n                return symbol;\r\n            },\r\n            fracSimp: function (symbol) {\r\n                //try a quick simplify of imaginary numbers\r\n                var den = symbol.getDenom();\r\n                var num = symbol.getNum();\r\n\r\n                if(num.isImaginary() && den.isImaginary())\r\n                    symbol = __.Simplify.complexSimp(num, den);\r\n\r\n                if(symbol.isComposite()) {\r\n                    if(symbol.power > 1) {\r\n                        symbol = _.expand(symbol);\r\n                    }\r\n\r\n                    var symbols = symbol.collectSymbols();\r\n                    //assumption 1.\r\n                    //since it's a composite, it has a length of at least 1\r\n                    var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;\r\n                    a = symbols.pop(); //grab the first symbol\r\n                    //loop through each term and make denominator common\r\n                    while(symbols.length) {\r\n                        b = symbols.pop(); //grab the second symbol\r\n                        d1 = _.parse(a.getDenom());\r\n                        d2 = _.parse(b.getDenom());\r\n                        n1 = a.getNum();\r\n                        n2 = b.getNum();\r\n                        c = _.multiply(d1.clone(), d2.clone());\r\n                        x = _.multiply(n1, d2);\r\n                        y = _.multiply(n2, d1);\r\n                        s = _.add(x, y);\r\n                        a = _.divide(s, c);\r\n                    }\r\n                    den = _.expand(a.getDenom());\r\n                    num = _.expand(a.getNum());\r\n                    //simplify imaginary\r\n                    if(num.isImaginary() && den.isImaginary()) {\r\n                        retval = __.Simplify.complexSimp(num, den);\r\n                    }\r\n                    else {\r\n                        retval = _.divide(num, den);\r\n                    }\r\n\r\n                    //we've already hit the simplest form so return that\r\n                    if(retval.equals(symbol)) {\r\n                        return symbol;\r\n                    }\r\n\r\n                    //otherwise simplify it some more\r\n                    return __.Simplify.simplify(retval);\r\n                }\r\n                return symbol;\r\n            },\r\n            ratSimp: function (symbol) {\r\n                if(symbol.group === CB) {\r\n                    var den = symbol.getDenom();\r\n                    var num = symbol.getNum().distributeMultiplier();\r\n                    var d = __.Simplify.fracSimp(den);\r\n                    var n = __.Simplify.fracSimp(num);\r\n                    symbol = _.divide(n, d);\r\n                }\r\n                return symbol;\r\n            },\r\n            sqrtSimp: function (symbol, sym_array) {\r\n                var retval;\r\n                if(symbol.isSQRT()) {\r\n                    var factored = __.Factor.factor(symbol.args[0].clone());\r\n                    var m = _.parse(factored.multiplier);\r\n                    var sign = m.sign();\r\n\r\n                    var retval = _.sqrt(m.abs());\r\n                    var arg;\r\n\r\n                    if(isInt(retval)) {\r\n\r\n                        if(factored.group === CB) {\r\n                            var rem = new Symbol(1);\r\n\r\n                            factored.each(function (x) {\r\n                                if(x.group === N) {\r\n                                    var trial = _.sqrt(x.clone());\r\n\r\n                                    // Multiply back sqrt if it's an integer otherwise just put back the number\r\n                                    if(isInt(trial)) {\r\n                                        retval = _.multiply(retval, trial);\r\n                                    }\r\n                                    else {\r\n                                        rem = _.multiply(rem, x);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    rem = _.multiply(rem, x);\r\n                                }\r\n\r\n                            });\r\n                            var t = _.multiply(rem, _.parse(sign));\r\n                            arg = _.sqrt(t.clone());\r\n\r\n                            // Expand if it's imaginary\r\n                            if(arg.isImaginary) {\r\n                                arg = _.sqrt(_.expand(t.clone()));\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Strip the multiplier\r\n                            arg = _.sqrt(factored.clone().toUnitMultiplier());\r\n                        }\r\n                        return _.multiply(retval, arg);\r\n\r\n                    }\r\n\r\n                }\r\n                else if(symbol.isComposite() && symbol.isLinear()) {\r\n                    retval = new Symbol(0);\r\n                    symbol.each(function (x) {\r\n                        retval = _.add(retval, __.Simplify.sqrtSimp(x));\r\n                    }, true);\r\n                    // Put back the multiplier\r\n                    retval = _.multiply(retval, _.parse(symbol.multiplier));\r\n                }\r\n                else if(symbol.group === CB) {\r\n                    retval = _.parse(symbol.multiplier);\r\n                    symbol.each(function (x) {\r\n                        var simp = __.Simplify.sqrtSimp(x);\r\n                        retval = _.multiply(retval, simp);\r\n\r\n                    }, true);\r\n                    // Put back the power\r\n                    retval = _.pow(retval, _.parse(symbol.power));\r\n                }\r\n\r\n                return retval ? retval : _.parse(symbol);\r\n            },\r\n            /**\r\n             * Unused. The goal is to substitute out patterns but it currently doesn't work.\r\n             * @param {Symbol} symbol\r\n             * @return {Array} The symbol and the matched patterns\r\n             */\r\n            patternSub: function (symbol) {\r\n                var patterns = {};\r\n\r\n                var has_CP = function (symbol) {\r\n                    var found = false;\r\n                    symbol.each(function (x) {\r\n                        if(x.group === CP) {\r\n                            found = true;\r\n                        }\r\n                        else if(x.symbols) {\r\n                            found = has_CP(x);\r\n                        }\r\n                    });\r\n\r\n                    return found;\r\n                };\r\n\r\n                var collect = function (sym) {\r\n                    // We loop through each symbol looking for anything in the simplest\r\n                    // form of ax+byz+...\r\n                    sym.each(function (x) {\r\n                        // Items of group N,P,S, need to apply\r\n                        if(!x.symbols && x.group !== FN) {\r\n                            return;\r\n                        }\r\n\r\n                        // Check to see if it has any symbols of group CP\r\n                        // Get the patterns in that symbol instead if it has anything of group CP\r\n                        if(has_CP(x)) {\r\n                            collect(x);\r\n                        }\r\n                        else {\r\n                            if(!patterns[x.value]) {\r\n                                var u = core.Utils.getU(symbol);\r\n                                // Get a u value and mark it for subsitution\r\n                                patterns[x.value] = u;\r\n                                symbol = symbol.sub(x.value, u);\r\n                            }\r\n                        }\r\n                    }, true);\r\n                };\r\n\r\n                // Collect a list of patterns\r\n                collect(symbol);\r\n\r\n                return [symbol, patterns];\r\n            },\r\n            simplify: function (symbol) {\r\n                //remove the multiplier to make calculation easier;\r\n                var sym_array = __.Simplify.strip(symbol);\r\n                symbol = sym_array.pop();\r\n                //remove gcd from denominator\r\n                symbol = __.Simplify.fracSimp(symbol);\r\n                //nothing more to do\r\n                if(symbol.isConstant() || symbol.group === core.groups.S) {\r\n                    sym_array.push(symbol);\r\n                    var ret = __.Simplify.unstrip(sym_array, symbol);\r\n                    return ret;\r\n                }\r\n\r\n                //var patterns;\r\n\r\n                var simplified = symbol.clone(); //make a copy\r\n\r\n                //[simplified, patterns] = __.Simplify.patternSub(symbol);\r\n\r\n                // Simplify sqrt within the symbol\r\n//                simplified = __.Simplify.sqrtSimp(simplified, sym_array);\r\n\r\n                // Try trig simplificatons e.g. cos(x)^2+sin(x)^2\r\n                simplified = __.Simplify.trigSimp(simplified);\r\n\r\n                // Simplify common denominators\r\n                simplified = __.Simplify.ratSimp(simplified);\r\n\r\n                // First go for the \"cheapest\" simplification which may eliminate \r\n                // your problems right away. factor -> evaluate. Remember\r\n                // that there's no need to expand since factor already does that\r\n\r\n                simplified = __.Factor.factor(simplified);\r\n\r\n                //If the simplfied is a sum then we can make a few more simplifications\r\n                //e.g. simplify(1/(x-1)+1/(1-x)) as per issue #431\r\n                if(simplified.group === core.groups.CP && simplified.isLinear()) {\r\n                    var m = simplified.multiplier.clone();\r\n                    simplified.toUnitMultiplier(); //strip the multiplier\r\n                    var r = new Symbol(0);\r\n                    //return the sum of simplifications\r\n                    simplified.each(function (x) {\r\n                        var s = __.Simplify.simplify(x);\r\n                        r = _.add(r, s);\r\n                    });\r\n                    simplified = r;\r\n                    //put back the multiplier\r\n                    r.multiplier = r.multiplier.multiply(m);\r\n                }\r\n\r\n                //place back multiplier and return\r\n                var retval = __.Simplify.unstrip(sym_array, simplified);\r\n\r\n                // Back substitute\r\n                /*\r\n                 for(var x in patterns) {\r\n                 retval = retval.sub(patterns[x], x);\r\n                 }\r\n                 */\r\n\r\n                return retval;\r\n            }\r\n        },\r\n\r\n        Classes: {\r\n            Polynomial: Polynomial,\r\n            Factors: Factors,\r\n            MVTerm: MVTerm\r\n        }\r\n    };\r\n\r\n    // Add a link to simplify\r\n    core.Expression.prototype.simplify = function () {\r\n        return __.Simplify.simplify(this.symbol);\r\n    };\r\n\r\n    nerdamer.useAlgebraDiv = function () {\r\n        var divide = __.divideFn = _.divide;\r\n        var calls = 0; //keep track of how many calls were made\r\n        _.divide = function (a, b) {\r\n            calls++;\r\n            var ans;\r\n            if(calls === 1) //check if this is the first call. If it is use algebra divide\r\n                ans = core.Algebra.divide(a, b);\r\n            else //otherwise use parser divide\r\n                ans = divide(a, b);\r\n            calls = 0; //reset the number of calls back to none\r\n            return ans;\r\n        };\r\n    };\r\n\r\n    nerdamer.useParserDiv = function () {\r\n        if(__.divideFn)\r\n            _.divide = __.divideFn;\r\n        delete __.divideFn;\r\n    };\r\n\r\n    nerdamer.register([\r\n        {\r\n            name: 'factor',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Factor.factor;\r\n            }\r\n        },\r\n        {\r\n            name: 'simplify',\r\n            visible: true,\r\n            numargs: 1,\r\n            build: function () {\r\n                return __.Simplify.simplify;\r\n            }\r\n        },\r\n        {\r\n            name: 'gcd',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.gcd;\r\n            }\r\n        },\r\n        {\r\n            name: 'lcm',\r\n            visible: true,\r\n            numargs: [1, ],\r\n            build: function () {\r\n                return __.lcm;\r\n            }\r\n        },\r\n        {\r\n            name: 'roots',\r\n            visible: true,\r\n            numargs: -1,\r\n            build: function () {\r\n                return __.roots;\r\n            }\r\n        },\r\n        {\r\n            name: 'divide',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.divide;\r\n            }\r\n        },\r\n        {\r\n            name: 'div',\r\n            visible: true,\r\n            numargs: 2,\r\n            build: function () {\r\n                return __.div;\r\n            }\r\n        },\r\n        {\r\n            name: 'partfrac',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.PartFrac.partfrac;\r\n            }\r\n        },\r\n        {\r\n            name: 'deg',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                return __.degree;\r\n            }\r\n        },\r\n        {\r\n            name: 'coeffs',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function () {\r\n                    var coeffs = __.coeffs.apply(__, arguments);\r\n                    return new core.Vector(coeffs);\r\n                };\r\n                return f;\r\n            }\r\n        },\r\n        {\r\n            name: 'line',\r\n            visible: true,\r\n            numargs: [2, 3],\r\n            build: function () {\r\n                return __.line;\r\n            }\r\n        },\r\n        {\r\n            name: 'sqcomp',\r\n            visible: true,\r\n            numargs: [1, 2],\r\n            build: function () {\r\n                var f = function (x, v) {\r\n                    try {\r\n                        v = v || variables(x)[0];\r\n                        var sq = __.sqComplete(x.clone(), v);\r\n                        return sq.f;\r\n                    }\r\n                    catch(e) {\r\n                        return x;\r\n                    }\r\n                };\r\n                return f;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.updateAPI();\r\n})();"],
  "mappings": "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",
  "names": ["retval", "symbol", "a", "b", "f", "arg", "x", "p", "k", "sym", "u", "integral", "t", "factor", "vars", "i", "x", "rarr", "powers", "max", "p", "N", "c", "d", "g", "c2", "j", "zeror", "zeroi", "l", "a", "b", "e", "ret", "symbol", "evaluate", "det", "l2", "s1", "s2", "lead_var", "t"]
}
