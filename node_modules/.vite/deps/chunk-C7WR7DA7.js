import {
  require_nerdamer_core
} from "./chunk-VJYXX7CH.js";
import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/nerdamer/Calculus.js
var require_Calculus = __commonJS({
  "node_modules/nerdamer/Calculus.js"(exports, module) {
    if (typeof module !== "undefined" && typeof nerdamer === "undefined") {
      nerdamer = require_nerdamer_core();
      require_Algebra();
    }
    var nerdamer;
    (function() {
      "use strict";
      var core = nerdamer.getCore(), _ = core.PARSER, Frac = core.Frac, Settings = core.Settings, isSymbol = core.Utils.isSymbol, FN = core.groups.FN, Symbol = core.Symbol, text = core.Utils.text, inBrackets = core.Utils.inBrackets, isInt = core.Utils.isInt, format = core.Utils.format, even = core.Utils.even, evaluate = core.Utils.evaluate, N = core.groups.N, S = core.groups.S, FN = core.groups.FN, PL = core.groups.PL, CP = core.groups.CP, CB = core.groups.CB, EX = core.groups.EX, P = core.groups.P, LOG = Settings.LOG, EXP = "exp", ABS = "abs", SQRT = "sqrt", SIN = "sin", COS = "cos", TAN = "tan", SEC = "sec", CSC = "csc", COT = "cot", ASIN = "asin", ACOS = "acos", ATAN = "atan", ASEC = "asec", ACSC = "acsc", ACOT = "acot", SINH = "sinh", COSH = "cosh", TANH = "tanh", CSCH = "csch", SECH = "sech", COTH = "coth", ASECH = "asech", ACSCH = "acsch", ACOTH = "acoth";
      function NoIntegralFound(msg) {
        this.message = msg || "";
      }
      NoIntegralFound.prototype = new Error();
      Symbol.prototype.hasIntegral = function() {
        return this.containsFunction("integrate");
      };
      Symbol.prototype.fnTransform = function() {
        if (this.group !== FN)
          return this;
        var retval, a = this.args[0];
        var m = new Symbol(this.multiplier);
        var sym = this.clone().toUnitMultiplier();
        if (this.isLinear()) {
          switch (this.fname) {
            case SINH:
              retval = _.parse(format("(e^({0})-e^(-({0})))/2", a));
              break;
            case COSH:
              retval = _.parse(format("(e^({0})+e^(-({0})))/2", a));
              break;
            case TANH:
              retval = _.parse(format("(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))", a));
              break;
            case TAN:
              retval = _.parse(format("sin({0})/cos({0})", a));
              break;
            case CSC:
              retval = _.parse(format("1/sin({0})", a));
              break;
            case SEC:
              retval = _.parse(format("1/cos({0})", a));
              break;
            default:
              retval = sym;
          }
        } else if (this.power.equals(2)) {
          switch (this.fname) {
            case SIN:
              retval = _.parse(format("1/2-cos(2*({0}))/2", a));
              break;
            case COS:
              retval = _.parse(format("1/2+cos(2*({0}))/2", a));
              break;
            case TAN:
              retval = _.parse(format("sin({0})^2/cos({0})^2", a));
              break;
            case COSH:
              retval = _.parse(format("1/2+cosh(2*({0}))/2", a));
              break;
            case SINH:
              retval = _.parse(format("-1/2+cosh(2*({0}))/2", a));
              break;
            case TANH:
              retval = _.parse(format("(1+cosh(2*({0})))/(-1+cosh(2*({0})))", a));
              break;
            case SEC:
              retval = _.parse(format("(1-cos(2*({0})))/(1+cos(2*({0})))+1", a));
              break;
            default:
              retval = sym;
          }
        } else if (this.fname === SEC) {
          retval = _.parse(format("1/cos({0})^({1})", this.args[0], this.power));
        } else if (this.fname === CSC) {
          retval = _.parse(format("1/sin({0})^({1})", this.args[0], this.power));
        } else if (this.fname === TAN) {
          if (this.power.lessThan(0)) {
            retval = _.parse(format("cos({0})^(-({1}))/sin({0})^({1})", this.args[0], this.power.negate()));
          } else {
            retval = _.parse(format("sin({0})^({1})/cos({0})^({1})", this.args[0], this.power));
          }
        } else if (this.fname === SIN && this.power.lessThan(0)) {
          retval = _.parse(format("csc({0})^(-({1}))", this.args[0], this.power.negate()));
        } else if (this.fname === COS && this.power.lessThan(0)) {
          retval = _.parse(format("sec({0})^(-({1}))", this.args[0], this.power.negate()));
        } else if (this.fname === SIN && this.power.equals(3)) {
          retval = _.parse(format("(3*sin({0})-sin(3*({0})))/4", this.args[0]));
        } else if (this.fname === COS && this.power.equals(3)) {
          retval = _.parse(format("(cos(3*({0}))+3*cos({0}))/4", this.args[0]));
        } else if ((this.fname === COS || this.fname === SIN) && even(this.power)) {
          var n = this.power / 2;
          var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();
          var transformed = _.expand(_.pow(double_angle, _.parse(n)));
          retval = new Symbol(0);
          transformed.each(function(s) {
            var t = s.fnTransform();
            retval = _.add(retval, t);
          }, true);
        } else
          retval = sym;
        return _.multiply(retval, m);
      };
      Symbol.prototype.hasTrig = function() {
        if (this.isConstant(true) || this.group === S)
          return false;
        if (this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))
          return true;
        if (this.symbols) {
          for (var x in this.symbols)
            if (this.symbols[x].hasTrig())
              return true;
        }
        return false;
      };
      core.Expression.prototype.hasIntegral = function() {
        return this.symbol.hasIntegral();
      };
      core.Utils.toCommonDenominator = function(symbol) {
        if (symbol.isComposite() && symbol.isLinear()) {
          var m = new Symbol(symbol.multiplier);
          var denominator = new Symbol(1);
          var numerator = new Symbol(0);
          symbol.each(function(x) {
            denominator = _.multiply(denominator, x.getDenom());
          }, true);
          symbol.each(function(x) {
            var num = x.getNum();
            var den = x.getDenom();
            var factor = _.multiply(num, _.divide(denominator.clone(), den));
            numerator = _.add(numerator, factor);
          });
          var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));
          return retval;
        }
        return symbol;
      };
      core.Utils.in_inverse_trig = function(x) {
        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];
        return inv_trig_fns.indexOf(x) !== -1;
      };
      core.Utils.in_trig = function(x) {
        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];
        return trig_fns.indexOf(x) !== -1;
      };
      core.Utils.in_htrig = function(x) {
        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];
        return trig_fns.indexOf(x) !== -1;
      };
      core.Matrix.jacobian = function(eqns, vars) {
        var jacobian = new core.Matrix();
        if (!vars) {
          vars = core.Utils.arrayGetVariables(eqns);
        }
        vars.forEach(function(v, i) {
          eqns.forEach(function(eq, j) {
            var e = core.Calculus.diff(eq.clone(), v);
            jacobian.set(j, i, e);
          });
        });
        return jacobian;
      };
      core.Matrix.prototype.max = function() {
        var max = new Symbol(0);
        this.each(function(x) {
          var e = x.abs();
          if (e.gt(max))
            max = e;
        });
        return max;
      };
      core.Matrix.cMatrix = function(value, vars) {
        var m = new core.Matrix();
        vars.forEach(function(v, i) {
          m.set(i, 0, _.parse(value));
        });
        return m;
      };
      var all_functions = core.Utils.all_functions = function(arr) {
        for (var i = 0, l = arr.length; i < l; i++)
          if (arr[i].group !== FN)
            return false;
        return true;
      }, cosAsinBtransform = core.Utils.cosAsinBtranform = function(symbol1, symbol2) {
        var a, b;
        a = symbol1.args[0];
        b = symbol2.args[0];
        return _.parse(format("(sin(({0})+({1}))-sin(({0})-({1})))/2", a, b));
      }, cosAsinAtransform = core.Utils.cosAsinAtranform = function(symbol1, symbol2) {
        if (Number(symbol2.power) !== 1)
          return _.multiply(symbol1, symbol2);
        var a;
        a = symbol1.args[0];
        return _.parse(format("(sin(2*({0})))/2", a));
      }, sinAsinBtransform = core.Utils.cosAsinBtranform = function(symbol1, symbol2) {
        var a, b;
        a = symbol1.args[0];
        b = symbol2.args[0];
        return _.parse(format("(cos(({0})+({1}))-cos(({0})-({1})))/2", a, b));
      }, trigTransform = core.Utils.trigTransform = function(arr) {
        var map = {}, symbol, t, retval = new Symbol(1);
        for (var i = 0, l = arr.length; i < l; i++) {
          symbol = arr[i];
          if (symbol.group === FN) {
            var fname = symbol.fname;
            if (fname === COS && map[SIN]) {
              if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {
                t = cosAsinBtransform(symbol, map[SIN]);
              } else {
                t = cosAsinAtransform(symbol, map[SIN]);
              }
              delete map[SIN];
              retval = _.multiply(retval, t);
            } else if (fname === SIN && map[COS]) {
              if (map[COS].args[0].toString() !== symbol.args[0].toString()) {
                t = cosAsinBtransform(symbol, map[COS]);
              } else {
                t = cosAsinAtransform(symbol, map[COS]);
              }
              delete map[COS];
              retval = _.multiply(retval, t);
            } else if (fname === SIN && map[SIN]) {
              if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {
                t = sinAsinBtransform(symbol, map[SIN]);
                delete map[SIN];
              } else {
                t = _.multiply(symbol, map[SIN]);
                delete map[SIN];
              }
              retval = t;
            } else {
              map[fname] = symbol;
            }
          } else
            retval = _.multiply(retval, symbol);
        }
        for (var x in map)
          retval = _.multiply(retval, map[x]);
        return retval;
      };
      core.Settings.integration_depth = 10;
      core.Settings.max_lim_depth = 10;
      var __ = core.Calculus = {
        version: "1.4.6",
        sum: function(fn, index, start, end) {
          if (!(index.group === core.groups.S))
            throw new core.exceptions.NerdamerTypeError("Index must be symbol. " + text(index) + " provided");
          index = index.value;
          var retval;
          if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {
            var modifier = end - start < 200 ? "" : "PARSE2NUMBER";
            start = Number(start);
            end = Number(end);
            retval = core.Utils.block(modifier, function() {
              var f = fn.text(), subs = { "~": true }, retval2 = new core.Symbol(0);
              for (var i = start; i <= end; i++) {
                subs[index] = new Symbol(i);
                var ans = _.parse(f, subs);
                retval2 = _.add(retval2, ans);
              }
              return retval2;
            });
          } else {
            retval = _.symfunction("sum", arguments);
          }
          return retval;
        },
        product: function(fn, index, start, end) {
          if (!(index.group === core.groups.S))
            throw new core.exceptions.NerdamerTypeError("Index must be symbol. " + text(index) + " provided");
          index = index.value;
          var retval;
          if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {
            var modifier = end - start < 200 ? "" : "PARSE2NUMBER";
            retval = core.Utils.block(modifier, function() {
              start = Number(start);
              end = Number(end.multiplier);
              var f = fn.text(), subs = {}, retval2 = new core.Symbol(1);
              for (var i = start; i <= end; i++) {
                subs[index] = new Symbol(i);
                retval2 = _.multiply(retval2, _.parse(f, subs));
              }
              return retval2;
            });
          } else {
            retval = _.symfunction("product", arguments);
          }
          return retval;
        },
        diff: function(symbol, wrt, nth) {
          if (core.Utils.isVector(symbol)) {
            var vector = new core.Vector([]);
            symbol.each(function(x) {
              vector.elements.push(__.diff(x, wrt, nth));
            });
            return vector;
          } else if (core.Utils.isMatrix(symbol)) {
            var matrix = new core.Matrix();
            symbol.each(function(x, i, j) {
              matrix.set(i, j, __.diff(x, wrt, nth));
            });
            return matrix;
          }
          var d = isSymbol(wrt) ? wrt.text() : wrt;
          nth = isSymbol(nth) ? nth.multiplier : nth || 1;
          if (d === void 0)
            d = core.Utils.variables(symbol)[0];
          if (symbol.group === FN && symbol.fname === SQRT) {
            var s = symbol.args[0], sp = symbol.power.clone();
            if (s.group !== N || s.group !== P) {
              s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);
              s.multiplier = s.multiplier.multiply(symbol.multiplier);
            }
            symbol = s;
          }
          if (symbol.group === FN && !isSymbol(symbol.power)) {
            var a = derive(_.parse(symbol));
            var b = __.diff(symbol.args[0].clone(), d);
            symbol = _.multiply(a, b);
          } else {
            symbol = derive(symbol);
          }
          if (nth > 1) {
            nth--;
            symbol = __.diff(symbol, wrt, nth);
          }
          return symbol;
          function polydiff(symbol2) {
            if (symbol2.value === d || symbol2.contains(d, true)) {
              symbol2.multiplier = symbol2.multiplier.multiply(symbol2.power);
              symbol2.power = symbol2.power.subtract(new Frac(1));
              if (symbol2.power.equals(0)) {
                symbol2 = Symbol(symbol2.multiplier);
              }
            }
            return symbol2;
          }
          function derive(symbol2) {
            var g = symbol2.group, a2, b2, cp;
            if (g === N || g === S && symbol2.value !== d || g === P) {
              symbol2 = Symbol(0);
            } else if (g === S) {
              symbol2 = polydiff(symbol2);
            } else if (g === CB) {
              var m = symbol2.multiplier.clone();
              symbol2.toUnitMultiplier();
              var retval = _.multiply(product_rule(symbol2), polydiff(symbol2));
              retval.multiplier = retval.multiplier.multiply(m);
              return retval;
            } else if (g === FN && symbol2.power.equals(1)) {
              switch (symbol2.fname) {
                case LOG:
                  cp = symbol2.clone();
                  symbol2 = symbol2.args[0].clone();
                  symbol2.power = symbol2.power.negate();
                  symbol2.multiplier = cp.multiplier.divide(symbol2.multiplier);
                  break;
                case COS:
                  symbol2.fname = SIN;
                  symbol2.multiplier.negate();
                  break;
                case SIN:
                  symbol2.fname = COS;
                  break;
                case TAN:
                  symbol2.fname = SEC;
                  symbol2.power = new Frac(2);
                  break;
                case SEC:
                  symbol2 = qdiff(symbol2, TAN);
                  break;
                case CSC:
                  symbol2 = qdiff(symbol2, "-cot");
                  break;
                case COT:
                  symbol2.fname = CSC;
                  symbol2.multiplier.negate();
                  symbol2.power = new Frac(2);
                  break;
                case ASIN:
                  symbol2 = _.parse("(sqrt(1-(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case ACOS:
                  symbol2 = _.parse("-(sqrt(1-(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case ATAN:
                  symbol2 = _.parse("(1+(" + text(symbol2.args[0]) + ")^2)^(-1)");
                  break;
                case ABS:
                  m = symbol2.multiplier.clone();
                  symbol2.toUnitMultiplier();
                  b2 = symbol2.args[0].clone();
                  b2.toUnitMultiplier();
                  symbol2 = _.parse(inBrackets(text(symbol2.args[0])) + "/abs" + inBrackets(text(b2)));
                  symbol2.multiplier = m;
                  break;
                case "parens":
                  symbol2 = Symbol(1);
                  break;
                case "cosh":
                  symbol2.fname = "sinh";
                  break;
                case "sinh":
                  symbol2.fname = "cosh";
                  break;
                case TANH:
                  symbol2.fname = SECH;
                  symbol2.power = new Frac(2);
                  break;
                case SECH:
                  symbol2 = qdiff(symbol2, "-tanh");
                  break;
                case CSCH:
                  var arg = String(symbol2.args[0]);
                  return _.parse("-coth(" + arg + ")*csch(" + arg + ")");
                  break;
                case COTH:
                  var arg = String(symbol2.args[0]);
                  return _.parse("-csch(" + arg + ")^2");
                  break;
                case "asinh":
                  symbol2 = _.parse("(sqrt(1+(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case "acosh":
                  symbol2 = _.parse("(sqrt(-1+(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case "atanh":
                  symbol2 = _.parse("(1-(" + text(symbol2.args[0]) + ")^2)^(-1)");
                  break;
                case ASECH:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("-1/(sqrt(1/(" + arg + ")^2-1)*(" + arg + ")^2)");
                  break;
                case ACOTH:
                  symbol2 = _.parse("-1/((" + symbol2.args[0] + ")^2-1)");
                  break;
                case ACSCH:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("-1/(sqrt(1/(" + arg + ")^2+1)*(" + arg + ")^2)");
                  break;
                case ASEC:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("1/(sqrt(1-1/(" + arg + ")^2)*(" + arg + ")^2)");
                  break;
                case ACSC:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("-1/(sqrt(1-1/(" + arg + ")^2)*(" + arg + ")^2)");
                  break;
                case ACOT:
                  symbol2 = _.parse("-1/((" + symbol2.args[0] + ")^2+1)");
                  break;
                case "S":
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("sin((pi*(" + arg + ")^2)/2)");
                  break;
                case "C":
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("cos((pi*(" + arg + ")^2)/2)");
                  break;
                case "Si":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("sin(" + arg + ")/(" + arg + ")");
                  break;
                case "Shi":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("sinh(" + arg + ")/(" + arg + ")");
                  break;
                case "Ci":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("cos(" + arg + ")/(" + arg + ")");
                  break;
                case "Chi":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("cosh(" + arg + ")/(" + arg + ")");
                  break;
                case "Ei":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("e^(" + arg + ")/(" + arg + ")");
                  break;
                case "Li":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("1/" + Settings.LOG + "(" + arg + ")");
                  break;
                case "erf":
                  symbol2 = _.parse("(2*e^(-(" + symbol2.args[0] + ")^2))/sqrt(pi)");
                  break;
                case "atan2":
                  var x_ = String(symbol2.args[0]), y_ = String(symbol2.args[1]);
                  symbol2 = _.parse("(" + y_ + ")/((" + y_ + ")^2+(" + x_ + ")^2)");
                  break;
                case "sign":
                  symbol2 = new Symbol(0);
                  break;
                case "sinc":
                  symbol2 = _.parse(format("(({0})*cos({0})-sin({0}))*({0})^(-2)", symbol2.args[0]));
                  break;
                case Settings.LOG10:
                  symbol2 = _.parse("1/((" + symbol2.args[0] + ")*" + Settings.LOG + "(10))");
                  break;
                default:
                  symbol2 = _.symfunction("diff", [symbol2, wrt]);
              }
            } else if (g === EX || g === FN && isSymbol(symbol2.power)) {
              var value;
              if (g === EX) {
                value = symbol2.value;
              } else if (g === FN && symbol2.contains(d)) {
                value = symbol2.fname + inBrackets(text(symbol2.args[0]));
              } else {
                value = symbol2.value + inBrackets(text(symbol2.args[0]));
              }
              a2 = _.multiply(_.parse(LOG + inBrackets(value)), symbol2.power.clone());
              b2 = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol2.power.clone()), d);
              symbol2 = _.multiply(symbol2, b2);
            } else if (g === FN && !symbol2.power.equals(1)) {
              b2 = symbol2.clone();
              b2.toLinear();
              b2.toUnitMultiplier();
              symbol2 = _.multiply(polydiff(symbol2.clone()), derive(b2));
            } else if (g === CP || g === PL) {
              var c = symbol2.clone();
              var result = new Symbol(0);
              for (var x in symbol2.symbols) {
                result = _.add(result, __.diff(symbol2.symbols[x].clone(), d));
              }
              symbol2 = _.multiply(polydiff(c), result);
            }
            symbol2.updateHash();
            return symbol2;
          }
          ;
          function qdiff(symbol2, val, altVal) {
            return _.multiply(symbol2, _.parse(val + inBrackets(altVal || text(symbol2.args[0]))));
          }
          ;
          function product_rule(symbol2) {
            var symbols = symbol2.collectSymbols(), result = new Symbol(0), l = symbols.length;
            for (var i = 0; i < l; i++) {
              var df = __.diff(symbols[i].clone(), d);
              for (var j = 0; j < l; j++) {
                if (i !== j) {
                  df = _.multiply(df, symbols[j].clone());
                }
              }
              result = _.add(result, df);
            }
            return result;
          }
          ;
        },
        integration: {
          u_substitution: function(symbols, dx) {
            function try_combo(a2, b2, f3) {
              var d = __.diff(b2, dx);
              var q = f3 ? f3(a2, b2) : _.divide(a2.clone(), d);
              if (!q.contains(dx, true))
                return q;
              return null;
            }
            function do_fn_sub(fname, arg2) {
              var subbed = __.integrate(_.symfunction(fname, [new Symbol(u)]), u, 0);
              subbed = subbed.sub(new Symbol(u), arg2);
              subbed.updateHash();
              return subbed;
            }
            var a = symbols[0].clone(), b = symbols[1].clone(), g1 = a.group, g2 = b.group, u = "__u__", Q;
            if (g1 === FN && g2 !== FN) {
              var arg = a.args[0];
              Q = try_combo(b, arg.clone());
              if (Q)
                return _.multiply(Q, do_fn_sub(a.fname, arg));
              Q = try_combo(b, a);
              if (Q) {
                return __.integration.poly_integrate(a);
              }
            } else if (g2 === FN && g1 !== FN) {
              var arg = b.args[0];
              Q = try_combo(a, arg.clone());
              if (Q)
                return _.multiply(Q, do_fn_sub(b.fname, arg));
            } else if (g1 === FN && g2 === FN) {
              Q = try_combo(a.clone(), b.clone());
              if (Q)
                return _.multiply(__.integration.poly_integrate(b), Q);
              Q = try_combo(b.clone(), a.clone());
              if (Q)
                return _.multiply(__.integration.poly_integrate(b), Q);
            } else if (g1 === EX && g2 !== EX) {
              var p = a.power;
              Q = try_combo(b, p.clone());
              if (!Q) {
                var dc = __.integration.decompose_arg(p.clone(), dx);
                var xp = __.diff(dc[2].clone(), dx);
                var dc2 = __.integration.decompose_arg(xp.clone(), dx);
                if (_.multiply(dc[1], dc2[1]).power.equals(b.power)) {
                  var m = _.divide(dc[0].clone(), dc2[0].clone());
                  var new_val = _.multiply(m.clone(), _.pow(new Symbol(a.value), _.multiply(dc[0], new Symbol(u))));
                  new_val = _.multiply(new_val, new Symbol(u));
                  return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());
                }
              }
              var integrated = __.integrate(a.sub(p.clone(), new Symbol(u)), u, 0), retval = _.multiply(integrated.sub(new Symbol(u), p), Q);
              return retval;
            } else if (g2 === EX && g1 !== EX) {
              var p = b.power;
              Q = try_combo(a, p.clone());
              var integrated = __.integrate(b.sub(p, new Symbol(u)), u, 0);
              return _.multiply(integrated.sub(new Symbol(u), p), Q);
            } else if (a.isComposite() || b.isComposite()) {
              var f = function(a2, b2) {
                var d = __.diff(b2, dx);
                var A = core.Algebra.Factor.factor(a2), B = core.Algebra.Factor.factor(d);
                var q = _.divide(A, B);
                return q;
              };
              var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(), f2 = b.isComposite() ? b.clone().toLinear() : b.clone();
              Q = try_combo(f1.clone(), f2.clone(), f);
              if (Q)
                return _.multiply(__.integration.poly_integrate(b), Q);
              Q = try_combo(f2.clone(), f1.clone(), f);
              if (Q)
                return _.multiply(__.integration.poly_integrate(a), Q);
            }
          },
          //simple integration of a single polynomial x^(n+1)/(n+1)
          poly_integrate: function(x) {
            var p = x.power.toString(), m = x.multiplier.toDecimal(), s = x.toUnitMultiplier().toLinear();
            if (Number(p) === -1) {
              return _.multiply(new Symbol(m), _.symfunction(LOG, [s]));
            }
            return _.parse(format("({0})*({1})^(({2})+1)/(({2})+1)", m, s, p));
          },
          //If we're just spinning wheels we want to stop. This is why we 
          //wrap integration in a try catch block and call this to stop.
          stop: function(msg) {
            msg = msg || "Unable to compute integral!";
            core.Utils.warn(msg);
            throw new NoIntegralFound(msg);
          },
          partial_fraction: function(input, dx, depth, opt) {
            if (!isSymbol(dx))
              dx = _.parse(dx);
            var result, partial_fractions;
            result = new Symbol(0);
            partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);
            if (partial_fractions.group === CB && partial_fractions.isLinear()) {
              partial_fractions.each(function(x) {
                if (!x.isLinear())
                  __.integration.stop();
              });
              partial_fractions.each(function(x) {
                result = _.add(result, __.integrate(x, dx, depth, opt));
              });
            } else {
              result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));
            }
            return result;
          },
          get_udv: function(symbol) {
            var parts = [[
              /*L*/
            ], [
              /*I*/
            ], [
              /*A*/
            ], [
              /*T*/
            ], [
              /*E*/
            ]];
            var setSymbol = function(x) {
              var g = x.group;
              if (g === FN) {
                var fname = x.fname;
                if (core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))
                  parts[3].push(x);
                else if (core.Utils.in_inverse_trig(fname))
                  parts[1].push(x);
                else if (fname === LOG)
                  parts[0].push(x);
                else {
                  __.integration.stop();
                }
              } else if (g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {
                parts[2].push(x);
              } else if (g === EX || x.isComposite() && !x.isLinear())
                parts[4].push(x);
              else
                __.integration.stop();
            };
            if (symbol.group === CB)
              symbol.each(function(x) {
                setSymbol(Symbol.unwrapSQRT(x, true));
              });
            else
              setSymbol(symbol);
            var u, dv = new Symbol(1);
            for (var i = 0; i < 5; i++) {
              var part = parts[i], t, l = part.length;
              if (l > 0) {
                if (l > 1) {
                  t = new Symbol(1);
                  for (var j = 0; j < l; j++)
                    t = _.multiply(t, part[j].clone());
                } else
                  t = part[0].clone();
                if (!u) {
                  u = t;
                  u.multiplier = u.multiplier.multiply(symbol.multiplier);
                } else
                  dv = _.multiply(dv, t);
              }
            }
            return [u, dv];
          },
          trig_sub: function(symbol, dx, depth, opt, parts, symbols) {
            parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);
            var b = parts[3], ax = parts[2], a = parts[0], x = parts[1];
            if (x.power.equals(2) && a.greaterThan(0)) {
              var t = core.Utils.getU(symbol), u = _.parse(TAN + inBrackets(t)), du = _.parse(SEC + inBrackets(t) + "^2"), f = _.multiply(symbol.sub(x, u), du);
              var integral = __.integrate(f, t, depth, opt).sub(u, x);
              core.Utils.clearU(u);
              return integral;
            }
          },
          by_parts: function(symbol, dx, depth, o) {
            o.previous = o.previous || [];
            var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;
            udv = __.integration.get_udv(symbol);
            u = udv[0];
            dv = udv[1];
            du = Symbol.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);
            c = du.clone().stripVar(dx);
            du = _.divide(du, c.clone());
            v = __.integrate(dv.clone(), dx, depth || 0);
            vdu = _.multiply(v.clone(), du);
            vdu_s = vdu.toString();
            if (o.previous.indexOf(vdu_s) !== -1 && core.Utils.in_trig(u.fname) && dv.isE()) {
              o.is_cyclic = true;
              return new Symbol(1);
            } else
              o.previous.push(vdu_s);
            uv = _.multiply(u, v);
            m = vdu.multiplier.clone();
            vdu.toUnitMultiplier();
            integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);
            integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);
            retval = _.subtract(uv, integral_vdu);
            if (o.is_cyclic) {
              o.previous.pop();
              if (o.previous.length === 0) {
                retval = _.expand(retval);
                var rem = new Symbol(0);
                retval.each(function(x) {
                  if (!x.contains(dx))
                    rem = _.add(rem, x.clone());
                });
                retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol(1), rem));
              }
            }
            return retval;
          },
          /*
           * dependents: [Solve, integrate]
           */
          decompose_arg: core.Utils.decompose_fn
        },
        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output
        integrate: function(original_symbol, dt, depth, opt) {
          if (!dt) {
            var vars = core.Utils.variables(original_symbol);
            if (vars.length === 1)
              dt = vars[0];
            dt = dt || "x";
          }
          if (core.Utils.isVector(original_symbol)) {
            var vector = new core.Vector([]);
            original_symbol.each(function(x) {
              vector.elements.push(__.integrate(x, dt));
            });
            return vector;
          }
          if (!isNaN(dt))
            _.error("variable expected but received " + dt);
          if (original_symbol.isConstant(true))
            return _.multiply(original_symbol.clone(), _.parse(dt));
          opt = opt || {};
          return core.Utils.block("PARSE2NUMBER", function() {
            depth = depth || 0;
            var dx = isSymbol(dt) ? dt.toString() : dt, symbol = Symbol.unwrapSQRT(original_symbol.clone(), true), g = symbol.group, retval;
            try {
              if (++depth > core.Settings.integration_depth)
                __.integration.stop("Maximum depth reached. Exiting!");
              if (!symbol.contains(dx, true)) {
                retval = _.multiply(symbol.clone(), _.parse(dx));
              } else if (g === S) {
                retval = __.integration.poly_integrate(symbol, dx, depth);
              } else if (g === EX) {
                if (symbol.previousGroup === FN && !(symbol.fname === "sqrt" || symbol.fname === Settings.PARENTHESIS))
                  __.integration.stop();
                if (symbol.contains(dx) && symbol.previousGroup !== FN) {
                  if (symbol.power.contains(dx))
                    __.integration.stop();
                  else {
                    var t = __.diff(symbol.clone().toLinear(), dx);
                    if (t.contains(dx))
                      __.integration.stop();
                    retval = __.integration.poly_integrate(symbol, dx, depth);
                  }
                } else {
                  var a = __.diff(symbol.power.clone(), dx);
                  if (a.contains(dx)) {
                    var aa = a.stripVar(dx), x = _.divide(a.clone(), aa.clone());
                    if (x.group === S && x.isLinear()) {
                      aa.multiplier = aa.multiplier.divide(new Frac(2));
                      return _.parse(format("({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))", aa, dx, symbol.multiplier));
                    } else
                      __.integration.stop();
                  }
                  if (symbol.isE()) {
                    if (a.isLinear())
                      retval = symbol;
                    else {
                      if (a.isE() && a.power.group === S && a.power.power.equals(1))
                        retval = _.multiply(_.symfunction("Ei", [symbol.power.clone()]), symbol.power);
                      else
                        __.integration.stop();
                    }
                  } else {
                    var d = _.symfunction(LOG, [_.parse(symbol.value)]);
                    retval = _.divide(symbol, d);
                  }
                  retval = _.divide(retval, a);
                }
              } else if (symbol.isComposite() && symbol.isLinear()) {
                var m = _.parse(symbol.multiplier);
                symbol.toUnitMultiplier();
                retval = new Symbol(0);
                symbol.each(function(x2) {
                  retval = _.add(retval, __.integrate(x2, dx, depth));
                });
                retval = _.multiply(m, retval);
              } else if (g === CP) {
                if (symbol.power.greaterThan(1))
                  symbol = _.expand(symbol);
                if (symbol.power.equals(1)) {
                  retval = new Symbol(0);
                  symbol.each(function(x2) {
                    retval = _.add(retval, __.integrate(x2, dx, depth));
                  }, true);
                } else {
                  var p = Number(symbol.power), m = symbol.multiplier.clone();
                  symbol.toUnitMultiplier();
                  var fn = symbol.clone().toLinear(), decomp = __.integration.decompose_arg(fn, dx), b = decomp[3], ax = decomp[2], a = decomp[0], x = decomp[1];
                  if (p === -1 && x.group !== PL && x.power.equals(2)) {
                    var b_is_positive = isInt(b) ? b > 0 : true;
                    if (x.group === S && x.power.equals(2) && b_is_positive) {
                      var unwrapAbs = function(s) {
                        var result = new Symbol(1);
                        s.each(function(x2) {
                          result = _.multiply(result, x2.fname === "abs" ? x2.args[0] : x2);
                        });
                        return result;
                      };
                      var A = a.clone(), B = b.clone();
                      A = _.pow(A, new Symbol(1 / 2));
                      B = _.pow(B, new Symbol(1 / 2));
                      var d = _.multiply(unwrapAbs(B), unwrapAbs(A)), f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);
                      retval = _.divide(f, d);
                    } else if (x.group === S && x.isLinear()) {
                      retval = _.divide(__.integration.poly_integrate(symbol), a);
                    } else {
                      if (x.power.equals(4)) {
                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;
                        var br = inBrackets;
                        A = _.parse(SQRT + br(a) + "*" + dx + "^2");
                        B = _.parse(SQRT + br(2) + "*" + br(a) + "^" + br("1/4") + "*" + br(b) + "^" + br("1/4") + "*" + dx);
                        C = _.parse(SQRT + br(b));
                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());
                        f2 = _.add(_.subtract(A, B), C);
                        D = _.parse(SQRT + br(2) + "*" + br(b) + "^" + br("3/4"));
                        E = _.parse(SQRT + br(b) + "*" + br(b) + "^" + br("1/4") + "*" + dx);
                        F = _.parse("2*" + br(b) + "*" + SQRT + br(2) + "*" + br(b) + "^" + br("1/4"));
                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));
                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));
                        retval = _.add(
                          __.integrate(L1, dx, depth, opt),
                          __.integrate(L2, dx, depth, opt)
                        );
                      } else
                        retval = __.integration.partial_fraction(symbol, dx, depth);
                    }
                  } else if (p === -1 / 2) {
                    if (x.group === S && x.power.equals(2)) {
                      if (ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {
                        a.negate();
                        if (b.isConstant() && a.isConstant()) {
                          var d = _.symfunction(SQRT, [a.clone()]), d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);
                          retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);
                        } else {
                          var sqrt_a = _.symfunction(SQRT, [a]), sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());
                          retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);
                        }
                      } else {
                        __.integration.stop();
                      }
                    } else {
                      __.integration.stop();
                    }
                  } else if (p === 1 / 2 && x.power.equals(2) && a.greaterThan(0)) {
                    __.integration.stop();
                  } else {
                    if (x.isLinear() && x.group !== PL)
                      retval = _.divide(__.integration.poly_integrate(symbol), a);
                    else if (x.power.equals(2) && a.greaterThan(0)) {
                      var sqa, sqb, aob, bsqi, n, integral, u, v, uv;
                      sqa = _.parse(SQRT + inBrackets(a));
                      sqb = _.parse(SQRT + inBrackets(b));
                      aob = _.multiply(sqa.clone(), sqb.clone()).invert();
                      bsqi = _.pow(b, new Symbol(symbol.power));
                      uv = core.Utils.getU(symbol);
                      u = _.multiply(aob, x.clone().toLinear());
                      v = _.parse(ATAN + inBrackets(u));
                      var n = (Math.abs(symbol.power) - 1) * 2;
                      var integral = __.integrate(_.parse(COS + inBrackets(uv) + "^" + n));
                      core.Utils.clearU(uv);
                      return _.multiply(integral.sub(uv, v), bsqi);
                    } else {
                      if (symbol.group !== CB && !symbol.power.lessThan(0)) {
                        retval = __.integration.by_parts(symbol, dx, depth, opt);
                      } else {
                        var f = symbol.clone().toLinear();
                        var factored = core.Algebra.Factor.factor(f);
                        var was_factored = factored.toString() !== f.toString();
                        if (core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {
                          try {
                            var f1, fx, u, sq;
                            sq = core.Algebra.sqComplete(f, dx);
                            u = core.Utils.getU(f);
                            f1 = sq.f.sub(sq.a, u);
                            fx = _.pow(f1, _.parse(symbol.power));
                            retval = __.integrate(fx, u).sub(u, sq.a);
                          } catch (e) {
                            __.integration.stop();
                          }
                        } else
                          retval = __.integration.partial_fraction(symbol, dx, depth, opt);
                      }
                    }
                  }
                  retval.multiplier = retval.multiplier.multiply(m);
                }
              } else if (g === FN) {
                var arg = symbol.args[0], m = symbol.multiplier.clone();
                symbol.toUnitMultiplier();
                var decomp = __.integration.decompose_arg(arg, dx);
                var a = decomp[0], x = decomp[1], fname = symbol.fname;
                if (fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {
                  var p = symbol.power.toString();
                  if (isInt(p))
                    depth = depth - p;
                  if (!arg.isComposite())
                    retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));
                  else {
                    var u = core.Utils.getU(symbol);
                    var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol(p));
                    var du = __.diff(arg, dx);
                    var u_du = _.multiply(f, du);
                    var integral = __.integrate(u_du, u, depth, opt);
                    retval = _.multiply(_.parse(m), integral.sub(u, arg));
                  }
                } else if (fname === TAN && symbol.power.lessThan(0)) {
                  var sym = symbol.clone();
                  sym.power.negate();
                  sym.fname = COT;
                  return _.multiply(_.parse(m), __.integrate(sym, dx, depth));
                } else {
                  if (!a.contains(dx, true) && symbol.isLinear()) {
                    if (fname === ABS) {
                      var x = _.divide(arg.clone(), a.clone());
                      if (x.group === S && !x.power.lessThan(0)) {
                        if (core.Utils.even(x.power)) {
                          retval = __.integrate(arg, dx, depth);
                        } else {
                          var integrated = __.integrate(x, dx, depth);
                          integrated.power = integrated.power.subtract(new Frac(1));
                          retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);
                        }
                      } else
                        __.integration.stop();
                    } else {
                      var ag = symbol.args[0].group, decomposed = __.integration.decompose_arg(arg, dx);
                      if (!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())
                        __.integration.stop();
                      switch (fname) {
                        case COS:
                          retval = _.symfunction(SIN, [arg]);
                          break;
                        case SIN:
                          retval = _.symfunction(COS, [arg]);
                          retval.negate();
                          break;
                        case TAN:
                          retval = _.parse(format(Settings.LOG + "(sec({0}))", arg));
                          break;
                        case SEC:
                          retval = _.parse(format(Settings.LOG + "(tan({0})+sec({0}))", arg));
                          break;
                        case CSC:
                          retval = _.parse(format("-" + Settings.LOG + "(csc({0})+cot({0}))", arg));
                          break;
                        case COT:
                          retval = _.parse(format(Settings.LOG + "(sin({0}))", arg));
                          break;
                        case SINH:
                          retval = _.symfunction(COSH, [arg]);
                          break;
                        case COSH:
                          retval = _.symfunction(SINH, [arg]);
                          break;
                        case TANH:
                          retval = _.parse(format(Settings.LOG + "(cosh({0}))", arg));
                          break;
                        case ASEC:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACSC:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACOT:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ASECH:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACSCH:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACOTH:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case SECH:
                          retval = _.parse(format("atan(sinh({0}))", arg));
                          break;
                        case CSCH:
                          retval = _.parse(format(Settings.LOG + "(tanh(({0})/2))", arg));
                          break;
                        case COTH:
                          retval = _.parse(format(Settings.LOG + "(sinh({0}))", arg));
                          break;
                        case EXP:
                          retval = __.integrate(_.parse(format("e^({0})", arg)), dx, depth);
                          break;
                        case "S":
                          var arg = symbol.args[0].clone(), dc = __.integration.decompose_arg(arg, dx), x_ = dc[1], a_ = dc[0];
                          var b_ = dc[3];
                          retval = _.parse(format("(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)", a_, b_, x));
                          break;
                        case "C":
                          var arg = symbol.args[0].clone(), dc = __.integration.decompose_arg(arg, dx), x_ = dc[1], a_ = dc[0];
                          var b_ = dc[3];
                          retval = _.parse(format("(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)", a_, b_, x_));
                          break;
                        case "erf":
                          var arg = symbol.args[0].clone(), dc = __.integration.decompose_arg(arg, dx), x_ = dc[1], a_ = dc[0];
                          retval = _.parse(format("e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))", a_, x_, arg));
                          break;
                        case "sign":
                          retval = _.multiply(symbol.clone(), arg.clone());
                          break;
                        default:
                          __.integration.stop();
                      }
                      retval = _.divide(retval, a);
                    }
                  } else if (x.isLinear()) {
                    if (fname === COS || fname === SIN) {
                      var p = Number(symbol.power);
                      if (p < 0) {
                        symbol.fname = fname === SIN ? CSC : SEC;
                        symbol.invert().updateHash();
                        retval = __.integrate(symbol, dx, depth);
                      } else {
                        var arg = symbol.args[0], rd = symbol.clone(), rd2 = symbol.clone(), q = new Symbol((p - 1) / p), na = _.multiply(a.clone(), new Symbol(p)).invert();
                        rd.power = rd.power.subtract(new Frac(1));
                        rd2.power = rd2.power.subtract(new Frac(2));
                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);
                        if (fname === SIN)
                          t.negate();
                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));
                      }
                    } else if (fname === TAN || fname === COT) {
                      if (symbol.args[0].isLinear(dx)) {
                        var n = symbol.power.subtract(new Frac(1)).toString(), r = symbol.clone().toUnitMultiplier(), w = _.parse(format((fname === COT ? "-" : "") + "1/({2}*{0})*{3}({1})^({0})", n, arg, a, fname));
                        r.power = r.power.subtract(new Frac(2));
                        if (r.power.equals(0))
                          r = _.parse(r);
                        retval = _.subtract(w, __.integrate(r, dx, depth));
                      }
                    } else if (fname === SEC || fname === CSC) {
                      var n1 = symbol.power.subtract(new Frac(1)).toString(), n2 = symbol.power.subtract(new Frac(2)).toString(), f2 = fname === SEC ? TAN : COT, r = symbol.clone().toUnitMultiplier(), parse_str = format((fname === CSC ? "-" : "") + "1/({0}*{1})*{4}({3})^({2})*{5}({3})", a, n1, n2, arg, fname, f2), w = _.parse(parse_str);
                      r.power = r.power.subtract(new Frac(2));
                      if (r.power.equals(0))
                        r = _.parse(r);
                      retval = _.add(w, _.multiply(new Symbol(n2 / n1), __.integrate(r, dx, depth)));
                    } else if ((fname === COSH || fname === SINH) && symbol.power.equals(2)) {
                      retval = __.integrate(symbol.fnTransform(), dx, depth);
                    } else
                      __.integration.stop();
                  } else
                    __.integration.stop();
                  retval.multiplier = retval.multiplier.multiply(m);
                }
              } else if (g === PL) {
                retval = __.integration.partial_fraction(symbol, dx, depth);
              } else if (g === CB) {
                var den = symbol.getDenom();
                if (den.group === S)
                  symbol = _.expand(symbol);
                var coeff = symbol.stripVar(dx);
                var cfsymbol = _.divide(symbol.clone(), coeff.clone());
                if (coeff.contains(dx)) {
                  cfsymbol = _.multiply(cfsymbol, coeff);
                  coeff = new Symbol(1);
                }
                if (cfsymbol.group !== CB) {
                  if (cfsymbol.equals(1)) {
                    return __.integrate(_.expand(symbol), dx, depth);
                  }
                  if (cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {
                    cfsymbol = core.Algebra.Factor.factor(cfsymbol);
                  }
                  retval = __.integrate(cfsymbol, dx, depth);
                } else {
                  var symbols = cfsymbol.collectSymbols().sort(function(a2, b2) {
                    if (a2.group === b2.group) {
                      if (Number(a2.power) === Number(b2.power))
                        if (a2 < b2)
                          return 1;
                        else
                          return -1;
                      return b2.power - a2.power;
                    }
                    return b2.group - a2.group;
                  }).map(function(x2) {
                    var unwrapped = Symbol.unwrapSQRT(x2, true);
                    if (unwrapped.fname === EXP) {
                      return _.parse(format("({1})*e^({0})", unwrapped.args[0], unwrapped.multiplier));
                    }
                    return unwrapped;
                  });
                  var l = symbols.length;
                  if (symbol.power < 0) {
                    if (l === 2) {
                      return __.integrate(_.expand(symbol), dx, depth, opt);
                    }
                  } else {
                    if (l === 2) {
                      try {
                        retval = __.integration.u_substitution(symbols, dx);
                      } catch (e) {
                        ;
                      }
                      if (!retval) {
                        var g1 = symbols[0].group, g2 = symbols[1].group, sym1 = symbols[0], sym2 = symbols[1], fn1 = sym1.fname, fn2 = sym2.fname;
                        symbol = _.multiply(sym1.clone(), sym2.clone());
                        if (g1 === FN && g2 === FN) {
                          if (fn1 === LOG || fn2 === LOG) {
                            retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);
                          } else {
                            symbols.sort(function(a2, b2) {
                              return b2.fname > a2.fname;
                            });
                            var arg1 = sym1.args[0];
                            if (!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))
                              __.integration.stop();
                            var decomp = __.integration.decompose_arg(arg1, dx);
                            x = decomp[1], a = decomp[0];
                            if (!x.isLinear())
                              __.integration.stop();
                            var arg2 = sym2.args[0];
                            if (arg1.equals(arg2)) {
                              if (fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {
                                if (sym1.power.lessThan(0))
                                  __.integration.stop();
                                if (fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {
                                  sym1.fname = TAN;
                                  sym1.updateHash();
                                  retval = __.integrate(sym1, dx, depth);
                                } else {
                                  if (even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {
                                    var n = Number(sym1.power) / 2, new_sym = _.parse(format("(1-cos({0})^2)^({1})", sym1.args[0], n));
                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);
                                  } else if (even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {
                                    var n = Number(sym1.power) / 2, new_sym = _.parse(format("(1-sin({0})^2)^({1})", sym1.args[0], n));
                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);
                                  } else {
                                    var p1_even = core.Utils.even(sym1.power), p2_even = core.Utils.even(sym2.power);
                                    retval = new Symbol(0);
                                    if (!p1_even || !p2_even) {
                                      var u, r, trans;
                                      if (!p1_even) {
                                        u = sym2;
                                        r = sym1;
                                      } else {
                                        u = sym1;
                                        r = sym2;
                                      }
                                      var sign = u.fname === COS ? -1 : 1, n = r.power, k = (n - 1) / 2, trans = _.parse("(1-" + u.fname + core.Utils.inBrackets(arg1) + "^2)^" + k), sym = _.expand(_.multiply(new Symbol(sign), _.multiply(u.clone(), trans)));
                                      sym.each(function(x2) {
                                        retval = _.add(retval, __.integration.poly_integrate(x2.clone()));
                                      });
                                    } else {
                                      var double_angle = function(symbol2) {
                                        var p3 = symbol2.power, k2 = p3 / 2, e;
                                        if (symbol2.fname === COS)
                                          e = "((1/2)+(cos(2*(" + symbol2.args[0] + "))/2))^" + k2;
                                        else
                                          e = "((1/2)-(cos(2*(" + symbol2.args[0] + "))/2))^" + k2;
                                        return _.parse(e);
                                      };
                                      var a = double_angle(sym1), b = double_angle(sym2), t = _.multiply(a, b);
                                      var sym = _.expand(t);
                                      sym.each(function(x2) {
                                        retval = _.add(retval, __.integrate(x2, dx, depth));
                                      });
                                      return _.multiply(retval, coeff);
                                    }
                                  }
                                }
                              } else if (fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {
                                retval = _.parse(format("sec({0})^({1})/({1})", sym1.args[0], sym1.power));
                              } else if (fn1 === TAN && fn2 === SEC && x.isLinear()) {
                                if (sym1.isLinear() && sym2.isLinear()) {
                                  retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);
                                } else if (even(sym1.power)) {
                                  var p = Number(sym1.power) / 2;
                                  var t = _.parse(format("(sec({0})^2-1)^({1})", sym1.args[0], p));
                                  retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);
                                } else
                                  __.integration.stop();
                              } else if (fn1 === SEC && fn2 === COS) {
                                sym1.fname = COS;
                                sym1.invert().updateHash();
                                retval = __.integrate(_.multiply(sym1, sym2), dx, depth);
                              } else if (fn1 === SIN && fn2 === CSC) {
                                sym2.fname = SIN;
                                sym2.invert().updateHash();
                                retval = __.integrate(_.multiply(sym1, sym2), dx, depth);
                              } else if (fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {
                                var t = _.multiply(sym1.fnTransform(), sym2);
                                retval = __.integrate(_.expand(t), dx, depth);
                              } else {
                                var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());
                                retval = __.integrate(_.expand(t), dx, depth);
                              }
                            } else if ((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {
                              if (sym1.isLinear() && sym2.isLinear()) {
                                if (sym1.args[0].isLinear() && sym2.args[0].isLinear()) {
                                  var ax, bx;
                                  if (fn2 === SIN) {
                                    ax = sym1.args[0];
                                    bx = sym2.args[0];
                                  } else {
                                    bx = sym1.args[0];
                                    ax = sym2.args[0];
                                  }
                                  f = _.parse(format("(sin(({1})+({0}))+sin(({1})-({0})))/2", ax.toString(), bx.toString()));
                                  retval = __.integrate(f, dx, depth);
                                } else {
                                  var transformed = trigTransform(symbols);
                                  retval = __.integrate(_.expand(transformed), dx, depth);
                                }
                              } else {
                                var transformed = new Symbol(1);
                                symbols.map(function(sym3) {
                                  var s = sym3.fnTransform();
                                  transformed = _.multiply(transformed, s);
                                });
                                var t = _.expand(transformed);
                                retval = __.integrate(t, dx, depth);
                                if (retval.hasIntegral()) {
                                  retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);
                                }
                              }
                            } else {
                              __.integration.stop();
                            }
                          }
                        } else if (g1 === FN && g2 === S) {
                          var sym1_is_linear = sym1.isLinear();
                          if (sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Ci", [sym1.args[0]]);
                          else if (sym1.fname === COS && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Chi", [sym1.args[0]]);
                          else if (sym1.fname === COSH && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Si", [sym1.args[0]]);
                          else if (sym1.fname === SIN && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Shi", [sym1.args[0]]);
                          else if (sym1.fname === SINH && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === LOG && sym2.power.equals(-1)) {
                            retval = __.integration.poly_integrate(sym1, dx, depth);
                          } else if (sym1.fname === "erf") {
                            if (sym2.power.equals(1)) {
                              var dc = __.integration.decompose_arg(sym1.args[0], dx), a_ = dc[0], x_ = dc[1], arg = sym1.args[0].toString();
                              retval = _.parse(format("(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)", a_, x_, arg));
                            }
                          } else {
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                          }
                        } else if (g1 === EX && g2 === S) {
                          var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;
                          if (sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {
                            retval = _.symfunction("Ei", [sym1.power.clone()]);
                          } else if (fn1 === LOG && x.value === sym2.value) {
                            retval = __.integration.poly_integrate(sym1, dx, depth);
                          } else
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                        } else if (g1 === PL && g2 === S) {
                          if (sym2.value === sym1.value && sym1.power.equals(-1)) {
                            var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));
                            var pc = Math.min(pd, sym2.power);
                            var factor = sym2.clone();
                            factor.power = new Frac(pc);
                            sym2 = _.divide(sym2, factor.clone());
                            var t = new Symbol(0);
                            sym1.each(function(x2) {
                              t = _.add(t, _.divide(x2.clone(), factor.clone()));
                            });
                            t.multiplier = sym1.multiplier;
                            symbol = _.divide(sym2, t);
                          } else {
                            symbol = _.expand(symbol);
                          }
                          retval = __.integration.partial_fraction(symbol, dx, depth);
                        } else if (g1 === CP && g2 === S) {
                          var f = sym1.clone().toLinear(), f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);
                          if (sym1.power.equals(-1 / 2)) {
                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);
                            var a = decomp[0].negate(), x = decomp[1], b = decomp[3], p1 = Number(sym1.power), p2 = Number(sym2.power);
                            if (isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {
                              var c = _.divide(
                                _.multiply(
                                  _.pow(b.clone(), new Symbol(2)),
                                  _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])
                                ),
                                _.pow(a.clone(), new Symbol(2))
                              );
                              c = _.multiply(c, _.symfunction(SQRT, [b]).invert());
                              var dummy = _.parse("sin(u)");
                              dummy.power = dummy.power.multiply(sym2.power);
                              var integral = __.integrate(dummy, "u", depth);
                              var bksub = _.parse(ASIN + "(" + SQRT + "(" + a + "/" + b + ")*" + dx + ")");
                              retval = _.multiply(c, integral.sub(new Symbol("u"), bksub));
                            } else if (p1 === -1 / 2) {
                              var u_transform = function(f5, u2) {
                                var integral2 = _.parse(__.integrate(f5, dx, depth, opt).sub(dx, format(u2, dx)));
                                if (!integral2.hasIntegral())
                                  return integral2;
                              };
                              if (p2 === -1) {
                                retval = u_transform(
                                  _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol(2)))).invert(),
                                  "sqrt(1-1/({0})^2)"
                                );
                              } else if (p2 === -2) {
                                retval = u_transform(
                                  _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol(2)).invert(), _.pow(new Symbol(dx), new Symbol(2))).negate())).invert(),
                                  "sqrt(1-1/({0})^2)"
                                );
                              }
                            }
                          } else if (sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {
                            retval = __.integration.partial_fraction(symbol, dx, depth);
                          } else if (!sym1.power.lessThan(0) && isInt(sym1.power)) {
                            var expanded = _.expand(sym1);
                            retval = new Symbol(0);
                            expanded.each(function(x2) {
                              if (x2.group === PL) {
                                x2.each(function(y) {
                                  retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));
                                });
                              } else
                                retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x2), dx, depth));
                            });
                          } else if (sym1.power.lessThan(-2)) {
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                          } else if (sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {
                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx), a = decomp[0].negate(), x = decomp[1], b = decomp[3], fn = sym1.clone().toLinear();
                            if (x.group !== PL && x.isLinear()) {
                              var p = Number(sym2.power), du = "_u_", u = new Symbol(du), U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol(p)), u.clone())), scope = {};
                              scope[du] = fn;
                              var U2 = _.parse(U, scope);
                              retval = __.integrate(U2, dx, 0);
                            } else if (sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {
                              var factors = new core.Algebra.Classes.Factors();
                              sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);
                              var div = core.Algebra.divide(sym2, sym1);
                              if (div.group !== CB) {
                                retval = new Symbol(0);
                                div.each(function(t2) {
                                  retval = _.add(retval, __.integrate(t2, dx, depth));
                                });
                                factors.each(function(factor2) {
                                  retval = _.divide(retval, factor2);
                                });
                                retval = _.expand(retval);
                              } else {
                                retval = __.integration.by_parts(symbol, dx, depth, opt);
                              }
                            } else
                              retval = __.integration.partial_fraction(symbol, dx, depth);
                          } else {
                            if (sym1.power.den.equals(2)) {
                              var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx), a = dc[3], x = dc[1], b = dc[0], bx = dc[2];
                              if (x.power.equals(2) && b.lessThan(0)) {
                                if (!a.equals(1)) {
                                  coeff = _.multiply(coeff, _.pow(a, new Symbol(2)));
                                }
                                var u = dx;
                                var c = _.divide(_.pow(b.clone().negate(), new Symbol(1 / 2)), _.pow(a, new Symbol(1 / 2))), du = _.symfunction(COS, [new Symbol(u)]), cosn = _.pow(_.symfunction(COS, [new Symbol(u)]), new Symbol(sym1.power.num)), X = _.pow(_.symfunction(SIN, [new Symbol(u)]), new Symbol(sym2.power)), val = _.multiply(_.multiply(cosn, du), X), integral = __.integrate(val, u, depth);
                                retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol(dx), c)]));
                              } else {
                                retval = __.integration.partial_fraction(symbol, dx, depth, opt);
                              }
                            } else if (f_is_linear) {
                              retval = __.integration.partial_fraction(symbol, dx, depth);
                            }
                          }
                        } else if (sym1.isComposite() && sym2.isComposite()) {
                          retval = new Symbol(0);
                          if (sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {
                            var sym = _.expand(symbol);
                            sym.each(function(x2) {
                              retval = _.add(retval, __.integrate(x2, dx, depth));
                            }, true);
                          } else {
                            var p1 = Number(sym1.power), p2 = Number(sym2.power);
                            if (p1 < 0 && p2 > 0) {
                              var t = sym1;
                              sym1 = sym2;
                              sym2 = t;
                            }
                            if (p1 === -1 && p2 === -1) {
                              retval = __.integration.partial_fraction(symbol, dx);
                            } else {
                              sym1.each(function(x2) {
                                var k2 = _.multiply(x2, sym2.clone());
                                var integral2 = __.integrate(k2, dx, depth);
                                retval = _.add(retval, integral2);
                              });
                            }
                          }
                        } else if (g1 === CP && symbols[0].power.greaterThan(0)) {
                          sym1 = _.expand(sym1);
                          retval = new Symbol(0);
                          sym1.each(function(x2) {
                            retval = _.add(retval, __.integrate(_.multiply(x2, sym2.clone()), dx, depth));
                          }, true);
                        } else if (g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {
                          sym1 = sym1.fnTransform();
                          retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);
                        } else if (g1 === FN && g2 === CP || g2 === FN && g1 === CP) {
                          if (g2 === FN && g1 === CP) {
                            var t = sym1;
                            sym1 = sym2;
                            sym2 = t;
                          }
                          var du, sym2_clone, p, q, sa, sb;
                          du = Symbol.unwrapSQRT(__.diff(sym1.clone(), dx), true);
                          sym2_clone = Symbol.unwrapSQRT(sym2, true);
                          if (du.power.equals(sym2_clone.power)) {
                            p = new Symbol(sym2.power);
                            sa = du.clone().toLinear();
                            sb = sym2.clone().toLinear();
                            q = core.Algebra.divide(sa.toLinear(), sb);
                            if (q.isConstant()) {
                              var nq = _.pow(q, p.negate());
                              retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));
                            }
                          } else {
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                          }
                        } else {
                          var syma = sym1.clone().toLinear();
                          var symb = sym2.clone().toLinear();
                          if (g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx) && !syma.contains(dx) && !symb.contains(dx)) {
                            retval = _.parse(format(
                              "(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))",
                              syma.toString(),
                              symb.toString(),
                              sym1.power.multiplier.toString(),
                              sym2.power.multiplier.toString(),
                              dx
                            ));
                          } else
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                        }
                      }
                    } else if (l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {
                      var first = symbols[0];
                      if (first.group === CP) {
                        if (first.power.greaterThan(1))
                          first = _.expand(first);
                        var r = _.multiply(symbols[1], symbols[2]);
                        retval = new Symbol(0);
                        first.each(function(x2) {
                          var t2 = _.multiply(x2, r.clone());
                          var intg = __.integrate(t2, dx, depth);
                          retval = _.add(retval, intg);
                        }, true);
                      } else {
                        retval = __.integration.by_parts(symbol, dx, depth, opt);
                      }
                    } else if (all_functions(symbols)) {
                      var t = new Symbol(1);
                      for (var i = 0, l = symbols.length; i < l; i++) {
                        t = _.multiply(t, symbols[i].fnTransform());
                      }
                      t = _.expand(t);
                      retval = __.integrate(t, dx, depth);
                    } else {
                      var transformed = trigTransform(symbols);
                      retval = __.integrate(_.expand(transformed), dx, depth);
                    }
                  }
                }
                retval = _.multiply(retval, coeff);
              }
              if (retval)
                return retval;
            } catch (error) {
              if (!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))
                throw error;
            }
            return _.symfunction("integrate", [original_symbol, dt]);
          }, false);
        },
        defint: function(symbol, from, to, dx) {
          dx = dx || "x";
          var get_value = function(integral2, vars2, point) {
            try {
              return _.parse(integral2, vars2);
            } catch (e) {
              var lim = __.Limit.limit(integral2, dx, point);
              return lim;
            }
          };
          var vars = core.Utils.variables(symbol), hasTrig = symbol.hasTrig();
          var retval, integral;
          if (vars.length === 1 && !dx)
            dx = vars[0];
          if (!hasTrig) {
            integral = __.integrate(symbol, dx);
          }
          if (!hasTrig && !integral.hasIntegral()) {
            var upper = {}, lower = {}, a, b;
            upper[dx] = to;
            lower[dx] = from;
            a = get_value(integral, upper, to, dx);
            b = get_value(integral, lower, from, dx);
            retval = _.subtract(a, b);
          } else if (vars.length === 1 && from.isConstant() && to.isConstant()) {
            var f = core.Utils.build(symbol);
            retval = new Symbol(core.Math2.num_integrate(f, Number(from), Number(to)));
          } else
            retval = _.symfunction("defint", [symbol, from, to, dx]);
          return retval;
        },
        Limit: {
          interval: function(start, end) {
            return _.parse(format("[{0}, {1}]", start, end));
          },
          diverges: function() {
            return __.Limit.interval("-Infinity", "Infinity");
          },
          divide: function(f, g, x, lim, depth) {
            if (depth++ > Settings.max_lim_depth) {
              return;
            }
            var fin = f.clone(), gin = g.clone();
            if (g.fname === ABS) {
              var sign = f.sign();
              var lim_sign = lim.sign();
              if (lim.isInfinity)
                return _.multiply(new Symbol(sign), new Symbol(lim_sign));
              else if (lim.equals(0)) {
                var fm = _.parse(f.multiplier);
                var gm = _.parse(g.multiplier);
                return _.divide(_.multiply(fm, __.Limit.interval("-1", "1")), gm);
              } else {
                __.Limit.diverges();
              }
            }
            var isInfinity = function(L) {
              if (core.Utils.isVector(L)) {
                for (var i = 0; i < L.elements.length; i++)
                  if (!L.elements[i].isInfinity)
                    return false;
                return true;
              }
              return L.isInfinity;
            };
            var equals = function(L, v) {
              if (core.Utils.isVector(L)) {
                return false;
              }
              return L.equals(v);
            };
            var retval;
            do {
              var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));
              var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));
              var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);
              if (indeterminate) {
                var ft = __.diff(f.clone(), x);
                var gt = __.diff(g.clone(), x);
                var t_symbol = _.expand(_.divide(ft, gt));
                f = t_symbol.getNum();
                g = t_symbol.getDenom();
              }
            } while (indeterminate);
            var den_is_zero = lim2.equals(0);
            var p = Number(gin.power);
            if (lim.isConstant(true) && den_is_zero) {
              retval = Symbol.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : void 0);
            } else if (den_is_zero) {
              retval = __.Limit.diverges();
            } else {
              retval = _.divide(lim1, lim2);
            }
            return retval;
          },
          rewriteToLog: function(symbol) {
            var p = symbol.power.clone();
            symbol.toLinear();
            return _.pow(new Symbol("e"), _.multiply(p, _.symfunction(Settings.LOG + "", [symbol])));
          },
          getSubbed: function(f, x, lim) {
            var retval;
            if (f.group === EX) {
              f = __.rewriteToLog(f);
            }
            try {
              retval = f.sub(x, lim);
            } catch (e) {
              retval = f;
            }
            return retval;
          },
          isInterval: function(limit) {
            return core.Utils.isVector(limit);
          },
          isConvergent: function(limit) {
            if (
              //It lies on the interval -Infinity to Infinity
              __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity || //We weren't able to calculate the limit
              limit.containsFunction("limit")
            ) {
              return false;
            }
            return true;
          },
          limit: function(symbol, x, lim, depth) {
            if (symbol.isLinear() && symbol.isComposite()) {
              var limit = new Symbol(0);
              symbol.each(function(s) {
                limit = _.add(limit, __.Limit.limit(s, x, lim, depth));
              }, true);
              return limit;
            }
            ;
            symbol = core.Algebra.Simplify.simplify(symbol);
            depth = depth || 1;
            if (depth++ > Settings.max_lim_depth) {
              return;
            }
            var m = _.parse(symbol.multiplier);
            symbol.toUnitMultiplier();
            try {
              var retval;
              if (symbol.isConstant(true)) {
                retval = symbol;
              } else {
                var point = {};
                point[x] = lim;
                try {
                  var t = _.parse(symbol.sub(x, lim), point);
                  if (t.isConstant(true) || t.isInfinity)
                    retval = t;
                } catch (e) {
                }
                ;
                if (!retval) {
                  var num = symbol.getNum();
                  var den = symbol.getDenom();
                  if (den.isConstant(true)) {
                    if (symbol.group === EX) {
                      var f = symbol.clone().toLinear();
                      var p = symbol.power.clone();
                      var _num = f.getNum();
                      var _den = f.getDenom();
                      var fn = core.Utils.decompose_fn(_den, x, true);
                      if (_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {
                        retval = _.parse(format("(1/e^({0}))", fn.b));
                      } else {
                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());
                        var pow = symbol_.power.clone();
                        var base = symbol_.clone().toLinear();
                        var lim_base = __.Limit.limit(base, x, lim, depth);
                        var lim_pow = __.Limit.limit(pow, x, lim, depth);
                        retval = _.pow(lim_base, lim_pow);
                      }
                    } else if (symbol.group === FN && symbol.args.length === 1) {
                      var evaluates;
                      var arg = __.Limit.limit(symbol.args[0], x, lim, depth);
                      if (core.Utils.isVector(arg)) {
                        retval = arg.map(function(e) {
                          var clone = symbol.clone();
                          clone.args[0] = e;
                          return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);
                        });
                        return _.multiply(m, retval);
                      } else if (arg.isConstant(true)) {
                        var trial = _.symfunction(symbol.fname, [arg]);
                        try {
                          evaluate(trial);
                          evaluates = true;
                        } catch (e) {
                          evaluates = false;
                        }
                      }
                      if (evaluates) {
                        retval = trial;
                      } else {
                        if (__.Limit.isConvergent(arg)) {
                          if (symbol.fname === LOG) {
                            switch (arg.toString()) {
                              case "0":
                                retval = Symbol.infinity().negate();
                                break;
                              case "Infinity":
                                retval = Symbol.infinity();
                                break;
                              case "-Infinity":
                                retval = Symbol.infinity();
                                break;
                            }
                          } else if ((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {
                            retval = __.Limit.interval(-1, 1);
                          } else if (symbol.fname === TAN) {
                            var s_arg = symbol.args[0];
                            var n = s_arg.getNum();
                            var d = s_arg.getDenom();
                            var pi = n.toUnitMultiplier();
                            if (lim.isInfinity || pi.equals("pi") && d.equals(2)) {
                              retval = divergent();
                            }
                          } else if (symbol.fname === Settings.FACTORIAL) {
                            if (arg.isInfinity)
                              return Symbol.infinity();
                          }
                        }
                      }
                    } else if (symbol.group === S) {
                      if (symbol.power > 0)
                        return _.parse(symbol, point);
                      else {
                        if (core.Utils.even(symbol.power)) {
                          retval = Symbol.infinity();
                        } else {
                          retval = __.Limit.diverges();
                        }
                      }
                    } else if (symbol.group === CB) {
                      var lim1, lim2;
                      var symbols = symbol.collectSymbols().sort(function(a, b) {
                        return a.group - b.group;
                      });
                      var f = symbols.pop();
                      lim1 = evaluate(__.Limit.limit(f, x, lim, depth));
                      while (symbols.length) {
                        var g = symbols.pop();
                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));
                        if (lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2)) {
                          if (g.containsFunction(LOG)) {
                            g = [f, f = g][0];
                          }
                          g.invert();
                          if (lim1.isInfinity && lim2.isInfinity) {
                            lim1 = Symbol.infinity();
                          } else {
                            lim1 = __.Limit.divide(f, g, x, lim, depth);
                          }
                        } else {
                          lim1 = _.multiply(lim1, lim2);
                          f = _.multiply(f, g);
                        }
                      }
                      retval = lim1;
                    } else if (symbol.isComposite()) {
                      var _lim;
                      if (!symbol.isLinear())
                        symbol = _.expand(symbol);
                      retval = new Symbol(0);
                      var symbols = symbol.collectSymbols().sort(function(a, b) {
                        return b.group - a.group;
                      });
                      var _symbols = [];
                      var fns = new Symbol(0);
                      for (var i = 0, l = symbols.length; i < l; i++) {
                        var sym = symbols[i].clone();
                        if (sym.group === FN || sym.group === CB && sym.hasFunc()) {
                          fns = _.add(fns, sym);
                        } else
                          _symbols.push(sym);
                      }
                      _symbols.unshift(fns);
                      if (_symbols.length !== 1) {
                        symbols = _symbols;
                      }
                      for (var i = 0, l = symbols.length; i < l; i++) {
                        var sym = symbols[i];
                        try {
                          _lim = __.Limit.limit(sym, x, lim, depth);
                        } catch (e) {
                          _lim = __.Limit.diverges();
                        }
                        try {
                          retval = _.add(retval, _lim);
                        } catch (e) {
                          if (depth++ > Settings.max_lim_depth) {
                            return;
                          }
                          ;
                          retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);
                        }
                      }
                    }
                  } else {
                    retval = __.Limit.divide(num, den, x, lim, depth);
                  }
                }
              }
              if (!retval)
                retval = _.symfunction("limit", [symbol, x, lim]);
            } catch (e) {
              retval = _.symfunction("limit", [symbol, x, lim]);
            }
            return _.multiply(m, retval);
          }
        },
        Fresnel: {
          S: function(x) {
            if (x.isConstant(true)) {
              return __.defint(_.parse("sin(pi*x^2/2)"), Symbol(0), x, "x");
            }
            return _.symfunction("S", arguments);
          },
          C: function(x) {
            if (x.isConstant(true)) {
              return __.defint(_.parse("cos(pi*x^2/2)"), Symbol(0), x, "x");
            }
            return _.symfunction("C", arguments);
          }
        }
      };
      nerdamer.register([
        {
          name: "diff",
          visible: true,
          numargs: [1, 3],
          build: function() {
            return __.diff;
          }
        },
        {
          name: "sum",
          visible: true,
          numargs: 4,
          build: function() {
            return __.sum;
          }
        },
        {
          name: "product",
          visible: true,
          numargs: 4,
          build: function() {
            return __.product;
          }
        },
        {
          name: "integrate",
          visible: true,
          numargs: [1, 2],
          build: function() {
            return __.integrate;
          }
        },
        {
          name: "defint",
          visible: true,
          numargs: [3, 4],
          build: function() {
            return __.defint;
          }
        },
        {
          name: "S",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Fresnel.S;
          }
        },
        {
          name: "C",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Fresnel.C;
          }
        },
        {
          name: "limit",
          visible: true,
          numargs: [3, 4],
          build: function() {
            return __.Limit.limit;
          }
        }
      ]);
      nerdamer.updateAPI();
    })();
  }
});

// node_modules/nerdamer/Algebra.js
var require_Algebra = __commonJS({
  "node_modules/nerdamer/Algebra.js"(exports, module) {
    if (typeof module !== "undefined") {
      nerdamer = require_nerdamer_core();
      require_Calculus();
    }
    var nerdamer;
    (function() {
      "use strict";
      var core = nerdamer.getCore(), _ = core.PARSER, N = core.groups.N, P = core.groups.P, S = core.groups.S, EX = core.groups.EX, FN = core.groups.FN, PL = core.groups.PL, CP = core.groups.CP, CB = core.groups.CB, keys = core.Utils.keys, even = core.Utils.even, variables = core.Utils.variables, format = core.Utils.format, round = core.Utils.round, Frac = core.Frac, isInt = core.Utils.isInt, Symbol = core.Symbol, CONST_HASH = core.Settings.CONST_HASH, math = core.Utils.importFunctions(), evaluate = core.Utils.evaluate;
      function Polynomial(symbol, variable, order) {
        if (core.Utils.isSymbol(symbol)) {
          this.parse(symbol);
          this.variable = this.variable || variable;
        } else if (!isNaN(symbol)) {
          order = order || 0;
          if (variable === void 0)
            throw new core.exceptions.InvalidVariableNameError("Polynomial expects a variable name when creating using order");
          this.coeffs = [];
          this.coeffs[order] = symbol;
          this.fill(symbol);
        } else if (typeof symbol === "string") {
          this.parse(_.parse(symbol));
        }
      }
      Polynomial.fromArray = function(arr, variable) {
        if (typeof variable === "undefined")
          throw new core.exceptions.InvalidVariableNameError("A variable name must be specified when creating polynomial from array");
        var p = new Polynomial();
        p.coeffs = arr;
        p.variable = variable;
        return p;
      };
      Polynomial.fit = function(c1, c2, n, base, p, variable) {
        var terms = new Array(p + 1), t = n - c2;
        terms[0] = c2;
        terms[p] = c1;
        t -= c1 * Math.pow(base, p);
        for (var i = p - 1; i > 0; i--) {
          var b = Math.pow(base, i), q = t / b, sign = Math.sign(q);
          var c = sign * Math.floor(Math.abs(q));
          t -= c * b;
          terms[i] = c;
        }
        if (t !== 0)
          return null;
        for (var i = 0; i < terms.length; i++)
          terms[i] = new Frac(terms[i]);
        return Polynomial.fromArray(terms, variable);
      };
      Polynomial.prototype = {
        /**
         * Converts Symbol to Polynomial
         * @param {Symbol} symbol
         * @param {Array} c - a collector array
         * @returns {Polynomial}
         */
        parse: function(symbol, c) {
          this.variable = variables(symbol)[0];
          if (!symbol.isPoly())
            throw core.exceptions.NerdamerTypeError("Polynomial Expected! Received " + core.Utils.text(symbol));
          c = c || [];
          if (!symbol.power.absEquals(1))
            symbol = _.expand(symbol);
          if (symbol.group === core.groups.N) {
            c[0] = symbol.multiplier;
          } else if (symbol.group === core.groups.S) {
            c[symbol.power.toDecimal()] = symbol.multiplier;
          } else {
            for (var x in symbol.symbols) {
              var sub = symbol.symbols[x], p = sub.power;
              if (core.Utils.isSymbol(p))
                throw new core.exceptions.NerdamerTypeError("power cannot be a Symbol");
              p = sub.group === N ? 0 : p.toDecimal();
              if (sub.symbols) {
                this.parse(sub, c);
              } else {
                c[p] = sub.multiplier;
              }
            }
          }
          this.coeffs = c;
          this.fill();
        },
        /**
         * Fills in the holes in a polynomial with zeroes
         * @param {Number} x - The number to fill the holes with
         */
        fill: function(x) {
          x = Number(x) || 0;
          var l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            if (this.coeffs[i] === void 0) {
              this.coeffs[i] = new Frac(x);
            }
          }
          return this;
        },
        /**
         * Removes higher order zeros or a specific coefficient
         * @returns {Array}
         */
        trim: function() {
          var l = this.coeffs.length;
          while (l--) {
            var c = this.coeffs[l];
            var equalsZero = c.equals(0);
            if (c && equalsZero) {
              if (l === 0)
                break;
              this.coeffs.pop();
            } else
              break;
          }
          return this;
        },
        /*
         * Returns polynomial mod p **currently fails**
         * @param {Number} p
         * @returns {Polynomial}
         */
        modP: function(p) {
          var l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var c = this.coeffs[i];
            if (c < 0) {
              var b;
              for (var j = i; j < l; j++) {
                if (this.coeffs[j] > 0) {
                  b = this.coeffs[j];
                  break;
                }
              }
              if (b) {
                for (j; j > i; j--) {
                  this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));
                  this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));
                }
                c = this.coeffs[i];
              }
            }
            var d = c.mod(p);
            var w = c.subtract(d).divide(p);
            if (!w.equals(0)) {
              var up_one = i + 1;
              var next = this.coeffs[up_one] || new Frac(0);
              next = next.add(w);
              this.coeffs[up_one] = new Frac(next);
              this.coeffs[i] = new Frac(d);
            }
          }
          return this;
        },
        /**
         * Adds together 2 polynomials
         * @param {Polynomial} poly
         */
        add: function(poly) {
          var l = Math.max(this.coeffs.length, poly.coeffs.length);
          for (var i = 0; i < l; i++) {
            var a = this.coeffs[i] || new Frac(0), b = poly.coeffs[i] || new Frac(0);
            this.coeffs[i] = a.add(b);
          }
          return this;
        },
        /**
         * Adds together 2 polynomials
         * @param {Polynomial} poly
         */
        subtract: function(poly) {
          var l = Math.max(this.coeffs.length, poly.coeffs.length);
          for (var i = 0; i < l; i++) {
            var a = this.coeffs[i] || new Frac(0), b = poly.coeffs[i] || new Frac(0);
            this.coeffs[i] = a.subtract(b);
          }
          return this;
        },
        divide: function(poly) {
          var variable = this.variable, dividend = core.Utils.arrayClone(this.coeffs), divisor = core.Utils.arrayClone(poly.coeffs), n = dividend.length, mp = divisor.length - 1, quotient = [];
          for (var i = 0; i < n; i++) {
            var p = n - (i + 1);
            var d = p - mp;
            var q = dividend[p].divide(divisor[mp]);
            if (d < 0)
              break;
            quotient[d] = q;
            for (var j = 0; j <= mp; j++) {
              dividend[j + d] = dividend[j + d].subtract(divisor[j].multiply(q));
            }
          }
          var p1 = Polynomial.fromArray(dividend, variable || "x").trim(), p2 = Polynomial.fromArray(quotient, variable || "x");
          return [p2, p1];
        },
        multiply: function(poly) {
          var l1 = this.coeffs.length, l2 = poly.coeffs.length, c = [];
          for (var i = 0; i < l1; i++) {
            var x1 = this.coeffs[i];
            for (var j = 0; j < l2; j++) {
              var k = i + j, x2 = poly.coeffs[j], e = c[k] || new Frac(0);
              c[k] = e.add(x1.multiply(x2));
            }
          }
          this.coeffs = c;
          return this;
        },
        /**
         * Checks if a polynomial is zero
         * @returns {Boolean}
         */
        isZero: function() {
          var l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var e = this.coeffs[i];
            if (!e.equals(0))
              return false;
          }
          return true;
        },
        /** 
         * Substitutes in a number n into the polynomial p(n)
         * @param {Number} n
         * @returns {Frac}
         */
        sub: function(n) {
          var sum = new Frac(0), l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var t = this.coeffs[i];
            if (!t.equals(0))
              sum = sum.add(t.multiply(new Frac(Math.pow(n, i))));
          }
          return sum;
        },
        /**
         * Returns a clone of the polynomial
         * @returns {Polynomial}
         */
        clone: function() {
          var p = new Polynomial();
          p.coeffs = this.coeffs;
          p.variable = this.variable;
          return p;
        },
        /**
         * Gets the degree of the polynomial
         * @returns {Number}
         */
        deg: function() {
          this.trim();
          return this.coeffs.length - 1;
        },
        /**
         * Returns a lead coefficient
         * @returns {Frac}
         */
        lc: function() {
          return this.coeffs[this.deg()].clone();
        },
        /**
         * Converts polynomial into a monic polynomial
         * @returns {Polynomial}
         */
        monic: function() {
          var lc = this.lc(), l = this.coeffs.length;
          for (var i = 0; i < l; i++)
            this.coeffs[i] = this.coeffs[i].divide(lc);
          return this;
        },
        /**
         * Returns the GCD of two polynomials
         * @param {Polynomial} poly
         * @returns {Polynomial}
         */
        gcd: function(poly) {
          var mp1 = this.coeffs.length - 1, mp2 = poly.coeffs.length - 1, T;
          if (mp1 < mp2) {
            return poly.gcd(this);
          }
          var a = this;
          while (!poly.isZero()) {
            var t = poly.clone();
            a = a.clone();
            T = a.divide(t);
            poly = T[1];
            a = t;
          }
          var gcd = core.Math2.QGCD.apply(null, a.coeffs);
          if (!gcd.equals(1)) {
            var l = a.coeffs.length;
            for (var i = 0; i < l; i++) {
              a.coeffs[i] = a.coeffs[i].divide(gcd);
            }
          }
          return a;
        },
        /**
         * Differentiates the polynomial
         * @returns {Polynomial}
         */
        diff: function() {
          var new_array = [], l = this.coeffs.length;
          for (var i = 1; i < l; i++)
            new_array.push(this.coeffs[i].multiply(new Frac(i)));
          this.coeffs = new_array;
          return this;
        },
        /**
         * Integrates the polynomial
         * @returns {Polynomial} 
         */
        integrate: function() {
          var new_array = [0], l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var c = new Frac(i + 1);
            new_array[c] = this.coeffs[i].divide(c);
          }
          this.coeffs = new_array;
          return this;
        },
        /**
         * Returns the Greatest common factor of the polynomial
         * @param {bool} toPolynomial - true if a polynomial is wanted
         * @returns {Frac|Polynomial}
         */
        gcf: function(toPolynomial) {
          var fnz = function(a) {
            for (var i2 = 0; i2 < a.length; i2++)
              if (!a[i2].equals(0))
                return i2;
          }, ca = [];
          for (var i = 0; i < this.coeffs.length; i++) {
            var c = this.coeffs[i];
            if (!c.equals(0) && ca.indexOf(c) === -1)
              ca.push(c);
          }
          var p = [core.Math2.QGCD.apply(void 0, ca), fnz(this.coeffs)].toDecimal();
          if (toPolynomial) {
            var parr = [];
            parr[p[1] - 1] = p[0];
            p = Polynomial.fromArray(parr, this.variable).fill();
          }
          return p;
        },
        /**
         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2
         * @param {bool} incl_img - Include imaginary numbers 
         */
        quad: function(incl_img) {
          var roots = [];
          if (this.coeffs.length > 3)
            throw new Error("Cannot calculate quadratic order of " + (this.coeffs.length - 1));
          if (this.coeffs.length === 0)
            throw new Error("Polynomial array has no terms");
          var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];
          var dsc = b * b - 4 * a * c;
          if (dsc < 0 && !incl_img)
            return roots;
          else {
            roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);
            roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);
          }
          return roots;
        },
        /**
         * Makes polynomial square free
         * @returns {Array}
         */
        squareFree: function() {
          var a = this.clone(), i = 1, b = a.clone().diff(), c = a.clone().gcd(b), w = a.divide(c)[0];
          var output = Polynomial.fromArray([new Frac(1)], a.variable);
          while (!c.equalsNumber(1)) {
            var y = w.gcd(c);
            var z = w.divide(y)[0];
            if (!z.equalsNumber(1) && i > 1) {
              var t = z.clone();
              for (var j = 1; j < i; j++)
                t.multiply(z.clone());
              z = t;
            }
            output = output.multiply(z);
            i++;
            w = y;
            c = c.divide(y)[0];
          }
          return [output, w, i];
        },
        /**
         * Converts polynomial to Symbol
         * @returns {Symbol}
         */
        toSymbol: function() {
          var l = this.coeffs.length, variable = this.variable;
          if (l === 0)
            return new core.Symbol(0);
          var end = l - 1, str = "";
          for (var i = 0; i < l; i++) {
            var plus = i === end ? "" : "+", e = this.coeffs[i];
            if (!e.equals(0))
              str += e + "*" + variable + "^" + i + plus;
          }
          return _.parse(str);
        },
        /**
         * Checks if polynomial is equal to a number
         * @param {Number} x
         * @returns {Boolean}
         */
        equalsNumber: function(x) {
          this.trim();
          return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);
        },
        toString: function() {
          return this.toSymbol().toString();
        }
      };
      Symbol.prototype.coeffs = function(c, with_order) {
        if (with_order && !this.isPoly(true))
          _.error("Polynomial expected when requesting coefficients with order");
        c = c || [];
        var s = this.clone().distributeMultiplier();
        if (s.isComposite()) {
          for (var x in s.symbols) {
            var sub = s.symbols[x];
            if (sub.isComposite()) {
              sub.clone().distributeMultiplier().coeffs(c, with_order);
            } else {
              if (with_order)
                c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;
              else {
                c.push(sub.multiplier);
              }
            }
          }
        } else {
          if (with_order)
            c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;
          else {
            if (s.group === CB && s.isImaginary()) {
              var m = new Symbol(s.multiplier);
              s.each(function(x2) {
                if (x2.isConstant(true) || x2.imaginary)
                  m = _.multiply(m, x2);
              });
              c.push(m);
            } else
              c.push(s.multiplier);
          }
        }
        if (with_order) {
          for (var i = 0; i < c.length; i++)
            if (c[i] === void 0)
              c[i] = new Symbol(0);
        }
        return c;
      };
      Symbol.prototype.tBase = function(map) {
        if (typeof map === "undefined")
          throw new Error("Symbol.tBase requires a map object!");
        var terms = [];
        var symbols = this.collectSymbols(null, null, null, true), l = symbols.length;
        for (var i = 0; i < l; i++) {
          var symbol = symbols[i], g = symbol.group, nterm = new MVTerm(symbol.multiplier, [], map);
          if (g === CB) {
            for (var x in symbol.symbols) {
              var sym = symbol.symbols[x];
              nterm.terms[map[x]] = sym.power;
            }
          } else {
            nterm.terms[map[symbol.value]] = symbol.power;
          }
          terms.push(nterm.fill());
          nterm.updateCount();
        }
        return terms;
      };
      Symbol.prototype.altVar = function(x) {
        var m = this.multiplier.toString(), p = this.power.toString();
        return (m === "1" ? "" : m + "*") + x + (p === "1" ? "" : "^" + p);
      };
      Symbol.prototype.sameVars = function(symbol) {
        if (!(this.symbols || this.group === symbol.group))
          return false;
        for (var x in this.symbols) {
          var a = this.symbols[x], b = symbol.symbols[x];
          if (!b)
            return false;
          if (a.value !== b.value)
            return false;
        }
        return true;
      };
      Symbol.prototype.groupTerms = function(x) {
        x = String(x);
        var f, p, egrouped;
        var grouped = [];
        this.each(function(e) {
          if (e.group === PL) {
            egrouped = e.groupTerms(x);
            for (var i = 0; i < egrouped.length; i++) {
              var el = egrouped[i];
              if (el)
                grouped[i] = el;
            }
          } else {
            f = core.Utils.decompose_fn(e, x, true);
            p = f.x.value === x ? Number(f.x.power) : 0;
            grouped[p] = _.add(grouped[p] || new Symbol(0), f.a);
          }
        });
        return grouped;
      };
      Symbol.prototype.collectFactors = function() {
        var factors = [];
        if (this.group === CB)
          this.each(function(x) {
            factors.push(x.clone());
          });
        else
          factors.push(this.clone());
        return factors;
      };
      function Factors() {
        this.factors = {};
        this.length = 0;
      }
      ;
      Factors.prototype.getNumberSymbolics = function() {
        var n = 0;
        this.each(function(x) {
          if (!x.isConstant(true))
            n++;
        });
        return n;
      };
      Factors.prototype.add = function(s) {
        if (s.equals(0))
          return this;
        if (s.equals(-1) && this.length > 0) {
          var fo = core.Utils.firstObject(this.factors, null, true);
          this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());
          delete this.factors[fo.key];
          this.length--;
          return this;
        }
        if (s.group === CB) {
          var factors = this;
          if (!s.multiplier.equals(1))
            factors.add(new Symbol(s.multiplier));
          s.each(function(x) {
            factors.add(x);
          });
        } else {
          if (this.preAdd)
            s = this.preAdd(s);
          if (this.pFactor)
            s = _.pow(s, new Symbol(this.pFactor));
          var is_constant = s.isConstant();
          if (is_constant && s.equals(1))
            return this;
          var v = is_constant ? s.value : s.text();
          if (v in this.factors) {
            this.factors[v] = _.multiply(this.factors[v], s);
            if (this.factors[v].equals(1)) {
              delete this.factors[v];
              this.length--;
            }
          } else {
            this.factors[v] = s;
            this.length++;
          }
        }
        return this;
      };
      Factors.prototype.toSymbol = function() {
        var factored = new Symbol(1);
        var factors = Object.values(this.factors).sort(function(a, b) {
          return a.group > b.group;
        });
        for (var i = 0, l = factors.length; i < l; i++) {
          var f = factors[i];
          var factor = f.power.equals(1) && f.fname !== "" ? _.symfunction(core.PARENTHESIS, [f]) : f;
          factored = _.multiply(factored, factor);
        }
        if (factored.fname === "")
          factored = Symbol.unwrapPARENS(factored);
        return factored;
      };
      Factors.prototype.merge = function(o) {
        for (var x in o) {
          if (x in this.factors)
            this.factors[x] = _.multiply(this.factors[x], o[x]);
          else
            this.factors[x] = o[x];
        }
        return this;
      };
      Factors.prototype.each = function(f) {
        for (var x in this.factors) {
          var factor = this.factors[x];
          if (factor.fname === core.PARENTHESIS && factor.isLinear())
            factor = factor.args[0];
          f.call(this, factor, x);
        }
        return this;
      };
      Factors.prototype.count = function() {
        return keys(this.factors).length;
      };
      Factors.prototype.clean = function() {
        try {
          var h = core.Settings.CONST_HASH;
          if (this.factors[h].lessThan(0)) {
            if (this.factors[h].equals(-1))
              delete this.factors[h];
            else
              this.factors[h].negate();
            this.each(function(x) {
              x.negate();
            });
          }
        } catch (e) {
        }
        ;
      };
      Factors.prototype.toString = function() {
        return this.toSymbol().toString();
      };
      function MVTerm(coeff, terms, map) {
        this.terms = terms || [];
        this.coeff = coeff;
        this.map = map;
        this.sum = new core.Frac(0);
        this.image = void 0;
      }
      ;
      MVTerm.prototype.updateCount = function() {
        this.count = this.count || 0;
        for (var i = 0; i < this.terms.length; i++) {
          if (!this.terms[i].equals(0))
            this.count++;
        }
        return this;
      };
      MVTerm.prototype.getVars = function() {
        var vars = [];
        for (var i = 0; i < this.terms.length; i++) {
          var term = this.terms[i], rev_map = this.getRevMap();
          if (!term.equals(0))
            vars.push(this.rev_map[i]);
        }
        return vars.join(" ");
      };
      MVTerm.prototype.len = function() {
        if (typeof this.count === "undefined") {
          this.updateCount();
        }
        return this.count;
      };
      MVTerm.prototype.toSymbol = function(rev_map) {
        rev_map = rev_map || this.getRevMap();
        var symbol = new Symbol(this.coeff);
        for (var i = 0; i < this.terms.length; i++) {
          var v = rev_map[i], t = this.terms[i];
          if (t.equals(0) || v === CONST_HASH)
            continue;
          var mapped = new Symbol(v);
          mapped.power = t;
          symbol = _.multiply(symbol, mapped);
        }
        return symbol;
      };
      MVTerm.prototype.getRevMap = function() {
        if (this.rev_map)
          return this.rev_map;
        var o = {};
        for (var x in this.map)
          o[this.map[x]] = x;
        this.rev_map = o;
        return o;
      };
      MVTerm.prototype.generateImage = function() {
        this.image = this.terms.join(" ");
        return this;
      }, MVTerm.prototype.getImg = function() {
        if (!this.image)
          this.generateImage();
        return this.image;
      }, MVTerm.prototype.fill = function() {
        var l = this.map.length;
        for (var i = 0; i < l; i++) {
          if (typeof this.terms[i] === "undefined")
            this.terms[i] = new core.Frac(0);
          else {
            this.sum = this.sum.add(this.terms[i]);
          }
        }
        return this;
      };
      MVTerm.prototype.divide = function(mvterm) {
        var c = this.coeff.divide(mvterm.coeff), l = this.terms.length, new_mvterm = new MVTerm(c, [], this.map);
        for (var i = 0; i < l; i++) {
          new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);
          new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);
        }
        return new_mvterm;
      };
      MVTerm.prototype.multiply = function(mvterm) {
        var c = this.coeff.multiply(mvterm.coeff), l = this.terms.length, new_mvterm = new MVTerm(c, [], this.map);
        for (var i = 0; i < l; i++) {
          new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);
          new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);
        }
        return new_mvterm;
      };
      MVTerm.prototype.isZero = function() {
        return this.coeff.equals(0);
      };
      MVTerm.prototype.toString = function() {
        return "{ coeff: " + this.coeff.toString() + ", terms: [" + this.terms.join(",") + "]: sum: " + this.sum.toString() + ", count: " + this.count + "}";
      };
      core.Utils.toMapObj = function(arr) {
        var c = 0, o = {};
        for (var i = 0; i < arr.length; i++) {
          var v = arr[i];
          if (typeof o[v] === "undefined") {
            o[v] = c;
            c++;
          }
        }
        o.length = c;
        return o;
      };
      core.Utils.filledArray = function(v, n, clss) {
        var a = [];
        while (n--) {
          a[n] = clss ? new clss(v) : v;
        }
        return a;
      };
      core.Utils.arrSum = function(arr) {
        var sum = 0, l = arr.length;
        for (var i = 0; i < l; i++)
          sum += arr[i];
        return sum;
      };
      core.Utils.haveIntersection = function(a, b) {
        var t;
        if (b.length > a.length)
          t = b, b = a, a = t;
        return a.some(function(e) {
          return b.indexOf(e) > -1;
        });
      };
      core.Utils.subFunctions = function(symbol, map) {
        map = map || {};
        var subbed = [];
        symbol.each(function(x) {
          if (x.group === FN || x.previousGroup === FN) {
            var val = core.Utils.text(x, "hash"), tvar = map[val];
            if (!tvar) {
              var t = x.fname + keys(map).length;
              map[val] = t;
              subbed.push(x.altVar(t));
            } else
              subbed.push(x.altVar(tvar));
          } else if (x.group === CB || x.group === PL || x.group === CP) {
            subbed.push(core.Utils.subFunctions(x, map));
          } else
            subbed.push(x.text());
        });
        if (symbol.group === CP || symbol.group === PL)
          return symbol.altVar(core.Utils.inBrackets(subbed.join("+")));
        ;
        if (symbol.group === CB)
          return symbol.altVar(core.Utils.inBrackets(subbed.join("*")));
        return symbol.text();
      };
      core.Utils.getFunctionsSubs = function(map) {
        var subs = {};
        for (var x in map)
          subs[map[x]] = _.parse(x);
        return subs;
      };
      var __ = core.Algebra = {
        version: "1.4.6",
        proots: function(symbol, decp) {
          decp = decp || 7;
          var zeros = 0;
          var known_roots = [];
          var get_roots = function(rarr2, powers2, max2) {
            var roots = calcroots(rarr2, powers2, max2).concat(known_roots);
            for (var i2 = 0; i2 < zeros; i2++)
              roots.unshift(0);
            return roots;
          };
          if (symbol instanceof Symbol && symbol.isPoly()) {
            symbol.distributeMultiplier();
            if (symbol.group === PL) {
              var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));
              var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();
              symbol = _.expand(_.divide(symbol, lowest_symbol));
              known_roots.push(0);
            }
            if (symbol.group === core.groups.S) {
              return [0];
            } else if (symbol.group === core.groups.PL) {
              var powers = keys(symbol.symbols), minpower = core.Utils.arrayMin(powers), symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + "^" + minpower));
            }
            var variable = keys(symbol.symbols).sort().pop(), sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable], g = sym.group, powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols), rarr = [], max = core.Utils.arrayMax(powers);
            for (var i = 1; i <= max; i++) {
              var c = 0;
              if (powers.indexOf(i + "") !== -1) {
                if (g === S) {
                  c = sym.multiplier;
                } else {
                  c = sym.symbols[i].multiplier;
                }
              }
              rarr.unshift(c);
            }
            rarr.push(symbol.symbols[CONST_HASH].multiplier);
            if (sym.group === S)
              rarr[0] = sym.multiplier;
            return get_roots(rarr, powers, max);
          } else if (core.Utils.isArray(symbol)) {
            var parr = symbol;
            var rarr = [], powers = [], last_power = 0;
            for (var i = 0; i < parr.length; i++) {
              var coeff = parr[i][0], pow = parr[i][1], d = pow - last_power - 1;
              for (var j = 0; j < d; j++)
                rarr.unshift(0);
              rarr.unshift(coeff);
              if (pow !== 0)
                powers.push(pow);
              last_power = pow;
            }
            var max = Math.max.apply(void 0, powers);
            return get_roots(rarr, powers, max);
          } else {
            throw new core.exceptions.NerdamerTypeError("Cannot calculate roots. Symbol must be a polynomial!");
          }
          function calcroots(rarr2, powers2, max2) {
            var MAXDEGREE = 100;
            var p = rarr2.slice(0);
            rarr2.unshift(max2);
            if (max2 > MAXDEGREE) {
              throw new core.exceptions.ValueLimitExceededError("This utility accepts polynomials of degree up to " + MAXDEGREE + ". ");
            }
            var zeroi = [], degreePar = {};
            degreePar.Degree = max2;
            for (i = 0; i < max2; i++) {
              zeroi.push(0);
            }
            var zeror = zeroi.slice(0);
            function QuadSD_ak1(NN, u, v, p2, q, iPar) {
              q[0] = iPar.b = p2[0];
              q[1] = iPar.a = -(u * iPar.b) + p2[1];
              for (var i2 = 2; i2 < NN; i2++) {
                q[i2] = -(u * iPar.a + v * iPar.b) + p2[i2];
                iPar.b = iPar.a;
                iPar.a = q[i2];
              }
              return;
            }
            function calcSC_ak1(DBL_EPSILON, N2, a, b, iPar, K, u, v, qk) {
              var sdPar = new Object(), dumFlag = 3;
              sdPar.b = sdPar.a = 0;
              QuadSD_ak1(N2, u, v, K, qk, sdPar);
              iPar.c = sdPar.a;
              iPar.d = sdPar.b;
              if (Math.abs(iPar.c) <= 100 * DBL_EPSILON * Math.abs(K[N2 - 1])) {
                if (Math.abs(iPar.d) <= 100 * DBL_EPSILON * Math.abs(K[N2 - 2]))
                  return dumFlag;
              }
              iPar.h = v * b;
              if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {
                dumFlag = 2;
                iPar.e = a / iPar.d;
                iPar.f = iPar.c / iPar.d;
                iPar.g = u * b;
                iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);
                iPar.a1 = -a + iPar.f * b;
                iPar.a7 = iPar.h + (iPar.f + u) * a;
              } else {
                dumFlag = 1;
                iPar.e = a / iPar.c;
                iPar.f = iPar.d / iPar.c;
                iPar.g = iPar.e * u;
                iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;
                iPar.a1 = -(a * (iPar.d / iPar.c)) + b;
                iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;
              }
              return dumFlag;
            }
            function nextK_ak1(DBL_EPSILON, N2, tFlag, a, b, iPar, K, qk, qp) {
              var temp;
              if (tFlag == 3) {
                K[1] = K[0] = 0;
                for (var i2 = 2; i2 < N2; i2++) {
                  K[i2] = qk[i2 - 2];
                }
                return;
              }
              temp = tFlag == 1 ? b : a;
              if (Math.abs(iPar.a1) > 10 * DBL_EPSILON * Math.abs(temp)) {
                iPar.a7 /= iPar.a1;
                iPar.a3 /= iPar.a1;
                K[0] = qp[0];
                K[1] = -(qp[0] * iPar.a7) + qp[1];
                for (var i2 = 2; i2 < N2; i2++)
                  K[i2] = -(qp[i2 - 1] * iPar.a7) + qk[i2 - 2] * iPar.a3 + qp[i2];
              } else {
                K[0] = 0;
                K[1] = -(qp[0] * iPar.a7);
                for (var i2 = 2; i2 < N2; i2++) {
                  K[i2] = -(qp[i2 - 1] * iPar.a7) + qk[i2 - 2] * iPar.a3;
                }
              }
              return;
            }
            function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c2, d2, f, g2, h, u, v, K, N2, p2) {
              var a4, a5, b1, b2, c1, c22, c3, c4, temp;
              iPar.b = iPar.a = 0;
              if (tFlag != 3) {
                if (tFlag != 2) {
                  a4 = a + u * b + h * f;
                  a5 = c2 + (u + v * f) * d2;
                } else {
                  a4 = (a + g2) * f + h;
                  a5 = (f + u) * c2 + v * d2;
                }
                b1 = -(K[N2 - 1] / p2[N2]);
                b2 = -(K[N2 - 2] + b1 * p2[N2 - 1]) / p2[N2];
                c1 = v * b2 * a1;
                c22 = b1 * a7;
                c3 = b1 * b1 * a3;
                c4 = -(c22 + c3) + c1;
                temp = -c4 + a5 + b1 * a4;
                if (temp != 0) {
                  iPar.a = -((u * (c3 + c22) + v * (b1 * a1 + b2 * a7)) / temp) + u;
                  iPar.b = v * (1 + c4 / temp);
                }
              }
              return;
            }
            function Quad_ak1(a, b1, c2, iPar) {
              var b, d2, e;
              iPar.sr = iPar.si = iPar.lr = iPar.li = 0;
              if (a == 0) {
                iPar.sr = b1 != 0 ? -(c2 / b1) : iPar.sr;
                return;
              }
              if (c2 == 0) {
                iPar.lr = -(b1 / a);
                return;
              }
              b = b1 / 2;
              if (Math.abs(b) < Math.abs(c2)) {
                e = c2 >= 0 ? a : -a;
                e = -e + b * (b / Math.abs(c2));
                d2 = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c2));
              } else {
                e = -(a / b * (c2 / b)) + 1;
                d2 = Math.sqrt(Math.abs(e)) * Math.abs(b);
              }
              if (e >= 0) {
                d2 = b >= 0 ? -d2 : d2;
                iPar.lr = (-b + d2) / a;
                iPar.sr = iPar.lr != 0 ? c2 / iPar.lr / a : iPar.sr;
              } else {
                iPar.lr = iPar.sr = -(b / a);
                iPar.si = Math.abs(d2 / a);
                iPar.li = -iPar.si;
              }
              return;
            }
            function QuadIT_ak1(DBL_EPSILON, N2, iPar, uu, vv, qp, NN, sdPar, p2, qk, calcPar, K) {
              var qPar = new Object(), ee, mp, omp, relstp, t, u, ui, v, vi, zm, i2, j2 = 0, tFlag, triedFlag = 0;
              iPar.NZ = 0;
              u = uu;
              v = vv;
              do {
                qPar.li = qPar.lr = qPar.si = qPar.sr = 0;
                Quad_ak1(1, u, v, qPar);
                iPar.szr = qPar.sr;
                iPar.szi = qPar.si;
                iPar.lzr = qPar.lr;
                iPar.lzi = qPar.li;
                if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))
                  break;
                QuadSD_ak1(NN, u, v, p2, qp, sdPar);
                mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b);
                zm = Math.sqrt(Math.abs(v));
                ee = 2 * Math.abs(qp[0]);
                t = -(iPar.szr * sdPar.b);
                for (i2 = 1; i2 < N2; i2++) {
                  ee = ee * zm + Math.abs(qp[i2]);
                }
                ee = ee * zm + Math.abs(t + sdPar.a);
                ee = (9 * ee + 2 * Math.abs(t) - 7 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON;
                if (mp <= 20 * ee) {
                  iPar.NZ = 2;
                  break;
                }
                j2++;
                if (j2 > 20)
                  break;
                if (j2 >= 2) {
                  if (relstp <= 0.01 && mp >= omp && !triedFlag) {
                    relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);
                    u -= u * relstp;
                    v += v * relstp;
                    QuadSD_ak1(NN, u, v, p2, qp, sdPar);
                    for (i2 = 0; i2 < 5; i2++) {
                      tFlag = calcSC_ak1(DBL_EPSILON, N2, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
                      nextK_ak1(DBL_EPSILON, N2, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);
                    }
                    triedFlag = 1;
                    j2 = 0;
                  }
                }
                omp = mp;
                tFlag = calcSC_ak1(DBL_EPSILON, N2, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
                nextK_ak1(DBL_EPSILON, N2, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);
                tFlag = calcSC_ak1(DBL_EPSILON, N2, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
                newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N2, p2);
                ui = sdPar.a;
                vi = sdPar.b;
                if (vi != 0) {
                  relstp = Math.abs((-v + vi) / vi);
                  u = ui;
                  v = vi;
                }
              } while (vi != 0);
              return;
            }
            function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N2, p2, NN, qp, K, qk) {
              var ee, kv, mp, ms, omp, pv, s, t, dumFlag, i2, j2, nm1 = N2 - 1;
              iPar.NZ = j2 = dumFlag = 0;
              s = sdPar.a;
              for (; ; ) {
                pv = p2[0];
                qp[0] = pv;
                for (i2 = 1; i2 < NN; i2++) {
                  qp[i2] = pv = pv * s + p2[i2];
                }
                mp = Math.abs(pv);
                ms = Math.abs(s);
                ee = 0.5 * Math.abs(qp[0]);
                for (i2 = 1; i2 < NN; i2++) {
                  ee = ee * ms + Math.abs(qp[i2]);
                }
                if (mp <= 20 * DBL_EPSILON * (2 * ee - mp)) {
                  iPar.NZ = 1;
                  iPar.szr = s;
                  iPar.szi = 0;
                  break;
                }
                j2++;
                if (j2 > 10)
                  break;
                if (j2 >= 2) {
                  if (Math.abs(t) <= 1e-3 * Math.abs(-t + s) && mp > omp) {
                    dumFlag = 1;
                    iPar.a = s;
                    break;
                  }
                }
                omp = mp;
                qk[0] = kv = K[0];
                for (i2 = 1; i2 < N2; i2++) {
                  qk[i2] = kv = kv * s + K[i2];
                }
                if (Math.abs(kv) > Math.abs(K[nm1]) * 10 * DBL_EPSILON) {
                  t = -(pv / kv);
                  K[0] = qp[0];
                  for (i2 = 1; i2 < N2; i2++) {
                    K[i2] = t * qk[i2 - 1] + qp[i2];
                  }
                } else {
                  K[0] = 0;
                  for (i2 = 1; i2 < N2; i2++)
                    K[i2] = qk[i2 - 1];
                }
                kv = K[0];
                for (i2 = 1; i2 < N2; i2++) {
                  kv = kv * s + K[i2];
                }
                t = Math.abs(kv) > Math.abs(K[nm1]) * 10 * DBL_EPSILON ? -(pv / kv) : 0;
                s += t;
              }
              return dumFlag;
            }
            function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N2, p2, NN, qp, u, iPar) {
              var sdPar = new Object(), calcPar = new Object(), qk = new Array(MDP1), svk = new Array(MDP1), a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv, fflag, i2, iFlag = 1, j2, spass, stry, tFlag, vpass, vtry;
              iPar.NZ = 0;
              betav = betas = 0.25;
              oss = sr;
              ovv = v;
              sdPar.b = sdPar.a = 0;
              QuadSD_ak1(NN, u, v, p2, qp, sdPar);
              a = sdPar.a;
              b = sdPar.b;
              calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0;
              tFlag = calcSC_ak1(DBL_EPSILON, N2, a, b, calcPar, K, u, v, qk);
              for (j2 = 0; j2 < L2; j2++) {
                fflag = 1;
                nextK_ak1(DBL_EPSILON, N2, tFlag, a, b, calcPar, K, qk, qp);
                tFlag = calcSC_ak1(DBL_EPSILON, N2, a, b, calcPar, K, u, v, qk);
                newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N2, p2);
                ui = sdPar.a;
                vv = vi = sdPar.b;
                ss = K[N2 - 1] != 0 ? -(p2[N2] / K[N2 - 1]) : 0;
                ts = tv = 1;
                if (j2 != 0 && tFlag != 3) {
                  tv = vv != 0 ? Math.abs((vv - ovv) / vv) : tv;
                  ts = ss != 0 ? Math.abs((ss - oss) / ss) : ts;
                  tvv = tv < otv ? tv * otv : 1;
                  tss = ts < ots ? ts * ots : 1;
                  vpass = tvv < betav ? 1 : 0;
                  spass = tss < betas ? 1 : 0;
                  if (spass || vpass) {
                    for (i2 = 0; i2 < N2; i2++) {
                      svk[i2] = K[i2];
                    }
                    s = ss;
                    stry = vtry = 0;
                    for (; ; ) {
                      if (fflag && (fflag = 0) == 0 && (spass && (!vpass || tss < tvv))) {
                        ;
                      } else {
                        QuadIT_ak1(DBL_EPSILON, N2, iPar, ui, vi, qp, NN, sdPar, p2, qk, calcPar, K);
                        a = sdPar.a;
                        b = sdPar.b;
                        if (iPar.NZ > 0)
                          return;
                        iFlag = vtry = 1;
                        betav *= 0.25;
                        if (stry || !spass) {
                          iFlag = 0;
                        } else {
                          for (i2 = 0; i2 < N2; i2++)
                            K[i2] = svk[i2];
                        }
                      }
                      if (iFlag != 0) {
                        sdPar.a = s;
                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N2, p2, NN, qp, K, qk);
                        s = sdPar.a;
                        if (iPar.NZ > 0)
                          return;
                        stry = 1;
                        betas *= 0.25;
                        if (iFlag != 0) {
                          ui = -(s + s);
                          vi = s * s;
                          continue;
                        }
                      }
                      for (i2 = 0; i2 < N2; i2++)
                        K[i2] = svk[i2];
                      if (!vpass || vtry)
                        break;
                    }
                    QuadSD_ak1(NN, u, v, p2, qp, sdPar);
                    a = sdPar.a;
                    b = sdPar.b;
                    tFlag = calcSC_ak1(DBL_EPSILON, N2, a, b, calcPar, K, u, v, qk);
                  }
                }
                ovv = vv;
                oss = ss;
                otv = tv;
                ots = ts;
              }
              return;
            }
            function rpSolve(degPar, p2, zeror2, zeroi2) {
              var N2 = degPar.Degree, RADFAC = 3.141592653589793 / 180, LB2 = Math.LN2, MDP1 = degPar.Degree + 1, K = new Array(MDP1), pt = new Array(MDP1), qp = new Array(MDP1), temp = new Array(MDP1), qPar = new Object(), Fxshfr_Par = new Object(), bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm, aa, bb, cc, sr, t, u, xxx, j2, jj, l2, NM1, NN, zerok;
              aa = 1;
              do {
                DBL_EPSILON = aa;
                aa /= 2;
                bb = 1 + aa;
              } while (bb > 1);
              var LO = Number.MIN_VALUE / DBL_EPSILON, cosr = Math.cos(94 * RADFAC), sinr = Math.sin(94 * RADFAC), xx = Math.sqrt(0.5), yy = -xx;
              Fxshfr_Par.NZ = j2 = 0;
              Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0;
              while (p2[N2] == 0) {
                zeror2[j2] = zeroi2[j2] = 0;
                N2--;
                j2++;
              }
              NN = N2 + 1;
              while (N2 >= 1) {
                if (N2 <= 2) {
                  if (N2 < 2) {
                    zeror2[degPar.Degree - 1] = -(p2[1] / p2[0]);
                    zeroi2[degPar.Degree - 1] = 0;
                  } else {
                    qPar.li = qPar.lr = qPar.si = qPar.sr = 0;
                    Quad_ak1(p2[0], p2[1], p2[2], qPar);
                    zeror2[degPar.Degree - 2] = qPar.sr;
                    zeroi2[degPar.Degree - 2] = qPar.si;
                    zeror2[degPar.Degree - 1] = qPar.lr;
                    zeroi2[degPar.Degree - 1] = qPar.li;
                  }
                  break;
                }
                moduli_max = 0;
                moduli_min = Number.MAX_VALUE;
                for (i2 = 0; i2 < NN; i2++) {
                  x = Math.abs(p2[i2]);
                  if (x > moduli_max)
                    moduli_max = x;
                  if (x != 0 && x < moduli_min)
                    moduli_min = x;
                }
                sc = LO / moduli_min;
                if (sc <= 1 && moduli_max >= 10 || sc > 1 && Number.MAX_VALUE / sc >= moduli_max) {
                  sc = sc == 0 ? Number.MIN_VALUE : sc;
                  l2 = Math.floor(Math.log(sc) / LB2 + 0.5);
                  factor = Math.pow(2, l2);
                  if (factor != 1) {
                    for (i2 = 0; i2 < NN; i2++)
                      p2[i2] *= factor;
                  }
                }
                for (var i2 = 0; i2 < NN; i2++)
                  pt[i2] = Math.abs(p2[i2]);
                pt[N2] = -pt[N2];
                NM1 = N2 - 1;
                x = Math.exp((Math.log(-pt[N2]) - Math.log(pt[0])) / N2);
                if (pt[NM1] != 0) {
                  xm = -pt[N2] / pt[NM1];
                  x = xm < x ? xm : x;
                }
                xm = x;
                do {
                  x = xm;
                  xm = 0.1 * x;
                  ff = pt[0];
                  for (var i2 = 1; i2 < NN; i2++) {
                    ff = ff * xm + pt[i2];
                  }
                } while (ff > 0);
                dx = x;
                do {
                  df = ff = pt[0];
                  for (var i2 = 1; i2 < N2; i2++) {
                    ff = x * ff + pt[i2];
                    df = x * df + ff;
                  }
                  ff = x * ff + pt[N2];
                  dx = ff / df;
                  x -= dx;
                } while (Math.abs(dx / x) > 5e-3);
                bnd = x;
                for (var i2 = 1; i2 < N2; i2++)
                  K[i2] = (N2 - i2) * p2[i2] / N2;
                K[0] = p2[0];
                aa = p2[N2];
                bb = p2[NM1];
                zerok = K[NM1] == 0 ? 1 : 0;
                for (jj = 0; jj < 5; jj++) {
                  cc = K[NM1];
                  if (zerok) {
                    for (var i2 = 0; i2 < NM1; i2++) {
                      j2 = NM1 - i2;
                      K[j2] = K[j2 - 1];
                    }
                    K[0] = 0;
                    zerok = K[NM1] == 0 ? 1 : 0;
                  } else {
                    t = -aa / cc;
                    for (var i2 = 0; i2 < NM1; i2++) {
                      j2 = NM1 - i2;
                      K[j2] = t * K[j2 - 1] + p2[j2];
                    }
                    K[0] = p2[0];
                    zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10 ? 1 : 0;
                  }
                }
                for (var i2 = 0; i2 < N2; i2++)
                  temp[i2] = K[i2];
                for (jj = 1; jj <= 20; jj++) {
                  xxx = -(sinr * yy) + cosr * xx;
                  yy = sinr * xx + cosr * yy;
                  xx = xxx;
                  sr = bnd * xx;
                  u = -(2 * sr);
                  Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N2, p2, NN, qp, u, Fxshfr_Par);
                  if (Fxshfr_Par.NZ != 0) {
                    j2 = degPar.Degree - N2;
                    zeror2[j2] = Fxshfr_Par.szr;
                    zeroi2[j2] = Fxshfr_Par.szi;
                    NN = NN - Fxshfr_Par.NZ;
                    N2 = NN - 1;
                    for (var i2 = 0; i2 < NN; i2++)
                      p2[i2] = qp[i2];
                    if (Fxshfr_Par.NZ != 1) {
                      zeror2[j2 + 1] = Fxshfr_Par.lzr;
                      zeroi2[j2 + 1] = Fxshfr_Par.lzi;
                    }
                    break;
                  } else {
                    for (var i2 = 0; i2 < N2; i2++) {
                      K[i2] = temp[i2];
                    }
                  }
                }
                if (jj > 20) {
                  degPar.Degree -= N2;
                  break;
                }
              }
              return;
            }
            rpSolve(degreePar, p, zeror, zeroi);
            var l = zeroi.length;
            for (i = 0; i < l; i++) {
              var img = round(zeroi[i], decp + 8), real = round(zeror[i], decp + 8);
              real = decp - String(real).length > 2 ? real : zeror[i];
              var sign = img < 0 ? "-" : "";
              if (real === 0) {
                real = "";
              }
              if (img === 0) {
                img = "";
              }
              img = Math.abs(img) === 1 ? sign + "i" : img ? img + "*i" : "";
              var num = real && img ? real + "+" + img : real + img;
              zeror[i] = num.replace(/\+\-/g, "-");
            }
            return zeror;
          }
        },
        roots: function(symbol) {
          if (symbol.isConstant(true, true)) {
            return core.Utils.nroots(symbol);
          }
          var roots = __.proots(symbol).map(function(x) {
            return _.parse(x);
          });
          return core.Vector.fromArray(roots);
        },
        froot: function(f, guess, dx) {
          var newtonraph = function(xn) {
            var mesh = 1e-12, df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())), fn = f instanceof Function ? f : core.Utils.build(f), max = 1e4, done = false, safety = 0;
            while (!done) {
              var x = xn - fn(xn) / df(xn);
              var r = Math.abs(x) - Math.abs(xn), delta = Math.abs(r);
              xn = x;
              if (delta < mesh)
                done = true;
              else if (safety > max) {
                xn = null;
                done = true;
              }
              safety++;
            }
            return xn;
          };
          return newtonraph(Number(guess));
        },
        quad: function(a, b, c) {
          var q = function(a2, b2, c2, sign) {
            return _.parse("-(" + b2 + "+" + sign + "*sqrt((" + b2 + ")^2-4*(" + a2 + ")*(" + c2 + ")))/(2*" + a2 + ")");
          };
          return [q(a, b, c, 1), q(a, b, c, -1)];
        },
        sumProd: function(a, b) {
          return __.quad(-b, a, -1).map(function(x) {
            return x.invert();
          });
        },
        coeffs: function(symbol, wrt, coeffs) {
          wrt = String(wrt);
          symbol = _.expand(symbol);
          coeffs = coeffs || [new Symbol(0)];
          if (symbol.group === EX && symbol.contains(wrt, true))
            _.error("Unable to get coefficients using expression " + symbol.toString());
          var vars = variables(symbol);
          if (vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {
            var a = new Polynomial(symbol).coeffs.map(function(x) {
              return new Symbol(x);
            });
            for (var i = 0, l = a.length; i < l; i++) {
              var coeff = a[i], e = coeffs[i];
              if (e)
                coeff = _.add(e, coeff);
              coeffs[i] = coeff;
            }
          } else {
            if (!wrt)
              _.error("Polynomial contains more than one variable. Please specify which variable is to be used!");
            if (vars.indexOf(wrt) === -1) {
              coeffs[0] = _.add(symbol, coeffs[0]);
            } else {
              coeffs = coeffs || [new Symbol(0)];
              if (symbol.group === CB) {
                var s = symbol.symbols[wrt];
                if (!s)
                  _.error("Expression is not a polynomial!");
                var p = Number(s.power);
                coeff = _.divide(symbol.clone(), s.clone());
                if (coeff.contains(wrt, true) || p < 0 || !isInt(p))
                  _.error("Expression is not a polynomial!");
                var e = coeffs[p];
                if (e)
                  coeff = _.add(e, coeff);
                coeffs[p] = coeff;
              } else if (symbol.group === CP) {
                symbol.each(function(x) {
                  __.coeffs(x.clone(), wrt, coeffs);
                }, true);
              }
            }
          }
          for (var i = 0, l = coeffs.length; i < l; i++)
            if (typeof coeffs[i] === "undefined")
              coeffs[i] = new Symbol(0);
          return coeffs;
        },
        /**
         * Get's all the powers of a particular polynomial including the denominators. The denominators powers
         * are returned as negative. All remaining polynomials are returned as zero order polynomials.
         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]
         * @param {Symbol} e
         * @param {String} for_variable
         * @param {Array} powers
         * @returns {Array} An array of the powers
         */
        //assumes you've already verified that it's a polynomial
        polyPowers: function(e, for_variable, powers) {
          powers = powers || [];
          var g = g = e.group;
          if (g === PL && for_variable === e.value) {
            powers = powers.concat(keys(e.symbols));
          } else if (g === CP) {
            for (var s in e.symbols) {
              var symbol = e.symbols[s];
              var g = symbol.group, v = symbol.value;
              if (g === S && for_variable === v)
                powers.push(symbol.power);
              else if (g === PL || g === CP)
                powers = __.polyPowers(symbol, for_variable, powers);
              else if (g === CB && symbol.contains(for_variable)) {
                var t = symbol.symbols[for_variable];
                if (t)
                  powers.push(t.power);
              } else if (g === N || for_variable !== v)
                powers.push(0);
            }
          } else if (g === CB && e.contains(for_variable)) {
            powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);
          }
          return core.Utils.arrayUnique(powers).sort();
        },
        //The factor object
        Factor: {
          //splits the symbol in symbol and constant
          split: function(symbol) {
            var c = new Symbol(1);
            var s = new Symbol(1);
            __.Factor.factor(symbol, new Factors()).each(function(x) {
              var t = _.parse(x);
              if (x.isConstant(true)) {
                c = _.multiply(c, t);
              } else {
                s = _.multiply(s, t);
              }
            });
            return [c, s];
          },
          mix: function(o, include_negatives) {
            var factors = keys(o);
            var l = factors.length;
            var m = [];
            for (var i = 0; i < l; i++) {
              var factor = factors[i], p = o[factor];
              var ll = m.length;
              for (var j = 0; j < ll; j++) {
                var t = m[j] * factor;
                m.push(t);
                if (include_negatives)
                  m.push(-t);
              }
              for (var j = 1; j <= p; j++)
                m.push(Math.pow(factor, j));
            }
            return m;
          },
          //TODO: this method is to replace common factoring
          common: function(symbol, factors) {
            try {
              if (symbol.group === CP) {
                var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function(a, b) {
                  return (b.length || 1) - (a.length || 1);
                });
                var map = {};
                var coeffs = [];
                for (var i = 0; i < symbols.length; i++) {
                  var sym = symbols[i];
                  coeffs.push(sym.multiplier.clone());
                  sym.each(function(x2) {
                    var p = Number(x2.power);
                    if (isNaN(p))
                      throw new Error("exiting");
                    if (x2.value in map) {
                      if (p < map[x2.value][0])
                        map[x2.value][0] = p;
                      map[x2.value][1].push(x2);
                    } else
                      map[x2.value] = [p, [x2]];
                  });
                }
                var factor = new Symbol(1);
                for (var x in map) {
                  if (map[x][1].length === symbols.length) {
                    factor = _.multiply(factor, _.pow(new Symbol(x), new Symbol(map[x][0])));
                  }
                }
                var c = core.Math2.QGCD.apply(null, coeffs);
                if (!c.equals(1)) {
                  factors.add(new Symbol(c));
                  for (var i = 0; i < symbols.length; i++) {
                    symbols[i].multiplier = symbols[i].multiplier.divide(c);
                  }
                }
                if (!factor.equals(1)) {
                  factors.add(factor);
                  symbol = new Symbol(0);
                  for (var i = 0; i < symbols.length; i++) {
                    symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));
                  }
                }
              }
            } catch (e) {
              ;
            }
            return symbol;
          },
          zeroes: function(symbol, factors) {
            var exit = function() {
              throw new core.exceptions.ValueLimitExceededError("Exiting");
            };
            try {
              var vars, term, sum, p, e;
              symbol = _.expand(symbol.clone());
              e = symbol.toString();
              vars = variables(symbol);
              sum = new Symbol(0);
              var terms = [];
              var powers = [];
              for (var i = 0, l = vars.length; i < vars.length; i++) {
                var subs = {};
                for (var j = 0; j < l; j++)
                  if (i !== j)
                    subs[vars[j]] = 0;
                term = _.parse(e, subs);
                var tp = term.power;
                if (!isInt(tp))
                  exit();
                terms.push(term);
                powers.push(term.power);
              }
              if (core.Utils.allSame(powers)) {
                var n_terms = symbol.length;
                var n_zeroes = terms.length;
                if (n_zeroes === 2) {
                  p = new Frac(powers[0] / (n_terms - 1));
                }
                if (n_zeroes === 3) {
                  p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));
                }
              } else
                p = core.Math2.QGCD.apply(null, powers);
              if (!isInt(p))
                exit();
              for (var i = 0; i < terms.length; i++) {
                var t = terms[i];
                var n = t.power.clone().divide(p);
                t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n));
                t.power = p.clone();
                sum = _.add(sum, t);
              }
              if (sum.group !== CP)
                return symbol;
              while (true) {
                var d = __.div(symbol.clone(), sum.clone());
                if (d[1].equals(0)) {
                  symbol = d[0];
                  factors.add(sum.clone());
                  if (symbol.equals(1))
                    break;
                } else
                  break;
              }
            } catch (e2) {
            }
            ;
            return symbol;
          },
          factor: function(symbol, factors) {
            if (symbol.isConstant()) {
              return core.Math2.factor(symbol);
            }
            var _symbol = _.parse(symbol);
            var retval = __.Factor._factor(_symbol, factors);
            if (retval.equals(symbol)) {
              return retval;
            }
            if (retval.group === CB) {
              var t = new Symbol(1);
              var p = _.parse(retval.power);
              var m = _.parse(retval.multiplier);
              retval.toUnitMultiplier();
              if (retval.multiplier.lessThan(0)) {
                t.negate();
                retval.negate();
              }
              retval.each(function(x) {
                var factored = _.parse(__.Factor._factor(x));
                if (factored.group === CB) {
                  m = _.multiply(m, Symbol.create(factored.multiplier));
                  factored.each(function(y) {
                    var _factored = _.parse(__.Factor._factor(y));
                    t = _.multiply(t, _factored);
                    if (_factored.group === CB) {
                      m = _.multiply(m, Symbol.create(_factored.multiplier));
                    }
                  });
                } else {
                  t = _.multiply(t, factored);
                }
              });
              retval = _.pow(_.multiply(m, t), p);
            }
            return retval;
          },
          quadFactor: function(symbol, factors) {
            if (symbol.isPoly() && __.degree(symbol.equals(2))) {
              var v = core.Utils.variables(symbol)[0];
              var coeffs = __.coeffs(symbol, v);
              var cf = __.Factor._factor(coeffs[2].clone());
              if (cf.group === CB) {
                var symbols = cf.collectSymbols();
                if (symbols.length > 2)
                  return symbol;
                var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));
                var b = _.parse(coeffs[1]).negate();
                var a = _.parse(symbols[1]);
                var root = __.quad(a, b, c).filter(function(x) {
                  if (core.Utils.isInt(x))
                    return x;
                });
                if (root.length === 1) {
                  var root1 = root[0];
                  var root2 = _.divide(coeffs[0], _.parse(root1));
                  if (core.Utils.isInt(root2)) {
                    factors.add(_.parse(format("({0})*({1})+({2})", symbols[1], v, root2)));
                    factors.add(_.parse(format("({0})*({1})+({2})", symbols[0], v, root1)));
                    symbol = new Symbol(1);
                  }
                }
              }
            }
            return symbol;
          },
          cubeFactor: function(symbol, factors) {
            if (symbol.isComposite()) {
              var symbols = symbol.collectSymbols();
              if (symbols.length === 2) {
                var sign_a = symbols[0].sign();
                var a = symbols[0].clone().abs();
                var sign_b = symbols[1].sign();
                var b = symbols[1].clone().abs();
                if (a.isCube() && b.isCube()) {
                  if (sign_a < sign_b) {
                    [sign_a, sign_b] = [sign_b, sign_a];
                    [a, b] = [b, a];
                  }
                  var m_root_a = _.parse(a.getNth(3));
                  var m_root_b = _.parse(b.getNth(3));
                  var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse("1/3"))), m_root_a);
                  var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse("1/3"))), m_root_b);
                  if (sign_a === 1 && sign_b === -1) {
                    factors.add(_.parse(format("(({0})-({1}))", x, y)));
                    factors.add(_.parse(format("(({0})^2+({0})*({1})+({1})^2)", x, y)));
                    symbol = Symbol(1);
                  } else if (sign_a === 1 && sign_b === 1) {
                    factors.add(_.parse(format("(({0})+({1}))", x, y)));
                    factors.add(_.parse(format("(({0})^2-({0})*({1})+({1})^2)", x, y)));
                    symbol = Symbol(1);
                  }
                }
              }
            }
            return symbol;
          },
          _factor: function(symbol, factors) {
            var g = symbol.group;
            if (symbol.group === FN) {
              var arg = symbol.args[0];
              if (arg.group === S && arg.isSimple()) {
                return symbol;
              }
            } else if (symbol.group === S && symbol.isSimple()) {
              return symbol;
            }
            if (symbol.group === CP) {
              symbol.distributeMultiplier(true);
              var t = new Symbol(0);
              symbol.each(function(x2) {
                if (x2.group === CP && x2.power.greaterThan(1) || x2.group === CB)
                  x2 = _.expand(x2);
                t = _.add(t, x2);
              });
              t.power = symbol.power;
              symbol = t;
            }
            if (symbol.group === FN && symbol.fname !== "sqrt") {
              symbol = core.Utils.evaluate(symbol);
            }
            var untouched = symbol.clone();
            try {
              if (symbol.group === CB) {
                var p = _.parse(symbol.power);
                var den_array, num_array, den, num, dfact, nfact;
                den_array = __.Simplify.strip(symbol.getDenom());
                num_array = __.Simplify.strip(symbol.getNum());
                den = den_array.pop();
                num = num_array.pop();
                if (num.equals(symbol)) {
                  return symbol;
                }
                nfact = __.Factor.factor(num);
                dfact = __.Factor.factor(den);
                var n = __.Simplify.unstrip(num_array, nfact);
                var d = __.Simplify.unstrip(den_array, dfact);
                var retval = _.divide(n, d);
                return retval;
              }
              if (symbol.group === S) {
                return symbol;
              }
              if (symbol.isConstant()) {
                if (symbol.equals(1))
                  return symbol.clone();
                var ret = core.Math2.factor(symbol);
                return ret;
              }
              var p = symbol.power.clone();
              if (isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {
                var sign = p.sign();
                symbol.toLinear();
                factors = factors || new Factors();
                var map = {};
                symbol = _.parse(core.Utils.subFunctions(symbol, map));
                if (keys(map).length > 0) {
                  factors.preAdd = function(factor) {
                    var ret2 = _.parse(factor, core.Utils.getFunctionsSubs(map));
                    return ret2;
                  };
                }
                if (!symbol.isLinear()) {
                  factors.pFactor = symbol.power.toString();
                  symbol.toLinear();
                }
                var vars = variables(symbol);
                if (symbol.isImaginary()) {
                  vars.push(core.Settings.IMAGINARY);
                }
                var multiVar = vars.length > 1;
                if (multiVar) {
                  var all_S = true, all_unit = true;
                  symbol.each(function(x2) {
                    if (x2.group !== S)
                      all_S = false;
                    if (!x2.multiplier.equals(1))
                      all_unit = false;
                  });
                  if (all_S && all_unit) {
                    return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));
                  }
                }
                var coeff_factors = new Factors();
                symbol = __.Factor.coeffFactor(symbol, coeff_factors);
                coeff_factors.each(function(x2) {
                  if (even(p) && x2.lessThan(0)) {
                    x2.negate();
                  }
                  if (sign < 0)
                    x2.invert();
                  factors.add(x2);
                });
                var power_factors = new Factors();
                symbol = __.Factor.powerFactor(symbol, power_factors);
                power_factors.each(function(x2) {
                  if (sign < 0)
                    x2.invert();
                  factors.add(x2);
                });
                if (!multiVar) {
                  var v = vars[0];
                  symbol = __.Factor.squareFree(symbol, factors, v);
                  var t_factors = new Factors();
                  symbol = __.Factor.trialAndError(symbol, t_factors, v);
                  var tf_symbol = t_factors.toSymbol();
                  if (tf_symbol.equals(untouched)) {
                    return tf_symbol;
                  }
                  for (var x in t_factors.factors) {
                    var t_factor = t_factors.factors[x];
                    factors.add(_.pow(t_factor, _.parse(p)));
                  }
                  if (symbol.equals(untouched)) {
                    symbol = __.Factor.quadFactor(symbol, factors);
                  }
                } else {
                  symbol = __.Factor.cubeFactor(symbol, factors);
                  symbol = __.Factor.mfactor(symbol, factors);
                  factors.each(function(x2) {
                    if (sign < 0)
                      x2.power.negate();
                  });
                }
                symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));
                var addPower = factors.length === 1;
                factors.add(_.pow(symbol, _.parse(p)));
                var retval = factors.toSymbol();
                if (addPower && symbol.equals(1) && retval.isLinear()) {
                  retval = _.pow(retval, _.parse(p));
                }
                return retval;
              }
              return symbol;
            } catch (e) {
              return untouched;
            }
          },
          reduce: function(symbol, factors) {
            if (symbol.group === CP && symbol.length === 2) {
              var symbols = symbol.collectSymbols().sort(function(a2, b2) {
                return b2.multiplier - a2.multiplier;
              });
              if (symbols[0].power.equals(symbols[1].power)) {
                var n = _.parse(symbols[0].power), a = symbols[0].clone().toLinear(), b = symbols[1].clone().toLinear();
                factors.add(_.add(a.clone(), b.clone()));
                b.negate();
                var nn = Number(n);
                var result = new Symbol(0);
                for (var i = 1; i <= nn; i++) {
                  var aa = _.pow(a.clone(), _.subtract(n.clone(), new Symbol(i))), bb = _.pow(b.clone(), _.subtract(new Symbol(i), new Symbol(1)));
                  result = _.add(result, _.multiply(aa, bb));
                }
                return result;
              }
            }
            return symbol;
          },
          /**
           * Makes Symbol square free
           * @param {Symbol} symbol
           * @param {Factors} factors
           * @@param {String} variable The variable which is being factored 
           * @returns {[Symbol, Factor]}
           */
          squareFree: function(symbol, factors, variable) {
            if (symbol.isConstant() || symbol.group === S)
              return symbol;
            var poly = new Polynomial(symbol, variable);
            var sqfr = poly.squareFree();
            var p = sqfr[2];
            if (p !== 1) {
              var t = sqfr[1].toSymbol();
              t.power = t.power.multiply(new Frac(p));
              factors.add(__.Factor.factor(t));
              var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);
              return retval;
            }
            return symbol;
          },
          /**
           * Factors the powers such that the lowest power is a constant
           * @param {Symbol} symbol
           * @param {Factors} factors
           * @returns {[Symbol, Factor]}
           */
          powerFactor: function(symbol, factors) {
            if (symbol.group !== PL || symbol.previousGroup === EX)
              return symbol;
            var k = keys(symbol.symbols);
            if (!core.Utils.allNumeric(k))
              return symbol;
            var d = core.Utils.arrayMin(k);
            var retval = new Symbol(0);
            var q = _.parse(symbol.value + "^" + d);
            symbol.each(function(x) {
              x = _.divide(x, q.clone());
              retval = _.add(retval, x);
            });
            factors.add(q);
            return retval;
          },
          /**
           * Removes GCD from coefficients
           * @param {Symbol} symbol
           * @param {Factor} factors
           * @returns {Symbol}
           */
          coeffFactor: function(symbol, factors) {
            if (symbol.isComposite()) {
              var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());
              if (!gcd.equals(1)) {
                symbol.each(function(x) {
                  if (x.isComposite()) {
                    x.each(function(y) {
                      y.multiplier = y.multiplier.divide(gcd);
                    });
                  } else
                    x.multiplier = x.multiplier.divide(gcd);
                });
                symbol.updateHash();
              } else {
                var power = function(symbol2) {
                  var p;
                  if (symbol2.group === CB) {
                    p = 0;
                    symbol2.each(function(x) {
                      p += x.power;
                    });
                  } else {
                    p = Number(symbol2.power);
                  }
                  return p;
                };
                var terms = symbol.collectSymbols(null, null, null, true).sort(function(a, b) {
                  if (a.isConstant(true))
                    return 1;
                  return b.power - a.power;
                });
                var LT = terms[0];
                if (power(LT) > power(terms[1]) || terms[1].isConstant(true)) {
                  if (LT.multiplier.lessThan(0)) {
                    factors.add(new Symbol(-1));
                    symbol.each(function(x) {
                      x.negate();
                    }, true);
                  }
                }
              }
              if (factors) {
                factors.add(new Symbol(gcd));
              }
            }
            return symbol;
          },
          /**
           * The name says it all :)
           * @param {Symbol} symbol
           * @param {Factor} factors
           * @@param {String} variable 
           * @returns {Symbol}
           */
          trialAndError: function(symbol, factors, variable) {
            var untouched = symbol.clone();
            try {
              var factor_array = [];
              if (symbol.isConstant() || symbol.group === S)
                return symbol;
              var poly = new Polynomial(symbol, variable), cnst = poly.coeffs[0], cfactors = core.Math2.ifactor(cnst), roots = __.proots(symbol);
              for (var i = 0; i < roots.length; i++) {
                var r = roots[i], p = 1;
                if (!isNaN(r)) {
                  for (var x in cfactors) {
                    var n = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);
                    if (isInt(n)) {
                      r = x;
                      p = n;
                      break;
                    }
                  }
                  var root = new Frac(r), terms = [new Frac(root.num).negate()];
                  terms[p] = new Frac(root.den);
                  var div = Polynomial.fromArray(terms, poly.variable).fill(), t = poly.divide(div);
                  if (t[1].equalsNumber(0)) {
                    poly = t[0];
                    factor_array.push(div.toSymbol());
                  }
                }
              }
              if (!poly.equalsNumber(1)) {
                poly = __.Factor.search(poly, factors);
              }
              factor_array.forEach(function(x2) {
                factors.add(x2);
              });
              return poly.toSymbol();
            } catch (e) {
              return untouched;
            }
          },
          search: function(poly, factors, base) {
            base = base || 10;
            var v = poly.variable;
            var check = function(c1, c2, n, p) {
              var candidate = Polynomial.fit(c1, c2, n, base, p, v);
              if (candidate && candidate.coeffs.length > 1) {
                var t = poly.divide(candidate);
                if (t[1].equalsNumber(0)) {
                  factors.add(candidate.toSymbol());
                  return [t[0], candidate];
                }
              }
              return null;
            };
            var cnst = poly.coeffs[0];
            var cfactors = core.Math2.ifactor(cnst);
            var lc = poly.lc();
            var ltfactors = core.Math2.ifactor(lc);
            var subbed = poly.sub(base);
            var isubbed = core.Math2.ifactor(subbed);
            var nfactors = __.Factor.mix(isubbed, subbed < 0);
            var cp = Math.ceil(poly.coeffs.length / 2);
            var lc_is_neg = lc.lessThan(0);
            var cnst_is_neg = cnst.lessThan(0);
            ltfactors["1"] = 1;
            cfactors["1"] = 1;
            while (cp--) {
              for (var x in ltfactors) {
                for (var y in cfactors) {
                  for (var i = 0; i < nfactors.length; i++) {
                    var factor_found = check(x, y, nfactors[i], cp);
                    if (factor_found) {
                      poly = factor_found[0];
                      if (!core.Utils.isPrime(poly.sub(base)))
                        poly = __.Factor.search(poly, factors);
                      return poly;
                    } else if (!factor_found) {
                      if (lc_is_neg && cnst_is_neg)
                        factor_found = check(-x, -y, nfactors[i], cp);
                      else if (lc_is_neg)
                        factor_found = check(-x, y, nfactors[i], cp);
                      else if (cnst_is_neg)
                        factor_found = check(x, -y, nfactors[i], cp);
                    }
                  }
                }
              }
            }
            return poly;
          },
          /**
           * Equivalent of square free factor for multivariate polynomials
           * @param {type} symbol
           * @param {type} factors
           * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}
           */
          mSqfrFactor: function(symbol, factors) {
            if (symbol.group !== FN) {
              var vars = variables(symbol).reverse();
              for (var i = 0; i < vars.length; i++) {
                do {
                  if (vars[i] === symbol.value) {
                    factors.add(symbol);
                    symbol = new Symbol(1);
                    continue;
                  }
                  var diff = core.Calculus.diff(symbol, vars[i]);
                  var d = __.Factor.coeffFactor(diff);
                  if (d.equals(0))
                    break;
                  var can_divide = true;
                  if (d.isConstant() && symbol.isComposite()) {
                    symbol.each(function(x) {
                      if (x.multiplier % d !== 0)
                        can_divide = false;
                    }, true);
                  }
                  if (can_divide) {
                    var div = __.div(symbol, d.clone()), is_factor = div[1].equals(0);
                    if (symbol.equals(div[0]) && div[1].equals(0)) {
                      break;
                    }
                    if (div[0].isConstant()) {
                      factors.add(div[0]);
                      break;
                    }
                  } else
                    is_factor = false;
                  if (is_factor) {
                    factors.add(div[0]);
                    symbol = d;
                  }
                } while (is_factor);
              }
            }
            return symbol;
          },
          //difference of squares factorization
          sqdiff: function(symbol, factors) {
            if (symbol.isConstant("all")) {
              return symbol;
            }
            try {
              var remove_square = function(x2) {
                return core.Utils.block("POSITIVE_MULTIPLIERS", function() {
                  return Symbol.unwrapPARENS(math.sqrt(math.abs(x2)));
                }, true);
              };
              var separated = core.Utils.separate(symbol.clone());
              var obj_array = [];
              for (var x in separated) {
                if (x !== "constants") {
                  obj_array.push(separated[x]);
                }
              }
              obj_array.sort(function(a2, b2) {
                return b2.power - a2.power;
              });
              if (obj_array.length === 2) {
                var a, b;
                a = obj_array.pop();
                b = obj_array.pop();
                if (even(a.power) && even(b.power) && a.sign() === b.sign() && a.group === S && b.group === S) {
                  throw new Error("Unable to factor");
                }
                ;
                if (a.isComposite() && b.power.equals(2)) {
                  b = remove_square(b);
                  var f = __.Factor.factor(_.add(a, separated.constants));
                  if (f.power.equals(2)) {
                    f.toLinear();
                    factors.add(_.subtract(f.clone(), b.clone()));
                    factors.add(_.add(f, b));
                    symbol = new Symbol(1);
                  }
                } else {
                  a = a.powSimp();
                  b = b.powSimp();
                  if ((a.group === S || a.fname === "") && a.power.equals(2) && (b.group === S || b.fname === "") && b.power.equals(2) && !separated.constants) {
                    if (a.multiplier.lessThan(0)) {
                      var t = b;
                      b = a;
                      a = t;
                    }
                    if (a.multiplier.greaterThan(0)) {
                      a = remove_square(a);
                      b = remove_square(b);
                    }
                    factors.add(_.subtract(a.clone(), b.clone()));
                    factors.add(_.add(a, b));
                    symbol = new Symbol(1);
                  }
                }
              }
            } catch (e) {
              ;
            }
            return symbol;
          },
          //factoring for multivariate
          mfactor: function(symbol, factors) {
            if (symbol.group === FN) {
              if (symbol.fname === "sqrt") {
                var factors2 = new Factors(), arg = __.Factor.common(symbol.args[0].clone(), factors2);
                arg = __.Factor.coeffFactor(arg, factors2);
                symbol = _.multiply(_.symfunction("sqrt", [arg]), _.parse(symbol.multiplier));
                factors2.each(function(x2) {
                  symbol = _.multiply(symbol, _.parse(core.Utils.format("sqrt({0})", x2)));
                });
              } else
                factors.add(symbol);
            } else {
              symbol = __.Factor.mSqfrFactor(symbol, factors);
              var vars = variables(symbol), symbols = symbol.collectSymbols().map(function(x2) {
                return Symbol.unwrapSQRT(x2);
              }), sorted = {}, maxes = {}, l = vars.length, n = symbols.length;
              for (var i = 0; i < l; i++) {
                var v = vars[i];
                sorted[v] = new Symbol(0);
                for (var j = 0; j < n; j++) {
                  var s = symbols[j];
                  if (s.contains(v)) {
                    var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();
                    if (!maxes[v] || p < maxes[v])
                      maxes[v] = p;
                    sorted[v] = _.add(sorted[v], s.clone());
                  }
                }
              }
              for (var x in sorted) {
                var r = _.parse(x + "^" + maxes[x]);
                var div = _.divide(sorted[x], r);
                var new_factor = _.expand(div);
                if (new_factor.equals(1))
                  break;
                var divided = __.div(symbol.clone(), new_factor);
                if (divided[0].equals(0)) {
                  break;
                }
                if (divided[1].equals(0)) {
                  var has_fractions = false;
                  divided[0].each(function(x2) {
                    if (!isInt(x2.multiplier)) {
                      has_fractions = true;
                    }
                  });
                  if (has_fractions) {
                    divided[1] = _.expand(_.multiply(divided[1], new_factor));
                    break;
                  }
                }
                var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);
                if (divided[1].equals(0) && !neg_numeric_factor) {
                  var d = __.div(symbol.clone(), divided[0].clone());
                  var r = d[0];
                  if (r.equals(0)) {
                    return symbol;
                  }
                  symbol = d[1];
                  if (r.equals(-1) && !symbol.equals(0))
                    return symbol;
                  var factor = divided[0];
                  if (symbol.equals(factor)) {
                    var rem = __.Factor.reduce(factor, factors);
                    if (!symbol.equals(rem))
                      return __.Factor.mfactor(rem, factors);
                    return rem;
                  } else {
                    factors.add(factor);
                    if (symbol.equals(0))
                      return r;
                  }
                  if (r.isConstant("all")) {
                    factors.add(r);
                    return r;
                  }
                  return __.Factor.mfactor(r, factors);
                }
              }
            }
            symbol = __.Factor.sqdiff(symbol, factors);
            symbol = __.Factor.zeroes(symbol, factors);
            return symbol;
          }
        },
        /**
         * Checks to see if a set of "equations" is linear. 
         * @param {type} set
         * @returns {Boolean}
         */
        allLinear: function(set) {
          var l = set.length;
          for (var i = 0; i < l; i++) {
            if (!__.isLinear(set[i]))
              return false;
          }
          return true;
        },
        /*
         * Checks to see if the "equation" is linear
         * @param {Symbol} e
         * @returns {boolean}
         */
        isLinear: function(e) {
          var status = false, g = e.group;
          if (g === PL || g === CP) {
            status = true;
            for (var s in e.symbols) {
              var symbol = e.symbols[s], sg = symbol.group;
              if (sg === FN || sg === EX) {
                status = false;
              }
              if (sg === CB) {
                status = variables(symbol).length === 1;
              } else {
                if (sg === PL || sg === CP)
                  status = __.isLinear(symbol);
                else {
                  if (symbol.group !== N && symbol.power.toString() !== "1") {
                    status = false;
                    break;
                  }
                }
              }
            }
          } else if (g === S && e.power === 1)
            status = true;
          return status;
        },
        gcd: function() {
          var args;
          if (arguments.length === 1 && arguments[0] instanceof core.Vector)
            args = arguments[0].elements;
          else
            args = core.Utils.arguments2Array(arguments);
          if (args.length === 0)
            return new Symbol(1);
          else if (args.length === 1)
            return args[0];
          var appeared = [], evaluate2 = false;
          for (var i = 0; i < args.length; i++) {
            if (args[i].group === FN && args[i].fname === "gcd") {
              args = args.concat(arguments[i].args);
              args.splice(i, 1);
            } else {
              var vars = variables(args[i]);
              if (core.Utils.haveIntersection(vars, appeared)) {
                evaluate2 = true;
                break;
              } else
                appeared = appeared.concat(vars);
            }
          }
          if (evaluate2 || appeared.length === 0) {
            if (args.every(function(symbol) {
              return symbol.getDenom().equals(1);
            })) {
              var aggregate = args[0];
              for (var i = 1; i < args.length; i++) {
                aggregate = __.gcd_(args[i], aggregate);
              }
              return aggregate;
            } else {
              return _.divide(
                __.gcd.apply(null, args.map(function(symbol) {
                  return symbol.getNum();
                })),
                __.lcm.apply(null, args.map(function(symbol) {
                  return symbol.getDenom();
                }))
              );
            }
          } else
            return _.symfunction("gcd", args);
        },
        gcd_: function(a, b) {
          if (a.group === FN || a.group === P)
            a = core.Utils.block("PARSE2NUMBER", function() {
              return _.parse(a);
            });
          if (b.group === FN)
            b = core.Utils.block("PARSE2NUMBER", function() {
              return _.parse(b);
            });
          if (a.isConstant() && b.isConstant()) {
            return new Symbol(core.Math2.QGCD(new Frac(+a), new Frac(+b)));
          }
          var den = _.multiply(a.getDenom() || new Symbol(1), b.getDenom() || new Symbol(1)).invert();
          a = _.multiply(a.clone(), den.clone());
          b = _.multiply(b.clone(), den.clone());
          a = _.expand(a);
          b = _.expand(b);
          if (a.group === CB || b.group === CB) {
            var q = _.divide(a.clone(), b.clone());
            var t = _.multiply(b.clone(), q.getDenom().invert());
            if (!t.equals(1))
              return t;
          }
          if (a.group === EX || b.group === EX) {
            var gcd_m = new Symbol(core.Math2.GCD(a.multiplier, b.multiplier));
            var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol(1) : _.parse(b.value));
            var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));
            return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));
          }
          if (a.length < b.length) {
            var t = a;
            a = b;
            b = t;
          }
          var vars_a = variables(a), vars_b = variables(b);
          if (vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0] || vars_a.length === 1 && vars_b.length === 0 || vars_a.length === 0 && vars_b.length === 1) {
            a = new Polynomial(a);
            b = new Polynomial(b);
            return _.divide(a.gcd(b).toSymbol(), den);
          } else {
            var multipliers = [];
            a.each(function(x) {
              multipliers.push(x.multiplier);
            });
            b.each(function(x) {
              multipliers.push(x.multiplier);
            });
            var T;
            while (!b.equals(0)) {
              var t = b.clone();
              a = a.clone();
              T = __.div(a, t);
              b = T[1];
              if (T[0].equals(0)) {
                return _.divide(new Symbol(core.Math2.QGCD(a.multiplier, b.multiplier)), den);
              }
              a = t;
            }
            var gcd = core.Math2.QGCD.apply(void 0, multipliers);
            if (!gcd.equals(1)) {
              a.each(function(x) {
                x.multiplier = x.multiplier.divide(gcd);
              });
            }
            if (a.equals(1) && !a.isConstant() && !b.isConstant())
              return _.divide(_.symfunction("gcd", arguments), den);
            return _.divide(a, den);
          }
        },
        lcm: function() {
          var args;
          if (arguments.length === 1)
            if (arguments[0] instanceof core.Vector)
              args = arguments[0].elements;
            else
              _.error("lcm expects either 1 vector or 2 or more arguments");
          else
            args = core.Utils.arguments2Array(arguments);
          var numer = args.reduce(function(prev, curr) {
            return _.multiply(prev, curr.clone());
          }, new Symbol(1));
          var denom_args = (
            //https://stackoverflow.com/a/18223072
            //take all complementary terms, e.g.
            //[a,b,c] => [a*b, b*c, a*c]
            //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]
            function(input, size) {
              size = Number(size);
              var results = [], result, mask, i, total = Math.pow(2, input.length);
              for (mask = size; mask < total; mask++) {
                result = [];
                i = input.length - 1;
                do {
                  if ((mask & 1 << i) !== 0) {
                    result.push(input[i]);
                  }
                } while (i--);
                if (result.length === size) {
                  results.push(result);
                }
              }
              return results;
            }(arguments, arguments.length - 1).map(function(x) {
              return x.reduce(function(prev, curr) {
                return _.multiply(prev, curr.clone());
              }, new Symbol(1));
            })
          );
          var denom;
          if (args.every(function(x) {
            return core.Utils.isVariableSymbol(x);
          }))
            denom = _.symfunction("gcd", core.Utils.arrayUnique(denom_args));
          else
            denom = __.gcd.apply(null, denom_args);
          var div = _.divide(numer, denom);
          return div;
        },
        /**
         * Divides one expression by another
         * @param {Symbol} symbol1
         * @param {Symbol} symbol2
         * @returns {Array}
         */
        divide: function(symbol1, symbol2) {
          var result, remainder, factored, den;
          factored = core.Algebra.Factor.factor(symbol1.clone());
          den = factored.getDenom();
          if (!den.isConstant("all")) {
            symbol1 = _.expand(Symbol.unwrapPARENS(_.multiply(factored, den.clone())));
          } else
            den = new Symbol(1);
          result = __.div(symbol1, symbol2);
          remainder = _.divide(result[1], symbol2);
          return _.divide(_.add(result[0], remainder), den);
        },
        div: function(symbol1, symbol2) {
          var fail = [new Symbol(0), symbol1.clone()];
          try {
            if (symbol2.isConstant("all")) {
              symbol1.each(function(x2) {
                x2.multiplier = x2.multiplier.divide(symbol2.multiplier);
              });
              return [symbol1, new Symbol(0)];
            }
            symbol1 = _.expand(symbol1);
            symbol2 = _.expand(symbol2);
            if (symbol1.group === S && symbol2.group === CP) {
              var x = symbol1.value;
              var f = core.Utils.decompose_fn(symbol2.clone(), x, true);
              if (symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {
                var k = Symbol.create(symbol1.multiplier);
                return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];
              }
            }
            if (symbol1.group === S && symbol2.group === S) {
              var r = _.divide(symbol1.clone(), symbol2.clone());
              if (r.isConstant())
                return [r, new Symbol(0)];
              return [new Symbol(0), symbol1.clone()];
            }
            var symbol1_has_func = symbol1.hasFunc(), symbol2_has_func = symbol2.hasFunc(), parse_funcs = false;
            if (symbol1_has_func || symbol2_has_func) {
              parse_funcs = true;
              var map = {}, symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)), symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)), subs = core.Utils.getFunctionsSubs(map);
            }
            var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))), quot, rem;
            if (symbol1.isImaginary() || symbol2.isImaginary()) {
              vars.push(core.Settings.IMAGINARY);
            }
            if (vars.length === 1) {
              var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));
              quot = q[0].toSymbol();
              rem = q[1].toSymbol();
            } else {
              vars.push(CONST_HASH);
              var reconvert = function(arr) {
                var symbol = new Symbol(0);
                for (var i2 = 0; i2 < arr.length; i2++) {
                  var x2 = arr[i2].toSymbol();
                  symbol = _.add(symbol, x2);
                }
                return symbol;
              };
              var get_unique_max = function(term, any) {
                var max2 = Math.max.apply(null, term.terms), count = 0, idx;
                if (!any) {
                  for (var i2 = 0; i2 < term.terms.length; i2++) {
                    if (term.terms[i2].equals(max2)) {
                      idx = i2;
                      count++;
                    }
                    if (count > 1)
                      return;
                  }
                }
                if (any) {
                  for (i2 = 0; i2 < term.terms.length; i2++)
                    if (term.terms[i2].equals(max2)) {
                      idx = i2;
                      break;
                    }
                }
                return [max2, idx, term];
              };
              var get_det = function(s, lookat) {
                lookat = lookat || 0;
                var det2 = s[lookat], l = s.length;
                if (!det2)
                  return;
                var umax = get_unique_max(det2);
                for (var i2 = lookat + 1; i2 < l; i2++) {
                  var term = s[i2], is_equal = det2.sum.equals(term.sum);
                  if (!is_equal && umax) {
                    break;
                  }
                  if (is_equal) {
                    var max1, max2, idx1, idx2, l22 = det2.terms.length;
                    for (var j2 = 0; j2 < l22; j2++) {
                      var item1 = det2.terms[j2], item2 = term.terms[j2];
                      if (typeof max1 === "undefined" || item1.greaterThan(max1)) {
                        max1 = item1;
                        idx1 = j2;
                      }
                      if (typeof max2 === "undefined" || item2.greaterThan(max2)) {
                        max2 = item2;
                        idx2 = j2;
                      }
                    }
                    var d1 = max1.subtract(term.terms[idx1]), d2 = max2.subtract(det2.terms[idx2]);
                    if (d2 > d1) {
                      umax = [max2, idx2, term];
                      break;
                    }
                    if (d1 > d2) {
                      umax = [max1, idx1, det2];
                      break;
                    }
                  } else {
                    umax = get_unique_max(term);
                    if (umax)
                      break;
                  }
                  umax = get_unique_max(term);
                }
                if (!umax)
                  return get_unique_max(s[0], true);
                var e, idx;
                for (var i2 = 0; i2 < s2.length; i2++) {
                  var cterm = s2[i2].terms;
                  idx = umax[1];
                  if (idx === cterm.length - 1)
                    return;
                  e = cterm[idx];
                  if (!e.equals(0))
                    break;
                }
                if (e.equals(0))
                  return get_det(s, ++lookat);
                return umax;
              };
              var t_map = core.Utils.toMapObj(vars);
              var init_sort = function(a, b) {
                return b.sum.subtract(a.sum);
              };
              var is_larger = function(a, b) {
                if (!a || !b)
                  return false;
                for (var i2 = 0; i2 < a.terms.length; i2++) {
                  if (a.terms[i2].lessThan(b.terms[i2]))
                    return false;
                }
                return true;
              };
              var s1 = symbol1.tBase(t_map).sort(init_sort), s2 = symbol2.tBase(t_map).sort(init_sort);
              var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1;
              var det = get_det(target);
              var quotient = [];
              if (det) {
                var lead_var = det[1];
                var can_divide = function(a, b) {
                  if (a[0].sum.equals(b[0].sum))
                    return a.length >= b.length;
                  return true;
                };
                var try_better_lead_var = function(s12, s22, lead_var2) {
                  var checked = [];
                  for (var i2 = 0; i2 < s12.length; i2++) {
                    var t2 = s12[i2];
                    for (var j2 = 0; j2 < t2.terms.length; j2++) {
                      var cf = checked[j2], tt = t2.terms[j2];
                      if (i2 === 0)
                        checked[j2] = tt;
                      else if (cf && !cf.equals(tt))
                        checked[j2] = void 0;
                    }
                  }
                  for (var i2 = 0; i2 < checked.length; i2++) {
                    var t2 = checked[i2];
                    if (t2 && !t2.equals(0))
                      return i2;
                  }
                  return lead_var2;
                };
                var sf = function(a, b) {
                  var l1 = a.len(), l22 = b.len();
                  var blv = b.terms[lead_var], alv = a.terms[lead_var];
                  if (l22 > l1 && blv.greaterThan(alv))
                    return l22 - l1;
                  return blv.subtract(alv);
                };
                lead_var = try_better_lead_var(s1, s2, lead_var);
                s1.sort(sf);
                s2.sort(sf);
                var fdt = s2[0], fnt = s1[0];
                var den = new MVTerm(new Frac(1), [], fnt.map);
                if (fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {
                  for (var i = 0; i < fnt.terms.length; i++) {
                    var d = fdt.terms[i].subtract(fnt.terms[i]);
                    if (!d.equals(0)) {
                      var nd = d.add(new Frac(1));
                      den.terms[i] = d;
                      for (var j = 0; j < s1.length; j++) {
                        s1[j].terms[i] = s1[j].terms[i].add(nd);
                      }
                    } else
                      den.terms[i] = new Frac(0);
                  }
                }
                var dividend_larger = is_larger(s1[0], s2[0]);
                var safety = 0;
                var max = 200;
                while (dividend_larger && can_divide(s1, s2)) {
                  if (safety++ > max) {
                    throw new core.exceptions.InfiniteLoopError("Unable to compute!");
                  }
                  var q = s1[0].divide(s2[0]);
                  quotient.push(q);
                  s1.shift();
                  for (var i = 1; i < s2.length; i++) {
                    var t = s2[i].multiply(q).generateImage(), l2 = s1.length;
                    if (l2 === 0) {
                      t.coeff = t.coeff.neg();
                      s1.push(t);
                      s1.sort(sf);
                    }
                    for (var j = 0; j < l2; j++) {
                      var cur = s1[j];
                      if (cur.getImg() === t.getImg()) {
                        cur.coeff = cur.coeff.subtract(t.coeff);
                        if (cur.coeff.equals(0)) {
                          core.Utils.remove(s1, j);
                          j--;
                        }
                        break;
                      }
                      if (j === l2 - 1) {
                        t.coeff = t.coeff.neg();
                        s1.push(t);
                        s1.sort(sf);
                      }
                    }
                  }
                  dividend_larger = is_larger(s1[0], s2[0]);
                  if (!dividend_larger && s1.length >= s2.length) {
                    for (var i = 1; i < s1.length; i++) {
                      dividend_larger = is_larger(s1[i], s2[0]);
                      if (dividend_larger) {
                        s1.unshift(core.Utils.remove(s1, i));
                        break;
                      }
                    }
                  }
                }
              }
              quot = reconvert(quotient);
              rem = reconvert(s1);
              if (typeof den !== "undefined") {
                den = den.toSymbol();
                quot = _.divide(quot, den.clone());
                rem = _.divide(rem, den);
              }
            }
            if (parse_funcs) {
              quot = _.parse(quot.text(), subs);
              rem = _.parse(rem.text(), subs);
            }
            return [quot, rem];
          } catch (e) {
            return fail;
          }
        },
        line: function(v1, v2, x) {
          if (core.Utils.isArray(v1))
            v1 = core.Utils.convertToVector(v1);
          if (core.Utils.isArray(v2))
            v2 = core.Utils.convertToVector(v2);
          x = _.parse(x || "x");
          if (!core.Utils.isVector(v1) || !core.Utils.isVector(v2))
            _.error('Line expects a vector! Received "' + v1 + '" & "' + v2 + '"');
          var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()), dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()), m = _.divide(dy, dx), a = _.multiply(x, m.clone()), b = _.multiply(v1.e(1).clone(), m);
          return _.add(_.subtract(a, b), v1.e(2).clone());
        },
        PartFrac: {
          createTemplate: function(den, denom_factors, f_array, v) {
            den = __.Factor.factor(den);
            den.each(function(x, key) {
              if (x.group === FN && x.fname === "" && x.args[0].group === S) {
                var y = x.args[0];
                if (this.symbols) {
                  delete this.symbols[key];
                  this.symbols[y.value] = y;
                } else {
                  den = x.args[0];
                }
              }
            });
            var factors, factors_vec, f, p, deg, degrees, m;
            factors = denom_factors.collectFactors();
            factors_vec = [];
            degrees = [];
            m = new Symbol(1);
            for (var i = 0; i < factors.length; i++) {
              var factor = Symbol.unwrapPARENS(factors[i]);
              if (factor.power.greaterThan(1)) {
                p = Number(factor.power);
                f = factor.clone().toLinear();
                deg = Number(__.degree(f, v));
                for (var j = 0; j < p; j++) {
                  var efactor = _.pow(f.clone(), new Symbol(j + 1));
                  f_array.push(efactor.clone());
                  var d = _.divide(den.clone(), efactor.clone());
                  degrees.push(deg);
                  factors_vec.push(d);
                }
              } else {
                deg = Number(__.degree(factor, v));
                f_array.push(factor);
                var d = _.divide(den.clone(), factor.clone());
                d = _.expand(Symbol.unwrapPARENS(d));
                degrees.push(deg);
                factors_vec.push(d);
              }
            }
            f_array = f_array.map(function(x) {
              return _.multiply(x, m.clone());
            });
            return [f_array, factors_vec, degrees];
          },
          partfrac: function(symbol, v, as_array) {
            var vars = variables(symbol);
            v = v || _.parse(vars[0]);
            try {
              var num, den, factors, tfactors, ofactors, nterms, degrees, dterms, max, M, c, powers, div, r, factors_vec, ks, template, tfactors;
              num = _.expand(symbol.getNum());
              den = _.expand(symbol.getDenom().toUnitMultiplier());
              num.multiplier = symbol.multiplier;
              nterms = num.groupTerms(v);
              if (Number(__.degree(num, v)) >= Number(__.degree(den, v))) {
                div = __.div(num.clone(), _.expand(den.clone()));
                r = div[0];
                num = div[1];
                nterms = num.groupTerms(v);
              } else
                r = new Symbol(0);
              if (Number(__.degree(den, v)) === 1) {
                var q = _.divide(num, den);
                if (as_array)
                  return [r, q];
                return _.add(r, q);
              }
              ofactors = __.Factor.factor(den);
              template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);
              tfactors = template[0];
              factors_vec = template[1];
              degrees = template[2];
              powers = [nterms.length];
              dterms = [];
              factors = [];
              ks = [];
              var factor, deg;
              factors_vec.map(function(x2, idx) {
                factor = tfactors[idx];
                deg = degrees[idx];
                for (var i2 = 0; i2 < deg; i2++) {
                  factors.push(factor.clone());
                  var k = Symbol.create(v, i2);
                  var t2 = _.expand(_.multiply(x2, k.clone())).groupTerms(v);
                  var p = t2.length;
                  powers.push(p);
                  dterms.push(t2);
                  ks.push(k.clone());
                }
              });
              max = core.Utils.arrayMax(powers);
              c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();
              M = new core.Matrix();
              for (var i = 0; i < dterms.length; i++) {
                M.elements.push(core.Utils.fillHoles(dterms[i], max));
              }
              var partials = _.multiply(M.transpose().invert(), c);
              var retval = as_array ? [r] : r;
              partials.each(function(e, i2) {
                var term = _.multiply(ks[i2], _.divide(e, factors[i2]));
                if (as_array)
                  retval.push(term);
                else
                  retval = _.add(retval, term);
              });
              return retval;
            } catch (e) {
              try {
                if (symbol.isComposite()) {
                  var denominators = {};
                  symbol.each(function(x2) {
                    var d = x2.getDenom();
                    var n = x2.getNum();
                    var e2 = denominators[d];
                    denominators[d] = e2 ? _.add(e2, n) : n;
                  });
                  var t = new Symbol(0);
                  for (var x in denominators) {
                    t = _.add(t, _.divide(denominators[x], _.parse(x)));
                  }
                  symbol = t;
                }
              } catch (e2) {
              }
              ;
            }
            ;
            return symbol;
          }
        },
        degree: function(symbol, v, o) {
          o = o || {
            nd: [],
            //numeric
            sd: [],
            //symbolic
            depth: 0
            //call depth
          };
          if (!v) {
            var vars = variables(symbol);
            if (vars.length > 1)
              throw new Error("You must specify the variable for multivariate polynomials!");
            if (vars.length === 0)
              return new Symbol(0);
            v = _.parse(vars[0]);
          }
          var g = symbol.group;
          if (symbol.isComposite()) {
            symbol = symbol.clone();
            symbol.distributeExponent();
            symbol.each(function(x) {
              o.depth++;
              __.degree(x, v, o);
              o.depth--;
            });
          } else if (symbol.group === CB) {
            symbol.each(function(x) {
              o.depth++;
              __.degree(x, v, o);
              o.depth++;
            });
          } else if (g === EX && symbol.value === v.value) {
            o.sd.push(symbol.power.clone());
          } else if (g === S && symbol.value === v.value) {
            o.nd.push(_.parse(symbol.power));
          } else
            o.nd.push(new Symbol(0));
          var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : void 0;
          if (o.depth === 0 && o.sd.length > 0) {
            if (deg !== void 0)
              o.sd.unshift(deg);
            return _.symfunction("max", o.sd);
          }
          if (!core.Utils.isSymbol(deg))
            deg = _.parse(deg);
          return deg;
        },
        /**
         * Attempts to complete the square of a polynomial
         * @param {type} symbol
         * @param {type} v
         * @param {type} raw
         * @throws {Error} 
         * @returns {Object|Symbol[]}
         */
        sqComplete: function(symbol, v, raw) {
          if (!core.Utils.isSymbol(v))
            v = _.parse(v);
          var stop = function(msg) {
            msg = msg || "Stopping";
            throw new core.exceptions.ValueLimitExceededError(msg);
          };
          if (!symbol.isPoly(true))
            stop("Must be a polynomial!");
          var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;
          br = core.Utils.inBrackets;
          symbol = symbol.clone();
          deg = core.Algebra.degree(symbol, v);
          if (!deg.equals(2))
            stop("Cannot complete square for degree " + deg);
          coeffs = core.Algebra.coeffs(symbol, v);
          a = coeffs[2];
          sign = coeffs[1].sign();
          b = _.divide(coeffs[1], new Symbol(2));
          c = _.pow(b.clone(), new Symbol(2));
          if (raw)
            return [a, b, d];
          sqrt_a = math.sqrt(a);
          e = _.divide(math.sqrt(c), sqrt_a.clone());
          d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol(2)));
          sym = _.parse(br(sqrt_a.clone() + "*" + v + (sign < 0 ? "-" : "+") + e));
          return {
            a: sym,
            c: d,
            f: _.add(_.pow(sym.clone(), new Symbol(2)), d.clone())
          };
        },
        Simplify: {
          strip: function(symbol) {
            var c = _.parse(symbol.multiplier);
            symbol.toUnitMultiplier();
            var p = _.parse(symbol.power);
            symbol.toLinear();
            return [c, p, symbol];
          },
          unstrip: function(cp, symbol) {
            var c = cp[0];
            var p = cp[1];
            return _.multiply(c, _.pow(symbol, p));
          },
          complexSimp: function(num, den) {
            var ac, bd, bc, ad, cd, r1, r2, i1, i2;
            r1 = num.realpart();
            i1 = num.imagpart();
            r2 = den.realpart();
            i2 = den.imagpart();
            ac = _.multiply(r1.clone(), r2.clone());
            bd = _.multiply(i1.clone(), i2.clone());
            bc = _.multiply(r2.clone(), i1);
            ad = _.multiply(r1, i2.clone());
            cd = _.add(_.pow(r2, new Symbol(2)), _.pow(i2, new Symbol(2)));
            return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol.imaginary())), cd);
          },
          trigSimp: function(symbol) {
            if (symbol.containsFunction(["cos", "sin", "tan"])) {
              symbol = symbol.clone();
              var sym_array = __.Simplify.strip(symbol);
              symbol = sym_array.pop();
              var retval = symbol.clone();
              if (symbol.group === CP) {
                var sym = new Symbol(0);
                symbol.each(function(x) {
                  var tr = __.Simplify.trigSimp(x.fnTransform());
                  sym = _.add(sym, tr);
                }, true);
                retval = _.pow(_.multiply(new Symbol(symbol.multiplier), sym), new Symbol(symbol.power));
              } else if (symbol.group === CB) {
                var n = symbol.getNum();
                var d = symbol.getDenom();
                if (n.fname === "sin" && d.fname === "cos" && n.args[0].equals(d.args[0]) && n.power.equals(d.power)) {
                  retval = _.parse(core.Utils.format("({0})*({1})*tan({2})^({3})", d.multiplier, n.multiplier, n.args[0], n.power));
                }
                if (retval.group === CB) {
                  var t = new Symbol(1);
                  retval.each(function(x) {
                    if (x.fname === "tan") {
                      x = _.parse(core.Utils.format("({0})*sin({1})^({2})/cos({1})^({2})", x.multiplier, __.Simplify.simplify(x.args[0]), x.power));
                    }
                    t = _.multiply(t, x);
                  });
                  retval = t;
                }
              }
              retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();
              symbol = retval;
            }
            return symbol;
          },
          fracSimp: function(symbol) {
            var den = symbol.getDenom();
            var num = symbol.getNum();
            if (num.isImaginary() && den.isImaginary())
              symbol = __.Simplify.complexSimp(num, den);
            if (symbol.isComposite()) {
              if (symbol.power > 1) {
                symbol = _.expand(symbol);
              }
              var symbols = symbol.collectSymbols();
              var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;
              a = symbols.pop();
              while (symbols.length) {
                b = symbols.pop();
                d1 = _.parse(a.getDenom());
                d2 = _.parse(b.getDenom());
                n1 = a.getNum();
                n2 = b.getNum();
                c = _.multiply(d1.clone(), d2.clone());
                x = _.multiply(n1, d2);
                y = _.multiply(n2, d1);
                s = _.add(x, y);
                a = _.divide(s, c);
              }
              den = _.expand(a.getDenom());
              num = _.expand(a.getNum());
              if (num.isImaginary() && den.isImaginary()) {
                retval = __.Simplify.complexSimp(num, den);
              } else {
                retval = _.divide(num, den);
              }
              if (retval.equals(symbol)) {
                return symbol;
              }
              return __.Simplify.simplify(retval);
            }
            return symbol;
          },
          ratSimp: function(symbol) {
            if (symbol.group === CB) {
              var den = symbol.getDenom();
              var num = symbol.getNum().distributeMultiplier();
              var d = __.Simplify.fracSimp(den);
              var n = __.Simplify.fracSimp(num);
              symbol = _.divide(n, d);
            }
            return symbol;
          },
          sqrtSimp: function(symbol, sym_array) {
            var retval;
            if (symbol.isSQRT()) {
              var factored = __.Factor.factor(symbol.args[0].clone());
              var m = _.parse(factored.multiplier);
              var sign = m.sign();
              var retval = _.sqrt(m.abs());
              var arg;
              if (isInt(retval)) {
                if (factored.group === CB) {
                  var rem = new Symbol(1);
                  factored.each(function(x) {
                    if (x.group === N) {
                      var trial = _.sqrt(x.clone());
                      if (isInt(trial)) {
                        retval = _.multiply(retval, trial);
                      } else {
                        rem = _.multiply(rem, x);
                      }
                    } else {
                      rem = _.multiply(rem, x);
                    }
                  });
                  var t = _.multiply(rem, _.parse(sign));
                  arg = _.sqrt(t.clone());
                  if (arg.isImaginary) {
                    arg = _.sqrt(_.expand(t.clone()));
                  }
                } else {
                  arg = _.sqrt(factored.clone().toUnitMultiplier());
                }
                return _.multiply(retval, arg);
              }
            } else if (symbol.isComposite() && symbol.isLinear()) {
              retval = new Symbol(0);
              symbol.each(function(x) {
                retval = _.add(retval, __.Simplify.sqrtSimp(x));
              }, true);
              retval = _.multiply(retval, _.parse(symbol.multiplier));
            } else if (symbol.group === CB) {
              retval = _.parse(symbol.multiplier);
              symbol.each(function(x) {
                var simp = __.Simplify.sqrtSimp(x);
                retval = _.multiply(retval, simp);
              }, true);
              retval = _.pow(retval, _.parse(symbol.power));
            }
            return retval ? retval : _.parse(symbol);
          },
          /**
           * Unused. The goal is to substitute out patterns but it currently doesn't work.
           * @param {Symbol} symbol
           * @return {Array} The symbol and the matched patterns
           */
          patternSub: function(symbol) {
            var patterns = {};
            var has_CP = function(symbol2) {
              var found = false;
              symbol2.each(function(x) {
                if (x.group === CP) {
                  found = true;
                } else if (x.symbols) {
                  found = has_CP(x);
                }
              });
              return found;
            };
            var collect = function(sym) {
              sym.each(function(x) {
                if (!x.symbols && x.group !== FN) {
                  return;
                }
                if (has_CP(x)) {
                  collect(x);
                } else {
                  if (!patterns[x.value]) {
                    var u = core.Utils.getU(symbol);
                    patterns[x.value] = u;
                    symbol = symbol.sub(x.value, u);
                  }
                }
              }, true);
            };
            collect(symbol);
            return [symbol, patterns];
          },
          simplify: function(symbol) {
            var sym_array = __.Simplify.strip(symbol);
            symbol = sym_array.pop();
            symbol = __.Simplify.fracSimp(symbol);
            if (symbol.isConstant() || symbol.group === core.groups.S) {
              sym_array.push(symbol);
              var ret = __.Simplify.unstrip(sym_array, symbol);
              return ret;
            }
            var simplified = symbol.clone();
            simplified = __.Simplify.trigSimp(simplified);
            simplified = __.Simplify.ratSimp(simplified);
            simplified = __.Factor.factor(simplified);
            if (simplified.group === core.groups.CP && simplified.isLinear()) {
              var m = simplified.multiplier.clone();
              simplified.toUnitMultiplier();
              var r = new Symbol(0);
              simplified.each(function(x) {
                var s = __.Simplify.simplify(x);
                r = _.add(r, s);
              });
              simplified = r;
              r.multiplier = r.multiplier.multiply(m);
            }
            var retval = __.Simplify.unstrip(sym_array, simplified);
            return retval;
          }
        },
        Classes: {
          Polynomial,
          Factors,
          MVTerm
        }
      };
      core.Expression.prototype.simplify = function() {
        return __.Simplify.simplify(this.symbol);
      };
      nerdamer.useAlgebraDiv = function() {
        var divide = __.divideFn = _.divide;
        var calls = 0;
        _.divide = function(a, b) {
          calls++;
          var ans;
          if (calls === 1)
            ans = core.Algebra.divide(a, b);
          else
            ans = divide(a, b);
          calls = 0;
          return ans;
        };
      };
      nerdamer.useParserDiv = function() {
        if (__.divideFn)
          _.divide = __.divideFn;
        delete __.divideFn;
      };
      nerdamer.register([
        {
          name: "factor",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Factor.factor;
          }
        },
        {
          name: "simplify",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Simplify.simplify;
          }
        },
        {
          name: "gcd",
          visible: true,
          numargs: [1],
          build: function() {
            return __.gcd;
          }
        },
        {
          name: "lcm",
          visible: true,
          numargs: [1],
          build: function() {
            return __.lcm;
          }
        },
        {
          name: "roots",
          visible: true,
          numargs: -1,
          build: function() {
            return __.roots;
          }
        },
        {
          name: "divide",
          visible: true,
          numargs: 2,
          build: function() {
            return __.divide;
          }
        },
        {
          name: "div",
          visible: true,
          numargs: 2,
          build: function() {
            return __.div;
          }
        },
        {
          name: "partfrac",
          visible: true,
          numargs: [1, 2],
          build: function() {
            return __.PartFrac.partfrac;
          }
        },
        {
          name: "deg",
          visible: true,
          numargs: [1, 2],
          build: function() {
            return __.degree;
          }
        },
        {
          name: "coeffs",
          visible: true,
          numargs: [1, 2],
          build: function() {
            var f = function() {
              var coeffs = __.coeffs.apply(__, arguments);
              return new core.Vector(coeffs);
            };
            return f;
          }
        },
        {
          name: "line",
          visible: true,
          numargs: [2, 3],
          build: function() {
            return __.line;
          }
        },
        {
          name: "sqcomp",
          visible: true,
          numargs: [1, 2],
          build: function() {
            var f = function(x, v) {
              try {
                v = v || variables(x)[0];
                var sq = __.sqComplete(x.clone(), v);
                return sq.f;
              } catch (e) {
                return x;
              }
            };
            return f;
          }
        }
      ]);
      nerdamer.updateAPI();
    })();
  }
});

export {
  require_Algebra,
  require_Calculus
};
//# sourceMappingURL=chunk-C7WR7DA7.js.map
