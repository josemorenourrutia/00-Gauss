{
  "version": 3,
  "sources": ["../../nerdamer/Solve.js"],
  "sourcesContent": ["/*\r\n * Author : Martin Donk\r\n * Website : http://www.nerdamer.com\r\n * Email : martin.r.donk@gmail.com\r\n * Source : https://github.com/jiggzson/nerdamer\r\n */\r\n/* global module */\r\n\r\nif((typeof module) !== 'undefined') {\r\n    var nerdamer = require('./nerdamer.core.js');\r\n    require('./Calculus.js');\r\n    require('./Algebra.js');\r\n}\r\n\r\n(function () {\r\n    //handle imports\r\n    var core = nerdamer.getCore(),\r\n            _ = core.PARSER,\r\n            _A = core.Algebra,\r\n            _C = core.Calculus,\r\n            explode = _C.integration.decompose_arg,\r\n            evaluate = core.Utils.evaluate,\r\n            remove = core.Utils.remove,\r\n            format = core.Utils.format,\r\n            build = core.Utils.build,\r\n            knownVariable = core.Utils.knownVariable,\r\n            Symbol = core.Symbol,\r\n            isSymbol = core.Utils.isSymbol,\r\n            variables = core.Utils.variables,\r\n            S = core.groups.S,\r\n            PL = core.groups.PL,\r\n            CB = core.groups.CB,\r\n            CP = core.groups.CP,\r\n            FN = core.groups.FN,\r\n            Settings = core.Settings,\r\n            range = core.Utils.range,\r\n            isArray = core.Utils.isArray;\r\n\r\n\r\n    // The search radius for the roots\r\n    core.Settings.SOLVE_RADIUS = 1000;\r\n    // The maximum number to fish for on each side of the zero\r\n    core.Settings.ROOTS_PER_SIDE = 10;\r\n    // Covert the number to multiples of pi if possible\r\n    core.Settings.make_pi_conversions = false;\r\n    // The step size\r\n    core.Settings.STEP_SIZE = 0.1;\r\n    // The epsilon size\r\n    core.Settings.EPSILON = 1e-13;\r\n    //the maximum iterations for Newton's method\r\n    core.Settings.MAX_NEWTON_ITERATIONS = 200;\r\n    //the maximum number of time non-linear solve tries another jump point\r\n    core.Settings.MAX_NON_LINEAR_TRIES = 12;\r\n    //the amount of iterations the function will start to jump at\r\n    core.Settings.NON_LINEAR_JUMP_AT = 50;\r\n    //the size of the jump\r\n    core.Settings.NON_LINEAR_JUMP_SIZE = 100;\r\n    //the original starting point for nonlinear solving\r\n    core.Settings.NON_LINEAR_START = 0.01;\r\n    //When points are generated as starting points for Newton's method, they are sliced into small\r\n    //slices to make sure that we have convergence on the right point. This defines the \r\n    //size of the slice\r\n    core.Settings.NEWTON_SLICES = 200;\r\n    //The epsilon used in Newton's iteration\r\n    core.Settings.NEWTON_EPSILON = Number.EPSILON * 2;\r\n    //The distance in which two solutions are deemed the same\r\n    core.Settings.SOLUTION_PROXIMITY = 1e-14;\r\n    //Indicate wheter to filter the solutions are not\r\n    core.Settings.FILTER_SOLUTIONS = true;\r\n    //the maximum number of recursive calls\r\n    core.Settings.MAX_SOLVE_DEPTH = 10;\r\n    // The tolerance that's considered close enough to zero\r\n    core.Settings.ZERO_EPSILON = 1e-9;\r\n    // The maximum iteration for the bisection method incase of some JS strangeness\r\n    core.Settings.MAX_BISECTION_ITER = 2000;\r\n    // The tolerance for the bisection method\r\n    core.Settings.BI_SECTION_EPSILON = 1e-12;\r\n\r\n\r\n    core.Symbol.prototype.hasTrig = function () {\r\n        return this.containsFunction(['cos', 'sin', 'tan', 'cot', 'csc', 'sec']);\r\n    };\r\n\r\n    core.Symbol.prototype.hasNegativeTerms = function () {\r\n        if(this.isComposite()) {\r\n            for(var x in this.symbols) {\r\n                var sym = this.symbols[x];\r\n                if(sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))\r\n                    return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /* nerdamer version 0.7.x and up allows us to make better use of operator overloading\r\n     * As such we can have this data type be supported completely outside of the core.\r\n     * This is an equation that has a left hand side and a right hand side\r\n     */\r\n    function Equation(lhs, rhs) {\r\n        if(rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) && rhs.isConstant(true) || rhs.equals(core.Settings.IMAGINARY) && lhs.isConstant(true))\r\n            throw new core.exceptions.NerdamerValueError(lhs.toString() + ' does not equal ' + rhs.toString());\r\n        this.LHS = lhs; //left hand side\r\n        this.RHS = rhs; //right and side\r\n    }\r\n    ;\r\n\r\n    //UTILS ##!!\r\n\r\n    Equation.prototype = {\r\n        toString: function () {\r\n            return this.LHS.toString() + '=' + this.RHS.toString();\r\n        },\r\n        text: function (option) {\r\n            return this.LHS.text(option) + '=' + this.RHS.text(option);\r\n        },\r\n        toLHS: function (expand) {\r\n            expand = typeof expand === 'undefined' ? true : false;\r\n            var eqn;\r\n            if(!expand) {\r\n                eqn = this.clone();\r\n            }\r\n            else {\r\n                eqn = this.removeDenom();\r\n            }\r\n            var a = eqn.LHS;\r\n            var b = eqn.RHS;\r\n            \r\n            if(a.isConstant(true) && !b.isConstant(true)) {\r\n                // Swap them to avoid confusing parser and cause an infinite loop\r\n                [a, b] = [b, a];\r\n            }\r\n            var _t = _.subtract(a, b);\r\n            var retval = expand ? _.expand(_t) : _t;\r\n            \r\n            // Quick workaround for issue #636\r\n            // This basically borrows the removeDenom method from the Equation class. \r\n            // TODO: Make this function a stand-alone function\r\n            retval = new Equation(retval, new Symbol(0)).removeDenom().LHS;\r\n            \r\n            return retval;\r\n        },\r\n        removeDenom: function () {\r\n            var a = this.LHS.clone();\r\n            var b = this.RHS.clone();\r\n            //remove the denominator on both sides\r\n            var den = _.multiply(a.getDenom(), b.getDenom());\r\n            a = _.expand(_.multiply(a, den.clone()));\r\n            b = _.expand(_.multiply(b, den));\r\n            //swap the groups\r\n            if(b.group === CP && b.group !== CP) {\r\n                var t = a;\r\n                a = b;\r\n                b = t; //swap\r\n            }\r\n\r\n            //scan to eliminate denominators\r\n            if(a.group === CB) {\r\n                var t = new Symbol(a.multiplier),\r\n                        newRHS = b.clone();\r\n                a.each(function (y) {\r\n                    if(y.power.lessThan(0))\r\n                        newRHS = _.divide(newRHS, y);\r\n                    else\r\n                        t = _.multiply(t, y);\r\n                });\r\n                a = t;\r\n                b = newRHS;\r\n\r\n            }\r\n            else if(a.group === CP) {\r\n                //the logic: loop through each and if it has a denominator then multiply it out on both ends\r\n                //and then start over\r\n                for(var x in a.symbols) {\r\n                    var sym = a.symbols[x];\r\n                    if(sym.group === CB) {\r\n                        for(var y in sym.symbols) {\r\n                            var sym2 = sym.symbols[y];\r\n                            if(sym2.power.lessThan(0)) {\r\n                                return new Equation(\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), a)),\r\n                                        _.expand(_.multiply(sym2.clone().toLinear(), b))\r\n                                        );\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return new Equation(a, b);\r\n        },\r\n        clone: function () {\r\n            return new Equation(this.LHS.clone(), this.RHS.clone());\r\n        },\r\n        sub: function (x, y) {\r\n            var clone = this.clone();\r\n            clone.LHS = clone.LHS.sub(x.clone(), y.clone());\r\n            clone.RHS = clone.RHS.sub(x.clone(), y.clone());\r\n            return clone;\r\n        },\r\n        isZero: function () {\r\n            return core.Utils.evaluate(this.toLHS()).equals(0);\r\n        },\r\n        latex: function (option) {\r\n            return [this.LHS.latex(option), this.RHS.latex(option)].join('=');\r\n        }\r\n    };\r\n    //overwrite the equals function\r\n    _.equals = function (a, b) {\r\n        return new Equation(a, b);\r\n    };\r\n\r\n    // Extend simplify\r\n    (function () {\r\n        var simplify = _.functions.simplify[0];\r\n        _.functions.simplify[0] = function (symbol) {\r\n            if(symbol instanceof Equation) {\r\n                symbol.LHS = simplify(symbol.LHS);\r\n                symbol.RHS = simplify(symbol.RHS);\r\n                return symbol;\r\n            }\r\n            // Just call the original simplify\r\n            return simplify(symbol);\r\n        };\r\n    })();\r\n\r\n    /**\r\n     * Sets two expressions equal\r\n     * @param {Symbol} symbol\r\n     * @returns {Expression}\r\n     */\r\n    core.Expression.prototype.equals = function (symbol) {\r\n        if(symbol instanceof core.Expression)\r\n            symbol = symbol.symbol; //grab the symbol if it's an expression\r\n        var eq = new Equation(this.symbol, symbol);\r\n        return eq;\r\n    };\r\n\r\n    core.Expression.prototype.solveFor = function (x) {\r\n        var symbol;\r\n        if(this.symbol instanceof Equation) {\r\n            //exit right away if we already have the answer\r\n            //check the LHS\r\n            if(this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))\r\n                return new core.Expression(this.symbol.LHS);\r\n\r\n            //check the RHS\r\n            if(this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))\r\n                return new core.Expression(this.symbol.RHS);\r\n\r\n            //otherwise just bring it to LHS\r\n            symbol = this.symbol.toLHS();\r\n        }\r\n        else {\r\n            symbol = this.symbol;\r\n        }\r\n\r\n        return solve(symbol, x).map(function (x) {\r\n            return new core.Expression(x);\r\n        });\r\n    };\r\n\r\n    core.Expression.prototype.expand = function () {\r\n        if(this.symbol instanceof Equation) {\r\n            var clone = this.symbol.clone();\r\n            clone.RHS = _.expand(clone.RHS);\r\n            clone.LHS = _.expand(clone.LHS);\r\n            return new core.Expression(clone);\r\n        }\r\n        return new core.Expression(_.expand(this.symbol));\r\n    };\r\n\r\n    core.Expression.prototype.variables = function () {\r\n        if(this.symbol instanceof Equation)\r\n            return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));\r\n        return variables(this.symbol);\r\n    };\r\n\r\n\r\n\r\n    var setEq = function (a, b) {\r\n        return _.equals(a, b);\r\n    };\r\n\r\n    //link the Equation class back to the core\r\n    core.Equation = Equation;\r\n\r\n    //Loops through an array and attempts to fails a test. Stops if manages to fail.\r\n    var checkAll = core.Utils.checkAll = function (args, test) {\r\n        for(var i = 0; i < args.length; i++)\r\n            if(test(args[i]))\r\n                return false;\r\n        return true;\r\n    };\r\n\r\n    //version solve\r\n    var __ = core.Solve = {\r\n        version: '2.0.3',\r\n        solutions: [],\r\n        solve: function (eq, variable) {\r\n            var solution = solve(eq, String(variable));\r\n            return new core.Vector(solution);\r\n            //return new core.Vector(solve(eq.toString(), variable ? variable.toString() : variable));\r\n        },\r\n        /**\r\n         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation\r\n         * @param {Equation|String} eqn\r\n         * @returns {Symbol}\r\n         */\r\n        toLHS: function (eqn, expand) {\r\n            if(isSymbol(eqn))\r\n                return eqn;\r\n            //If it's an equation then call its toLHS function instead\r\n            if(!(eqn instanceof Equation)) {\r\n                var es = eqn.split('=');\r\n                //convert falsey values to zero\r\n                es[1] = es[1] || '0';\r\n                eqn = new Equation(_.parse(es[0]), _.parse(es[1]));\r\n            }\r\n            return eqn.toLHS(expand);\r\n        },\r\n//        getSystemVariables: function(eqns) {\r\n//            vars = variables(eqns[0], null, null, true);\r\n//\r\n//            //get all variables\r\n//            for (var i = 1, l=eqns.length; i < l; i++)\r\n//                vars = vars.concat(variables(eqns[i]));\r\n//            //remove duplicates\r\n//            vars = core.Utils.arrayUnique(vars).sort();\r\n//            \r\n//            //done\r\n//            return vars;\r\n//        },\r\n        /**\r\n         * Solve a set of circle equations. \r\n         * @param {Symbol[]} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveCircle: function (eqns, vars) {\r\n            // Convert the variables to symbols\r\n            var svars = vars.map(function (x) {\r\n                return _.parse(x)\r\n            });\r\n\r\n            var deg = [];\r\n\r\n            var solutions = [];\r\n\r\n            // Get the degree for the equations\r\n            for(var i = 0; i < eqns.length; i++) {\r\n                var d = [];\r\n                for(var j = 0; j < svars.length; j++) {\r\n                    d.push(Number(core.Algebra.degree(eqns[i], svars[j])));\r\n                }\r\n                // Store the total degree\r\n                d.push(core.Utils.arraySum(d, true));\r\n                deg.push(d);\r\n            }\r\n\r\n            var a = eqns[0];\r\n            var b = eqns[1];\r\n\r\n            if(deg[0][2] > deg[1][2]) {\r\n                [b, a] = [a, b];\r\n                [deg[1], deg[0]] = [deg[0], deg[1]];\r\n            }\r\n\r\n            // Only solve it's truly a circle\r\n            if(deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {\r\n                // For clarity we'll refer to the variables as x and y\r\n                var x = vars[0];\r\n                var y = vars[1];\r\n\r\n                // We can now get the two points for y\r\n                var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function (x) {\r\n                    return x.toString();\r\n                });\r\n\r\n                // Since we now know y we can get the two x points from the first equation\r\n                var x_points = [\r\n                    solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()\r\n                ];\r\n\r\n                if(y_points[1]) {\r\n                    x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());\r\n                }\r\n\r\n                if(Settings.SOLUTIONS_AS_OBJECT) {\r\n                    var solutions = {};\r\n                    solutions[x] = x_points;\r\n                    solutions[y] = y_points;\r\n                }\r\n                else {\r\n                    y_points.unshift(y);\r\n                    x_points.unshift(x);\r\n                    solutions = [x_points, y_points];\r\n                }\r\n            }\r\n\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solve a system of nonlinear equations\r\n         * @param {Symbol[]} eqns The array of equations\r\n         * @param {number} tries The maximum number of tries\r\n         * @param {number} start The starting point where to start looking for solutions\r\n         * @returns {Array}\r\n         */\r\n        solveNonLinearSystem: function (eqns, tries, start) {\r\n            if(tries < 0) {\r\n                return [];//can't find a solution\r\n            }\r\n\r\n            start = typeof start === 'undefined' ? core.Settings.NON_LINEAR_START : start;\r\n\r\n            //the maximum number of times to jump\r\n            var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;\r\n\r\n            //halfway through the tries\r\n            var halfway = Math.floor(max_tries / 2);\r\n\r\n            //initialize the number of tries to 10 if not specified\r\n            tries = typeof tries === 'undefined' ? max_tries : tries;\r\n\r\n            //a point at which we check to see if we're converging. By inspection it seems that we can\r\n            //use around 20 iterations to see if we're converging. If not then we retry a jump of x\r\n            var jump_at = core.Settings.NON_LINEAR_JUMP_AT;\r\n\r\n            //we jump by this many points at each pivot point\r\n            var jump = core.Settings.NON_LINEAR_JUMP_SIZE;\r\n\r\n            //used to check if we actually found a solution or if we gave up. Assume we will find a solution.\r\n            var found = true;\r\n\r\n            var create_subs = function (vars, matrix) {\r\n                return vars.map(function (x, i) {\r\n                    return Number(matrix.get(i, 0));\r\n                });\r\n            };\r\n\r\n            var vars = core.Utils.arrayGetVariables(eqns);\r\n            var jacobian = core.Matrix.jacobian(eqns, vars, function (x) {\r\n                return build(x, vars);\r\n            }, true);\r\n\r\n            var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;\r\n            var o, y, iters, xn1, norm, lnorm, xn, d;\r\n\r\n            var f_eqns = eqns.map(function (eq) {\r\n                return build(eq, vars);\r\n            });\r\n\r\n            var J = jacobian.map(function (e) {\r\n                return build(e, vars);\r\n            }, true);\r\n            //initial values\r\n            xn1 = core.Matrix.cMatrix(0, vars);\r\n\r\n            //initialize the c matrix with something close to 0. \r\n            var c = core.Matrix.cMatrix(start, vars);\r\n\r\n            iters = 0;\r\n\r\n            //start of algorithm\r\n            do {\r\n                //if we've reached the max iterations then exit\r\n                if(iters > max_iter) {\r\n                    break;\r\n                    found = false;\r\n                }\r\n\r\n                //set the substitution object\r\n                o = create_subs(vars, c);\r\n\r\n                //set xn\r\n                xn = c.clone();\r\n\r\n                //make all the substitutions for each of the equations\r\n                f_eqns.forEach(function (f, i) {\r\n                    c.set(i, 0, f.apply(null, o));\r\n                });\r\n\r\n                var m = new core.Matrix();\r\n                J.each(function (fn, i, j) {\r\n                    var ans = fn.apply(null, o);\r\n                    m.set(i, j, ans);\r\n                });\r\n\r\n                m = m.invert();\r\n\r\n                //preform the elimination\r\n                y = _.multiply(m, c).negate();\r\n\r\n                //the callback is to avoid overflow in the coeffient denonimator\r\n                //it converts it to a decimal and then back to a fraction. Some precision\r\n                //is lost be it's better than overflow. \r\n                d = y.subtract(xn1, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                xn1 = xn.add(y, function (x) {\r\n                    return _.parse(Number(x));\r\n                });\r\n\r\n                //move c is now xn1\r\n                c = xn1;\r\n\r\n                //get the norm\r\n\r\n                //the expectation is that we're converging to some answer as this point regardless of where we start\r\n                //this may have to be adjusted at some point because of erroneous assumptions\r\n                if(iters >= jump_at) {\r\n                    //check the norm. If the norm is greater than one then it's time to try another point\r\n                    if(norm > 1) {\r\n                        //reset the start point at halway\r\n                        if(tries === halfway)\r\n                            start = 0;\r\n                        var sign = tries > halfway ? 1 : -1; //which side are we incrementing\r\n                        //we increment +n at one side and -n at the other. \r\n                        n = (tries % Math.floor(halfway)) + 1;\r\n                        //adjust the start point\r\n                        start += (sign * n * jump);\r\n                        //call restart\r\n                        return __.solveNonLinearSystem(eqns, --tries, start);\r\n                    }\r\n                }\r\n                lnorm = norm;\r\n                iters++;\r\n                norm = d.max();\r\n\r\n                //exit early. Revisit if we get bugs\r\n                if(Number(norm) === Number(lnorm)) {\r\n                    break;\r\n                }\r\n            }\r\n            while(Number(norm) >= Number.EPSILON)\r\n\r\n            //return a blank set if nothing was found;\r\n            if(!found)\r\n                return [];\r\n\r\n            //return c since that's the answer\r\n            return __.systemSolutions(c, vars, true, function (x) {\r\n                return core.Utils.round(Number(x), 14);\r\n            });\r\n        },\r\n        systemSolutions: function (result, vars, expand_result, callback) {\r\n            var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];\r\n\r\n            result.each(function (e, idx) {\r\n                var solution = (expand_result ? _.expand(e) : e).valueOf();\r\n                if(callback)\r\n                    solution = callback.call(e, solution);\r\n                var variable = vars[idx];\r\n                if(core.Settings.SOLUTIONS_AS_OBJECT) {\r\n                    solutions[variable] = solution;\r\n                }\r\n                else\r\n                    solutions.push([variable, solution]); /*NO*/\r\n            });\r\n            //done\r\n            return solutions;\r\n        },\r\n        /**\r\n         * Solves a system of equations by substitution. This is useful when\r\n         * no distinct solution exists. e.g. a line, plane, etc.\r\n         * @param {Array} eqns\r\n         * @returns {Array}\r\n         */\r\n        solveSystemBySubstitution: function (eqns) {\r\n            // Assume at least 2 equations. The function variables will just return an empty array if undefined is provided\r\n            var vars_a = variables(eqns[0]);\r\n            var vars_b = variables(eqns[1]);\r\n            // Check if it's a circle equation\r\n            if(eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {\r\n                return __.solveCircle(eqns, vars_a);\r\n            }\r\n\r\n            return []; // return an empty set\r\n        },\r\n\r\n        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf\r\n        /**\r\n         * Solves a systems of equations\r\n         * @param {Array} eqns An array of equations\r\n         * @param {Array} var_array An array of variables\r\n         * @returns {Array|object}\r\n         */\r\n        solveSystem: function (eqns, var_array) {\r\n            //check if a var_array was specified\r\n            //nerdamer.clearVars();// this deleted ALL variables: not what we want\r\n            //parse all the equations to LHS. Remember that they come in as strings\r\n            for(var i = 0; i < eqns.length; i++)\r\n                eqns[i] = __.toLHS(eqns[i]);\r\n\r\n            var l = eqns.length,\r\n                    m = new core.Matrix(),\r\n                    c = new core.Matrix(),\r\n                    expand_result = false,\r\n                    vars;\r\n\r\n            if(typeof var_array === 'undefined') {\r\n                //check to make sure that all the equations are linear\r\n                if(!_A.allLinear(eqns)) {\r\n                    try {\r\n                        return __.solveNonLinearSystem(eqns);\r\n                    }\r\n                    catch(e) {\r\n                        if(e instanceof core.exceptions.DivisionByZero) {\r\n                            return __.solveSystemBySubstitution(eqns);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                vars = core.Utils.arrayGetVariables(eqns);\r\n                \r\n                // If the system only has one variable then we solve for the first one and \r\n                // then test the remaining equations with that solution. If any of the remaining\r\n                // equation fails then the system has no solution\r\n                if(vars.length === 1) {\r\n                    var n = 0,\r\n                        sol, e;\r\n                    do {\r\n                        var e = eqns[n].clone();\r\n                        \r\n                        if(n > 0) {\r\n                            e = e.sub(vars[0], sol[0]);\r\n                        }\r\n\r\n                        sol = solve(e, vars[0]);\r\n                        // Skip the first one\r\n                        if(n === 0) \r\n                            continue;\r\n                    }\r\n                    while(++n < eqns.length)\r\n                        \r\n                    // Format the output\r\n                    var solutions;\r\n                    if(Settings.SOLUTIONS_AS_OBJECT) {\r\n                        solutions = {};\r\n                        solutions[vars[0]] = sol;\r\n                    }\r\n                    else if(sol.length === 0) {\r\n                        solutions = sol; // No solutions\r\n                    }\r\n                    else {\r\n                        solutions = [vars[0], sol];\r\n                    }\r\n                        \r\n                    return solutions;\r\n                }\r\n                \r\n                // Deal with redundant equations as expressed in #562\r\n                // The fix is to remove all but the number of equations equal to the number\r\n                // of variables. We then solve those and then evaluate the remaining equations\r\n                // with those solutions. If the all equal true then those are just redundant\r\n                // equations and we can return the solution set.\r\n                if(vars.length < eqns.length) {\r\n                    var reduced = [];\r\n                    var n = eqns.length;\r\n                    for(var i = 0; i < n - 1; i++) {\r\n                        reduced.push(_.parse(eqns[i]));\r\n                    }\r\n\r\n                    var knowns = {};\r\n                    var solutions = __.solveSystem(reduced, vars);\r\n                    // The solutions may have come back as an array\r\n                    if(Array.isArray(solutions)) {\r\n                        solutions.forEach(function (sol) {\r\n                            knowns[sol[0]] = sol[1];\r\n                        });\r\n                    }\r\n                    else {\r\n                        knowns = solutions;\r\n                    }\r\n\r\n                    // Start by assuming they will all evaluate to zero. If even one fails\r\n                    // then all zero will be false\r\n                    var all_zero = true;\r\n                    // Check if the last solution evalutes to zero given these solutions\r\n                    for(var i = n - 1; i < n; i++) {\r\n                        if(!_.parse(eqns[i], knowns).equals(0)) {\r\n                            all_zero = false;\r\n                        }\r\n                    }\r\n\r\n                    if(all_zero) {\r\n                        return solutions;\r\n                    }\r\n                }\r\n\r\n                // deletes only the variables of the linear equations in the nerdamer namespace\r\n                for(var i = 0; i < vars.length; i++) {\r\n                    nerdamer.setVar(vars[i], \"delete\");\r\n                }\r\n                // TODO: move this to cMatrix or something similar\r\n                // populate the matrix\r\n                for(var i = 0; i < l; i++) {\r\n                    var e = eqns[i]; //store the expression\r\n                    // Iterate over the columns\r\n                    for(var j = 0; j < vars.length; j++) {\r\n                        var v = vars[j];\r\n                        var coeffs = [];\r\n                        e.each(function (x) {\r\n                            if(x.contains(v)) {\r\n                                coeffs = coeffs.concat(x.coeffs());\r\n                            }\r\n                        });\r\n\r\n                        var cf = core.Utils.arraySum(coeffs);\r\n                        m.set(i, j, cf);\r\n                    }\r\n\r\n                    //strip the variables from the symbol so we're left with only the zeroth coefficient\r\n                    //start with the symbol and remove each variable and its coefficient\r\n                    var num = e.clone();\r\n                    vars.map(function (e) {\r\n                        num = num.stripVar(e, true);\r\n                    });\r\n                    c.set(i, 0, num.negate());\r\n                }\r\n            }\r\n            else {\r\n                /**\r\n                 * The idea is that we loop through each equation and then expand it. Afterwards we loop\r\n                 * through each term and see if and check to see if it matches one of the variables.\r\n                 * When a match is found we mark it. No other match should be found for that term. If it\r\n                 * is we stop since it's not linear.\r\n                 */\r\n                vars = var_array;\r\n                expand_result = true;\r\n                for(i = 0; i < l; i++) {\r\n                    //prefill\r\n                    c.set(i, 0, new Symbol(0));\r\n                    var e = _.expand(eqns[i]).collectSymbols(); //expand and store\r\n                    //go trough each of the variables\r\n                    for(var j = 0; j < var_array.length; j++) {\r\n                        m.set(i, j, new Symbol(0));\r\n                        var v = var_array[j];\r\n                        //go through the terms and sort the variables\r\n                        for(var k = 0; k < e.length; k++) {\r\n                            var term = e[k],\r\n                                    check = false;\r\n                            for(var z = 0; z < var_array.length; z++) {\r\n                                //check to see if terms contain multiple variables\r\n                                if(term.contains(var_array[z])) {\r\n                                    if(check)\r\n                                        core.err('Multiple variables found for term ' + term);\r\n                                    check = true;\r\n                                }\r\n                            }\r\n                            //we made sure that every term contains one variable so it's safe to assume that if the\r\n                            //variable is found then the remainder is the coefficient.\r\n                            if(term.contains(v)) {\r\n                                var tparts = explode(remove(e, k), v);\r\n                                m.set(i, j, _.add(m.get(i, j), tparts[0]));\r\n                            }\r\n                        }\r\n                    }\r\n                    //all the remaining terms go to the c matrix\r\n                    for(k = 0; k < e.length; k++) {\r\n                        c.set(i, 0, _.add(c.get(i, 0), e[k]));\r\n                    }\r\n                }\r\n                //consider case (a+b)*I+u\r\n            }\r\n\r\n            //check if the system has a distinct solution\r\n            if(vars.length !== eqns.length || m.determinant().equals(0)) {\r\n                // solve the system by hand\r\n                //return __.solveSystemBySubstitution(eqns, vars, m, c);\r\n                throw new core.exceptions.SolveError('System does not have a distinct solution');\r\n            }\r\n\r\n            // Use M^-1*c to solve system\r\n            m = m.invert();\r\n            var result = m.multiply(c);\r\n            //correct the sign as per issue #410\r\n            if(core.Utils.isArray(var_array))\r\n                result.each(function (x) {\r\n                    return x.negate();\r\n                });\r\n\r\n            return __.systemSolutions(result, vars, expand_result);\r\n        },\r\n        /**\r\n         * The quadratic function but only one side.\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Symbol}\r\n         */\r\n        quad: function (c, b, a) {\r\n            var discriminant = _.subtract(_.pow(b.clone(), Symbol(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol(4)))/*b^2 - 4ac*/;\r\n            // Fix for #608\r\n            discriminant = _.expand(discriminant);\r\n            var det = _.pow(discriminant, Symbol(0.5));\r\n            var den = _.parse(_.multiply(new Symbol(2), a.clone()));\r\n            var retval = [\r\n                _.parse(format('(-({0})+({1}))/({2})', b, det, den)),\r\n                _.parse(format('(-({0})-({1}))/({2})', b, det, den))\r\n            ];\r\n\r\n            return retval;\r\n        },\r\n        /**\r\n         * The cubic equation\r\n         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations\r\n         * @param {Symbol} d_o\r\n         * @param {Symbol} c_o\r\n         * @param {Symbol} b_o\r\n         * @param {Symbol} a_o\r\n         * @returns {Array}\r\n         */\r\n        cubic: function (d_o, c_o, b_o, a_o) {\r\n            //convert everything to text\r\n            var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();\r\n\r\n            var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;\r\n            var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;\r\n            var v = `(${b})/(3*(${a}))`;\r\n            var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`;\r\n\r\n            // Convert a to one\r\n            var w = '1/2+sqrt(3)/2*i'; // Cube root of unity\r\n\r\n            return [\r\n                _.parse(x),\r\n                _.parse(`(${x})(${w})`),\r\n                _.parse(`(${x})(${w})^2`)\r\n            ];\r\n        },\r\n        /**\r\n         * The quartic equation\r\n         * @param {Symbol} e\r\n         * @param {Symbol} d\r\n         * @param {Symbol} c\r\n         * @param {Symbol} b\r\n         * @param {Symbol} a\r\n         * @returns {Array}\r\n         */\r\n        quartic: function (e, d, c, b, a) {\r\n            var scope = {};\r\n            core.Utils.arrayUnique(variables(a).concat(variables(b))\r\n                    .concat(variables(c)).concat(variables(d)).concat(variables(e)))\r\n                    .map(function (x) {\r\n                        scope[x] = 1;\r\n                    });\r\n            a = a.toString();\r\n            b = b.toString();\r\n            c = c.toString();\r\n            d = d.toString();\r\n            e = e.toString();\r\n            var p, q, D, D0, D1, Q, x1, x2, x3, x4;\r\n            /*var D = core.Utils.block('PARSE2NUMBER', function() {\r\n             return _.parse(format(\"256*({0})^3*({4})^3-192*({0})^2*({1})*({3})*({4})^2-128*({0})^2*({2})^2*({4})^2+144*({0})^2*({2})*({3})^2*({4})\"+\r\n             \"-27*({0})^2*({3})^4+144*({0})*({1})^2*({2})*({4})^2-6*({0})*({1})^2*({3})^2*({4})-80*({0})*({1})*({2})^2*({3})*({4})+18*({0})*({1})*({2})*({3})^3\"+\r\n             \"+16*({0})*({2})^4*({4})-4*({0})*({2})^3*({3})^2-27*({1})^4*({4})^2+18*({1})^3*({2})*({3})*({4})-4*({1})^3*({3})^3-4*({1})^2*({2})^3*({4})+({1})^2*({2})^2*({3})^2\", \r\n             a, b, c, d, e), scope);\r\n             });*/\r\n\r\n            p = _.parse(format(\"(8*({0})*({2})-3*({1})^2)/(8*({0})^2)\", a, b, c)).toString(); //a, b, c\r\n            q = _.parse(format(\"(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)\", a, b, c, d)).toString();//a, b, c, d, e\r\n            D0 = _.parse(format(\"12*({0})*({4})-3*({1})*({3})+({2})^2\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            D1 = _.parse(format(\"2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})\", a, b, c, d, e)).toString(); //a, b, c, d, e\r\n            Q = _.parse(format(\"((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)\", D0, D1)).toString(); //D0, D1\r\n            S = _.parse(format(\"(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)\", a, p, Q, D0)).toString(); //a, p, Q, D0\r\n            x1 = _.parse(format(\"-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x2 = _.parse(format(\"-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x3 = _.parse(format(\"-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            x4 = _.parse(format(\"-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))\", a, b, p, q, S)); //a, b, p, q, S\r\n            return [x1, x2, x3, x4];\r\n        },\r\n        /**\r\n         * Breaks the equation up in its factors and tries to solve the smaller parts\r\n         * @param {Symbol} symbol\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        divideAndConquer: function (symbol, solve_for) {\r\n            var sols = [];\r\n            //see if we can solve the factors\r\n            var factors = core.Algebra.Factor.factor(symbol);\r\n            if(factors.group === CB) {\r\n                factors.each(function (x) {\r\n                    x = Symbol.unwrapPARENS(x);\r\n                    sols = sols.concat(solve(x, solve_for));\r\n                });\r\n            }\r\n            return sols;\r\n        },\r\n        /**\r\n         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients\r\n         * @param {Symbol} eq\r\n         * @param {String} solve_for\r\n         * @returns {Array}\r\n         */\r\n        csolve: function (eq, solve_for) {\r\n            return core.Utils.block('IGNORE_E', function () {\r\n                var f, p, pn, n, pf, r, theta, sr, sp, roots;\r\n                roots = [];\r\n                f = core.Utils.decompose_fn(eq, solve_for, true);\r\n                if(f.x.group === S) {\r\n                    p = _.parse(f.x.power);\r\n                    pn = Number(p);\r\n                    n = _.pow(_.divide(f.b.negate(), f.a), p.invert());\r\n                    pf = Symbol.toPolarFormArray(n);\r\n                    r = pf[0];\r\n                    theta = pf[1];\r\n                    sr = r.toString();\r\n                    sp = p.toString();\r\n                    var k, root, str;\r\n                    for(var i = 0; i < pn; i++) {\r\n                        k = i;\r\n                        str = format('({0})*e^(2*{1}*pi*{2}*{3})', sr, k, p, core.Settings.IMAGINARY);\r\n                        root = _.parse(str);\r\n                        roots.push(root);\r\n                    }\r\n                }\r\n                return roots;\r\n            }, true);\r\n        },\r\n        /**\r\n         * Generates starting points for the Newton solver given an expression at zero.\r\n         * It beings by check if zero is a good point and starts expanding by a provided step size. \r\n         * Builds on the fact that if the sign changes over an interval then a zero\r\n         * must exist on that interval\r\n         * @param {Symbol} symbol\r\n         * @param {Number} step\r\n         * @param {Array} points\r\n         * @returns {Array}\r\n         */\r\n        getPoints: function (symbol, step, points) {\r\n            step = step || 0.01;\r\n            points = points || [];\r\n            var f = build(symbol);\r\n            var x0 = 0;\r\n\r\n            var start = Math.round(x0),\r\n                    last = f(start),\r\n                    last_sign = last / Math.abs(last),\r\n                    rside = core.Settings.ROOTS_PER_SIDE, // the max number of roots on right side\r\n                    lside = rside; // the max number of roots on left side\r\n            // check around the starting point\r\n            points.push(Math.floor(start / 2)); //half way from zero might be a good start\r\n            points.push(Math.abs(start)); //|f(0)| could be a good start\r\n            points.push(start);//|f(0)| could be a good start\r\n            //adjust for log. A good starting point to include for log is 0.1\r\n            symbol.each(function (x) {\r\n                if(x.containsFunction(core.Settings.LOG))\r\n                    points.push(0.1);\r\n            });\r\n\r\n            var left = range(-core.Settings.SOLVE_RADIUS, start, step),\r\n                    right = range(start, core.Settings.SOLVE_RADIUS, step);\r\n\r\n            var test_side = function (side, num_roots) {\r\n                var xi, val, sign;\r\n                var hits = [];\r\n                for(var i = 0, l = side.length; i < l; i++) {\r\n                    xi = side[i]; //the point being evaluated\r\n                    val = f(xi);\r\n                    sign = val / Math.abs(val);\r\n                    //Don't add non-numeric values\r\n                    if(isNaN(val) || !isFinite(val) || hits.length > num_roots) {\r\n                        continue;\r\n                    }\r\n\r\n                    //compare the signs. The have to be different if they cross a zero\r\n                    if(sign !== last_sign) {\r\n                        hits.push(xi); //take note of the possible zero location\r\n                    }\r\n                    last_sign = sign;\r\n                }\r\n\r\n                points = points.concat(hits);\r\n            };\r\n\r\n            test_side(left, lside);\r\n            test_side(right, rside);\r\n\r\n            return points;\r\n        },\r\n        /**\r\n         * Implements the bisection method. Returns undefined in no solution is found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @returns {undefined | number}\r\n         */\r\n        bisection: function (point, f) {\r\n            var left = point - 1;\r\n            var right = point + 1;\r\n            // First test if this point is even worth evaluating. It should\r\n            // be crossing the x axis so the signs should be different\r\n            if(Math.sign(f(left)) !== Math.sign(f(right))) {\r\n                var safety = 0;\r\n\r\n                var epsilon, middle;\r\n\r\n                do {\r\n                    epsilon = Math.abs(right - left);\r\n                    // Safety against an infinite loop\r\n                    if(safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {\r\n                        return;\r\n                    }\r\n                    // Calculate the middle point\r\n                    middle = (left + right) / 2;\r\n\r\n                    if(f(left) * f(middle) > 0) {\r\n                        left = middle;\r\n                    }\r\n                    else {\r\n                        right = middle;\r\n                    }\r\n                }\r\n                while(epsilon >= Settings.EPSILON);\r\n\r\n                var solution = (left + right) / 2;\r\n\r\n                // Test the solution to make sure that it's within tolerance\r\n                var x_point = f(solution);\r\n\r\n                if(!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {\r\n                    // Returns too many junk solutions if not rounded at 13th place.\r\n                    return core.Utils.round(solution, 13);\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * Implements Newton's iterations. Returns undefined if no solutions if found\r\n         * @param {number} point\r\n         * @param {function} f\r\n         * @param {function} fp\r\n         * @returns {undefined|number}\r\n         */\r\n        Newton: function (point, f, fp) {\r\n            var maxiter = core.Settings.MAX_NEWTON_ITERATIONS,\r\n                    iter = 0;\r\n            //first try the point itself. If it's zero viola. We're done\r\n            var x0 = point, x;\r\n            do {\r\n                var fx0 = f(x0); //store the result of the function\r\n                //if the value is zero then we're done because 0 - (0/d f(x0)) = 0\r\n                if(x0 === 0 && fx0 === 0) {\r\n                    x = 0;\r\n                    break;\r\n                }\r\n\r\n                iter++;\r\n                if(iter > maxiter)\r\n                    return; //naximum iterations reached\r\n\r\n                x = x0 - fx0 / fp(x0);\r\n                var e = Math.abs(x - x0);\r\n                x0 = x;\r\n            }\r\n            while(e > Settings.NEWTON_EPSILON)\r\n\r\n            //check if the number is indeed zero. 1e-13 seems to give the most accurate results\r\n            if(Math.abs(f(x)) <= Settings.EPSILON)\r\n                return x;\r\n        },\r\n        rewrite: function (rhs, lhs, for_variable) {\r\n            lhs = lhs || new Symbol(0);\r\n            if(rhs.isComposite() && rhs.isLinear()) {\r\n                //try to isolate the square root\r\n                //container for the square roots\r\n                var sqrts = [];\r\n                //all else\r\n                var rem = [];\r\n                rhs.each(function (x) {\r\n                    x = x.clone();\r\n                    if(x.fname === 'sqrt' && x.contains(for_variable)) {\r\n                        sqrts.push(x);\r\n                    }\r\n                    else {\r\n                        rem.push(x);\r\n                    }\r\n                }, true);\r\n\r\n                if(sqrts.length === 1) {\r\n                    //move the remainder to the RHS\r\n                    lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol(2)));\r\n                    //square both sides\r\n                    rhs = _.expand(_.pow(Symbol.unwrapSQRT(sqrts[0]), new Symbol(2)));\r\n                }\r\n            }\r\n            else {\r\n                rhs = Symbol.unwrapSQRT(_.expand(rhs)); //expand the term expression go get rid of quotients when possible\r\n            }\r\n\r\n            var c = 0, //a counter to see if we have all terms with the variable\r\n                    l = rhs.length;\r\n            //try to rewrite the whole thing\r\n            if(rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                rhs.distributeMultiplier();\r\n                var t = new Symbol(0);\r\n                //first bring all the terms containing the variable to the lhs\r\n                rhs.each(function (x) {\r\n                    if(x.contains(for_variable)) {\r\n                        c++;\r\n                        t = _.add(t, x.clone());\r\n                    }\r\n                    else\r\n                        lhs = _.subtract(lhs, x.clone());\r\n                });\r\n                rhs = t;\r\n\r\n                //if not all the terms contain the variable so it's in the form\r\n                //a*x^2+x\r\n                if(c !== l) {\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n                }\r\n                else {\r\n                    return [rhs, lhs];\r\n                }\r\n            }\r\n            else if(rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {\r\n                if(rhs.multiplier.lessThan(0)) {\r\n                    rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));\r\n                    lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));\r\n                }\r\n                if(lhs.equals(0))\r\n                    return new Symbol(0);\r\n                else {\r\n                    var t = new Symbol(1);\r\n                    rhs.each(function (x) {\r\n                        if(x.contains(for_variable))\r\n                            t = _.multiply(t, x.clone());\r\n                        else\r\n                            lhs = _.divide(lhs, x.clone());\r\n                    });\r\n                    rhs = t;\r\n                    return __.rewrite(rhs, lhs, for_variable);\r\n\r\n                }\r\n            }\r\n            else if(!rhs.isLinear() && rhs.contains(for_variable)) {\r\n                var p = _.parse(rhs.power.clone().invert());\r\n                rhs = _.pow(rhs, p.clone());\r\n                lhs = _.pow(_.expand(lhs), p.clone());\r\n                return __.rewrite(rhs, lhs, for_variable);\r\n            }\r\n            else if(rhs.group === FN || rhs.group === S || rhs.group === PL) {\r\n                return [rhs, lhs];\r\n            }\r\n        },\r\n        sqrtSolve: function (symbol, v) {\r\n            var sqrts = new Symbol(0);\r\n            var rem = new Symbol(0);\r\n            if(symbol.isComposite()) {\r\n                symbol.each(function (x) {\r\n                    if(x.fname === 'sqrt' && x.contains(v)) {\r\n                        sqrts = _.add(sqrts, x.clone());\r\n                    }\r\n                    else {\r\n                        rem = _.add(rem, x.clone());\r\n                    }\r\n                });\r\n                //quick and dirty ATM\r\n                if(!sqrts.equals(0)) {\r\n                    var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol(2)), _.pow(sqrts, new Symbol(2)))));\r\n                    //square both sides\r\n                    var solutions = solve(t, v);\r\n                    //test the points. The dumb way of getting the answers\r\n                    solutions = solutions.filter(function (e) {\r\n                        if(e.isImaginary())\r\n                            return e;\r\n                        var subs = {};\r\n                        subs[v] = e;\r\n                        var point = evaluate(symbol, subs);\r\n                        if(point.equals(0))\r\n                            return e;\r\n                    });\r\n                    return solutions;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /*\r\n     * \r\n     * @param {String[]|String|Equation} eqns\r\n     * @param {String} solve_for\r\n     * @param {Array} solutions\r\n     * @param {Number} depth\r\n     * @param {String|Equation} fn\r\n     * @returns {Array}\r\n     */\r\n    var solve = function (eqns, solve_for, solutions, depth, fn) {\r\n        depth = depth || 0;\r\n\r\n        if(depth++ > Settings.MAX_SOLVE_DEPTH) {\r\n            return solutions;\r\n        }\r\n\r\n        //make preparations if it's an Equation\r\n        if(eqns instanceof Equation) {\r\n            //if it's zero then we're done\r\n            if(eqns.isZero()) {\r\n                return [new Symbol(0)];\r\n            }\r\n            //if the lhs = x then we're done\r\n            if(eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {\r\n                return [eqns.RHS];\r\n            }\r\n            //if the rhs = x then we're done\r\n            if(eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {\r\n                return [eqns.LHS];\r\n            }\r\n        }\r\n\r\n        //unwrap the vector since what we want are the elements\r\n        if(eqns instanceof core.Vector)\r\n            eqns = eqns.elements;\r\n        solve_for = solve_for || 'x'; //assumes x by default\r\n        //If it's an array then solve it as a system of equations\r\n        if(isArray(eqns)) {\r\n            return __.solveSystem.apply(undefined, arguments);\r\n        }\r\n\r\n        // Parse out functions. Fix for issue #300\r\n        // eqns = core.Utils.evaluate(eqns);\r\n        solutions = solutions || [];\r\n        //mark existing solutions as not to have duplicates\r\n        var existing = {};\r\n\r\n        // Easy fail. If it's a rational function and the denominator is zero\r\n        // the we're done. Issue #555\r\n        var known = {};\r\n        known[solve_for] = 0;\r\n        if(isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {\r\n            return solutions;\r\n        }\r\n\r\n        // Is usued to add solutions to set. \r\n        // TODO: Set is now implemented and should be utilized\r\n        var add_to_result = function (r, has_trig) {\r\n            var r_is_symbol = isSymbol(r);\r\n            if(r === undefined || typeof r === 'number' && isNaN(r))\r\n                return;\r\n            if(isArray(r)) {\r\n                r.forEach(function (sol) {\r\n                    add_to_result(sol);\r\n                });\r\n            }\r\n            else {\r\n                if(r.valueOf() !== 'null') {\r\n                    // Call the pre-add function if defined. This could be useful for rounding\r\n                    if(typeof core.Settings.PRE_ADD_SOLUTION === 'function') {\r\n                        r = core.Settings.PRE_ADD_SOLUTION(r);\r\n                    }\r\n\r\n                    if(!r_is_symbol) {\r\n                        r = _.parse(r);\r\n                    }\r\n                    // try to convert the number to multiples of pi\r\n                    if(core.Settings.make_pi_conversions && has_trig) {\r\n                        var temp = _.divide(r.clone(), new Symbol(Math.PI)),\r\n                                m = temp.multiplier,\r\n                                a = Math.abs(m.num),\r\n                                b = Math.abs(m.den);\r\n                        if(a < 10 && b < 10)\r\n                            r = _.multiply(temp, new Symbol('pi'));\r\n                    }\r\n\r\n                    // And check if we get a number otherwise we might be throwing out symbolic solutions.\r\n                    var r_str = r.toString();\r\n\r\n                    if(!existing[r_str]) {\r\n                        solutions.push(r);\r\n                    }\r\n                    // Mark the answer as seen\r\n                    existing[r_str] = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        // Maybe we get lucky. Try the point at the function. If it works we have a point\r\n        // If not it failed\r\n        if(eqns.group === S && eqns.contains(solve_for)) {\r\n            try {\r\n                var o = {};\r\n                o[solve_for] = 0;\r\n                evaluate(fn, o, 'numer');\r\n                add_to_result(new Symbol(0));\r\n            }\r\n            catch(e) {\r\n                // Do nothing;\r\n            }\r\n\r\n            return solutions;\r\n        }\r\n        if(eqns.group === CB) {\r\n            // It suffices to solve for the numerator\r\n            var num = eqns.getNum();\r\n\r\n            if(num.group === CB) {\r\n                var sf = String(solve_for); //everything else belongs to the coeff\r\n                //get the denominator and make sure it doesn't have x since we don't know how to solve for those\r\n                num.each(function (x) {\r\n                    if(x.contains(sf))\r\n                        solve(x, solve_for, solutions, depth, eqns);\r\n                });\r\n\r\n                return solutions;\r\n            }\r\n\r\n            return solve(num, solve_for, solutions, depth, fn);\r\n        }\r\n\r\n        if(eqns.group === FN && eqns.fname === 'sqrt') {\r\n            eqns = _.pow(Symbol.unwrapSQRT(eqns), new Symbol(2));\r\n        }\r\n        //pass in false to not expand equations such as (x+y)^5.\r\n        //It suffices to solve for the numerator since there's no value in the denominator which yields a zero for the function\r\n        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(),\r\n                vars = core.Utils.variables(eq), //get a list of all the variables\r\n                numvars = vars.length;//how many variables are we dealing with\r\n\r\n        //it sufficient to solve (x+y) if eq is (x+y)^n since 0^n\r\n        if(core.Utils.isInt(eq.power) && eq.power > 0) {\r\n            eq = _.parse(eq).toLinear();\r\n        }\r\n\r\n        //if we're dealing with a single variable then we first check if it's a \r\n        //polynomial (including rationals).If it is then we use the Jenkins-Traubb algorithm.     \r\n        //Don't waste time\r\n        if(eq.group === S || eq.group === CB && eq.contains(solve_for)) {\r\n            return [new Symbol(0)];\r\n        }\r\n        //force to polynomial. We go through each and then we look at what it would \r\n        //take for its power to be an integer\r\n        //if the power is a fractional we divide by the fractional power\r\n        var fractionals = {},\r\n                cfact;\r\n\r\n        var correct_denom = function (symbol) {\r\n            symbol = _.expand(symbol, {\r\n                expand_denominator: true,\r\n                expand_functions: true\r\n            });\r\n            var original = symbol.clone(); //preserve the original\r\n\r\n            if(symbol.symbols) {\r\n                for(var x in symbol.symbols) {\r\n                    var sym = symbol.symbols[x];\r\n\r\n                    //get the denominator of the sub-symbol\r\n                    var den = sym.getDenom();\r\n\r\n                    if(!den.isConstant(true) && symbol.isComposite()) {\r\n                        var t = new Symbol(0);\r\n                        symbol.each(function (e) {\r\n                            t = _.add(t, _.multiply(e, den.clone()));\r\n                        });\r\n\r\n                        return correct_denom(_.multiply(_.parse(symbol.multiplier), t));\r\n                    }\r\n\r\n                    var parts = explode(sym, solve_for);\r\n                    var is_sqrt = parts[1].fname === core.Settings.SQRT;\r\n                    var v = Symbol.unwrapSQRT(parts[1]);\r\n                    var p = v.power.clone();\r\n                    //circular logic with sqrt. Since sqrt(x) becomes x^(1/2) which then becomes sqrt(x), this continues forever\r\n                    //this needs to be terminated if p = 1/2\r\n                    if(!isSymbol(p) && !p.equals(1 / 2)) {\r\n                        if(p.den.gt(1)) {\r\n                            if(is_sqrt) {\r\n                                symbol = _.subtract(symbol, sym.clone());\r\n                                symbol = _.add(symbol, _.multiply(parts[0].clone(), v));\r\n                                return correct_denom(symbol);\r\n                            }\r\n                            var c = fractionals[p.den];\r\n                            fractionals[p.den] = c ? c++ : 1;\r\n                        }\r\n                        else if(p.sign() === -1) {\r\n                            var factor = _.parse(solve_for + '^' + Math.abs(p)); //this\r\n                            //unwrap the symbol's denoniator\r\n                            symbol.each(function (y, index) {\r\n                                if(y.contains(solve_for)) {\r\n                                    symbol.symbols[index] = _.multiply(y, factor.clone());\r\n                                }\r\n                            });\r\n                            fractionals = {};\r\n                            return correct_denom(_.parse(symbol));\r\n                        }\r\n                        else if(sym.group === PL) {\r\n                            var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));\r\n                            if(min_p < 0) {\r\n                                var factor = _.parse(solve_for + '^' + Math.abs(min_p));\r\n                                var corrected = new Symbol(0);\r\n                                original.each(function (x) {\r\n                                    corrected = _.add(corrected, _.multiply(x.clone(), factor.clone()));\r\n                                }, true);\r\n                                return corrected;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return symbol;\r\n        };\r\n\r\n\r\n        //separate the equation\r\n        var separate = function (eq) {\r\n            var lhs = new Symbol(0),\r\n                    rhs = new Symbol(0);\r\n            eq.each(function (x) {\r\n                if(x.contains(solve_for, true))\r\n                    lhs = _.add(lhs, x.clone());\r\n                else\r\n                    rhs = _.subtract(rhs, x.clone());\r\n            });\r\n            return [lhs, rhs];\r\n        };\r\n\r\n        __.inverseFunctionSolve = function (name, lhs, rhs) {\r\n            //ax+b comes back as [a, x, ax, b];\r\n            var parts = explode(lhs.args[0], solve_for);\r\n            //check if x is by itself\r\n            var x = parts[1];\r\n            if(x.group === S) {\r\n                return _.divide(_.symfunction(name, [_.divide(rhs, _.parse(lhs.multiplier))]), parts[0]);\r\n            }\r\n\r\n        };\r\n\r\n        //first remove any denominators\r\n        eq = correct_denom(eq);\r\n\r\n        if(eq.equals(0))\r\n            return [eq];\r\n        //correct fractionals. I can only handle one type right now\r\n        var fkeys = core.Utils.keys(fractionals);\r\n        if(fkeys.length === 1) {\r\n            //make a note of the factor\r\n            cfact = fkeys[0];\r\n            eq.each(function (x, index) {\r\n                if(x.contains(solve_for)) {\r\n                    var parts = explode(x, solve_for);\r\n                    var v = parts[1];\r\n                    var p = v.power;\r\n                    if(p.den.gt(1)) {\r\n                        v.power = p.multiply(new core.Frac(cfact));\r\n                        eq.symbols[index] = _.multiply(v, parts[0]);\r\n                    }\r\n                }\r\n            });\r\n            eq = _.parse(eq);\r\n        }\r\n\r\n        //try for nested sqrts as per issue #486\r\n        add_to_result(__.sqrtSolve(eq, solve_for));\r\n\r\n        //polynomial single variable\r\n        if(numvars === 1) {\r\n            if(eq.isPoly(true)) {\r\n                //try to factor and solve\r\n                var factors = new core.Algebra.Classes.Factors();\r\n\r\n                core.Algebra.Factor.factor(eq, factors);\r\n                //if the equation has more than one symbolic factor then solve those individually\r\n                if(factors.getNumberSymbolics() > 1) {\r\n                    for(var x in factors.factors) {\r\n                        add_to_result(solve(factors.factors[x], solve_for));\r\n                    }\r\n                }\r\n                else {\r\n                    var coeffs = core.Utils.getCoeffs(eq, solve_for),\r\n                            deg = coeffs.length - 1,\r\n                            was_calculated = false;\r\n                    if(vars[0] === solve_for) {\r\n                        //check to see if all the coefficients are constant\r\n                        if(checkAll(coeffs, function (x) {\r\n                            return x.group !== core.groups.N;\r\n                        })) {\r\n                            var roots = core.Algebra.proots(eq);\r\n                            //if all the roots are integers then return those\r\n                            if(checkAll(roots, function (x) {\r\n                                return !core.Utils.isInt(x);\r\n                            })) {\r\n                                //roots have been calculates\r\n                                was_calculated = true;\r\n                                roots.map(function (x) {\r\n                                    add_to_result(new Symbol(x));\r\n                                });\r\n                            }\r\n                        }\r\n\r\n                        if(!was_calculated) {\r\n                            eqns = _.parse(eqns);\r\n                            if(eqns instanceof core.Equation)\r\n                                eqns = eqns.toLHS();\r\n\r\n                            //we can solve algebraically for degrees 1, 2, 3. The remainder we switch to Jenkins-\r\n                            if(deg === 1)\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                            else if(deg === 2) {\r\n                                add_to_result(_.expand(__.quad.apply(undefined, coeffs)));\r\n                            }\r\n\r\n                            else if(deg === 3) {\r\n                                var solutions = []; //set to blank\r\n                                //first try to factor and solve\r\n                                var factored = core.Algebra.Factor.factor(eqns);\r\n\r\n                                //if it was successfully factored\r\n                                var solutions = [];\r\n                                if(solutions.length > 0)\r\n                                    add_to_result(solutions);\r\n                                else\r\n                                    add_to_result(__.cubic.apply(undefined, coeffs));\r\n                            }\r\n\r\n                            else {\r\n                                /*\r\n                                 var sym_roots = csolve(eq, solve_for); \r\n                                 if(sym_roots.length === 0)\r\n                                 sym_roots = divnconsolve(eq, solve_for);\r\n                                 if(sym_roots.length > 0) \r\n                                 add_to_result(sym_roots);\r\n                                 else\r\n                                 */\r\n                                _A.proots(eq).map(add_to_result);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    // Attempt Newton\r\n                    // Since it's not a polynomial then we'll try to look for a solution using Newton's method\r\n                    var has_trig = eq.hasTrig();\r\n                    // we get all the points where a possible zero might exist.\r\n                    var points1 = __.getPoints(eq, 0.1);\r\n                    var points2 = __.getPoints(eq, 0.05);\r\n                    var points3 = __.getPoints(eq, 0.01);\r\n                    var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function (a, b) {\r\n                        return a - b;\r\n                    });\r\n                    var i, point, solution;\r\n\r\n                    // Compile the function\r\n                    var f = build(eq.clone());\r\n\r\n                    // First try to eliminate some points using bisection\r\n                    var t_points = [];\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        // See if there's a solution at this point\r\n                        solution = __.bisection(point, f);\r\n\r\n                        // If there's no solution then add it to the array for further investigation\r\n                        if(typeof solution === 'undefined') {\r\n                            t_points.push(point);\r\n                            continue;\r\n                        }\r\n\r\n                        // Add the solution to the solution set\r\n                        add_to_result(solution, has_trig);\r\n                    }\r\n\r\n                    // Reset the points to the remaining points\r\n                    points = t_points;\r\n\r\n                    // Build the derivative and compile a function\r\n                    var d = _C.diff(eq.clone());\r\n                    var fp = build(d);\r\n                    for(i = 0; i < points.length; i++) {\r\n                        point = points[i];\r\n\r\n                        add_to_result(__.Newton(point, f, fp), has_trig);\r\n                    }\r\n                    solutions.sort();\r\n                }\r\n                catch(e) {\r\n                    console.log(e);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            //The idea here is to go through the equation and collect the coefficients\r\n            //place them in an array and call the quad or cubic function to get the results\r\n            if(!eq.hasFunc(solve_for) && eq.isComposite()) {\r\n                try {\r\n                    var factored = core.Algebra.Factor.factor(eq.clone());\r\n\r\n                    if(factored.group === CB) {\r\n                        factored.each(function (x) {\r\n                            add_to_result(solve(x, solve_for));\r\n                        });\r\n                    }\r\n                    else {\r\n                        var coeffs = core.Utils.getCoeffs(eq, solve_for);\r\n\r\n                        var l = coeffs.length,\r\n                                deg = l - 1; //the degree of the polynomial\r\n                        //get the denominator and make sure it doesn't have x\r\n\r\n                        //handle the problem based on the degree\r\n                        switch(deg) {\r\n                            case 0:\r\n                                var separated = separate(eq);\r\n                                var lhs = separated[0],\r\n                                        rhs = separated[1];\r\n                                \r\n                                if(lhs.group === core.groups.EX) {\r\n                                    var log = core.Settings.LOG;\r\n                                    var expr_str = `${log}((${rhs})/(${lhs.multiplier}))/${log}(${lhs.value})/${lhs.power.multiplier}`;\r\n                                    add_to_result(_.parse(expr_str));\r\n                                }\r\n                                break;\r\n                            case 1:\r\n                                //nothing to do but to return the quotient of the constant and the LT\r\n                                //e.g. 2*x-1\r\n                                add_to_result(_.divide(coeffs[0], coeffs[1].negate()));\r\n                                break;\r\n                            case 2:\r\n                                add_to_result(__.quad.apply(undefined, coeffs));\r\n                                break;\r\n                            case 3:\r\n                                add_to_result(__.cubic.apply(undefined, coeffs));\r\n                                break;\r\n                            case 4:\r\n                                add_to_result(__.quartic.apply(undefined, coeffs));\r\n                                break;\r\n                            default:\r\n                                add_to_result(__.csolve(eq, solve_for));\r\n                                if(solutions.length === 0)\r\n                                    add_to_result(__.divideAndConquer(eq, solve_for));\r\n                        }\r\n\r\n                        if(solutions.length === 0) {\r\n                            //try factoring\r\n                            add_to_result(solve(factored, solve_for, solutions, depth));\r\n                        }\r\n                    }\r\n\r\n                }\r\n                catch(e) { /*something went wrong. EXITING*/\r\n                    ;\r\n                }\r\n            }\r\n            else {\r\n                try {\r\n                    var rw = __.rewrite(eq, null, solve_for);\r\n                    var lhs = rw[0];\r\n                    var rhs = rw[1];\r\n                    if(lhs.group === FN) {\r\n                        if(lhs.fname === 'abs') {\r\n                            add_to_result([rhs.clone(), rhs.negate()]);\r\n                        }\r\n                        else if(lhs.fname === 'sin') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('asin', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'cos') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('acos', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === 'tan') {\r\n                            //asin\r\n                            add_to_result(__.inverseFunctionSolve('atan', lhs, rhs));\r\n                        }\r\n                        else if(lhs.fname === core.Settings.LOG) {\r\n                            //ax+b comes back as [a, x, ax, b];\r\n                            var parts = explode(lhs.args[0], solve_for);\r\n                            //check if x is by itself\r\n                            var x = parts[1];\r\n                            if(x.group === S) {\r\n                                rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol('e'), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);\r\n                                var eq = new Equation(x, rhs).toLHS();\r\n                                add_to_result(solve(eq, solve_for));\r\n                            }\r\n                        }\r\n                        else\r\n                            add_to_result(_.subtract(lhs, rhs));\r\n                    }\r\n                    else {\r\n                        var neq = new Equation(lhs, rhs).toLHS(); //create a new equation\r\n\r\n                        if(neq.equals(eq))\r\n                            throw new Error('Stopping. No stop condition exists');\r\n                        add_to_result(solve(neq, solve_for));\r\n                    }\r\n                }\r\n                catch(error) {\r\n                    //Let's try this another way\r\n                    try {\r\n                        //1. if the symbol is in the form a*b*c*... then the solution is zero if \r\n                        //either a or b or c is zero.\r\n                        if(eq.group === CB)\r\n                            add_to_result(0);\r\n                        else if(eq.group === CP) {\r\n                            var separated = separate(eq);\r\n                            var lhs = separated[0],\r\n                                    rhs = separated[1];\r\n\r\n                            //reduce the equation\r\n                            if(lhs.group === core.groups.EX && lhs.value === solve_for) {\r\n                                //change the base of both sides\r\n                                var p = lhs.power.clone().invert();\r\n                                add_to_result(_.pow(rhs, p));\r\n                            }\r\n                        }\r\n                    }\r\n                    catch(error) {\r\n                        ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(cfact) {\r\n            solutions = solutions.map(function (x) {\r\n                return _.pow(x, new Symbol(cfact));\r\n            });\r\n        }\r\n\r\n        // Perform some cleanup but don't do it agains arrays, etc\r\n        // Check it actually evaluates to zero\r\n        if(isSymbol(eqns)) {\r\n            var knowns = {};\r\n            solutions = solutions.filter(function (x) {\r\n                try {\r\n                    knowns[solve_for] = x;\r\n                    var zero = Number(evaluate(eqns, knowns));\r\n\r\n                    // Allow symbolic answers\r\n                    if(isNaN(zero)) {\r\n                        return true;\r\n                    }\r\n                    return true;\r\n                }\r\n                catch(e) {\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n\r\n        return solutions;\r\n    };\r\n\r\n    //Register the functions for external use\r\n    nerdamer.register([\r\n        {\r\n            name: 'solveEquations',\r\n            parent: 'nerdamer',\r\n            numargs: -1,\r\n            visible: true,\r\n            build: function () {\r\n                return solve; //comment out to return a vector\r\n                /*\r\n                 return function() {\r\n                 return core.Utils.convertToVector(solve.apply(null, arguments));\r\n                 };\r\n                 */\r\n            }\r\n        },\r\n        {\r\n            name: 'solve',\r\n            parent: 'Solve',\r\n            numargs: 2,\r\n            visible: true,\r\n            build: function () {\r\n                return core.Solve.solve;\r\n            }\r\n        },\r\n        {\r\n            name: 'setEquation',\r\n            parent: 'Solve',\r\n            visible: true,\r\n            build: function () {\r\n                return setEq;\r\n            }\r\n        }\r\n    ]);\r\n    nerdamer.updateAPI();\r\n})();"],
  "mappings": "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",
  "names": ["y", "x", "vars", "e", "n", "sol", "has_trig", "parts", "p", "eq", "lhs", "rhs", "error"]
}
